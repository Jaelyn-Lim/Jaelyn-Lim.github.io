<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Supervisor 指令学习]]></title>
    <url>%2F2018%2F05%2F15%2Fsupervisor-learn%2F</url>
    <content type="text"><![CDATA[参考资料 * Python 进程管理工具 Supervisor 使用教程 Supervisor 使用简介 supervisor 安装、配置、常用命令 Supervisor重新加载配置启动新的进程 简介Supervisor 是一个进程管理工具，可以简单的进行进程的控制（启动，重启，停止等），可以设置网址，直接在浏览器上可视化的操作进程。 一般情况下，当我们需要以守护进程的方式启动某些进程的时候，例如后台任务（备份数据，同步数据，日志处理，消息推送等）和Web服务进程，经常被用来管理和启动一组Tornado进程实现负载均衡。 有两个重要的组成部分：supervisord和supervisorctl。 安装sudo pip install supervisor 创建配置文件这个命令可以将supervisor的默认配置输出到一个文件中，到时候直接在那上面修改会方便很多， echo_supervisord_conf &gt; /etc/supervisord.conf 箭头后面指向路径，如果出现没有权限的问题，可以使用这条命令 sudo su - root -c &quot;echo_supervisord_conf &gt; /etc/supervisord.conf&quot; 配置文件说明在默认的配置文件中，会将 supervisord.pid 以及 supervisor.sock 是放在 /tmp 目录下，但是 /tmp 目录是存放临时文件，里面的文件是会被 Linux 系统删除的，一旦这些文件丢失，就无法再通过 supervisorctl 来执行 restart 和 stop 命令了，将只会得到 unix:///tmp/supervisor.sock 不存在的错误 。（引用） 12345678910111213141516171819202122232425262728293031323334...unix_http_server];file=/tmp/supervisor.sock ; (the path to the socket file);修改为 /home/supervisor 目录，避免被系统删除file=/home/supervisor/supervisor.sock ; (the path to the socket file)...[supervisord];logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log);修改为 /var/log 目录，避免被系统删除logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log);日志文件多大时进行分割logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB);最多保留多少份日志文件logfile_backups=10 ; (num of main logfile rotation backups;default 10)loglevel=info ; (log level;default info; others: debug,warn,trace);pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid);修改为 /home/supervisor 目录，避免被系统删除pidfile=/home/supervisor/supervisord.pid ; (supervisord pidfile;default supervisord.pid)...;设置启动supervisord的用户，一般情况下不要轻易用root用户来启动，除非你真的确定要这么做;user=chrism ; (default is current user, required if root)...[supervisorctl]; 必须和&apos;unix_http_server&apos;里面的设定匹配;serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socket;修改为 /home/supervisor 目录，避免被系统删除serverurl=unix:///home/supervisor/supervisor.sock ; use a unix:// URL for a unix socket;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket;username=chris ; should be same as http_username if set;password=123 ; should be same as http_password if set... 使用浏览器来管理supervisor 同时提供了通过浏览器来管理进程的方法，只需要注释掉如下几行就可以了。 123456789;[inet_http_server] ; inet (TCP) server disabled by default;port=127.0.0.1:9001 ; (ip_address:port specifier, *:port for ;all iface);username=user ; (default is no username (open server));password=123 ; (default is no password (open server))[supervisorctl]...;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket;username=chris ; should be same as http_username if set;password=123 ; should be same as http_password if set 使用 include在配置文件的最后，有一个 [include] 的配置项，跟 Nginx 一样，可以 include 某个文件夹下的所有配置文件，这样我们就可以为每个进程或相关的几个进程的配置单独写成一个文件。 12[include]files = /etc/supervisor.d/*.ini 进程的配置样例123456789101112; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名[program:your_program_name]command=python server.py --port=9000;numprocs=1 ; 默认为1;process_name=%(program_name)s ; 默认为 %(program_name)s，即 [program:x] 中的 xdirectory=/home/python/tornado_server ; 执行 command 之前，先切换到工作目录user=oxygen ; 使用 oxygen 用户来启动该进程; 程序崩溃时自动重启，重启次数是有限制的，默认为3次autorestart=true redirect_stderr=true ; 重定向输出的日志stdout_logfile = /var/log/supervisor/tornado_server.logloglevel=info 启动 supervisord123456# 使用默认的配置文件 /etc/supervisord.confsupervisord# 明确指定配置文件supervisord -c /etc/supervisord.conf# 使用 user 用户启动 supervisordsupervisord -u user supervisorctl 命令介绍12345678910111213141516# 停止某一个进程，program_name 为 [program:x] 里的 xsupervisorctl stop program_name# 启动某个进程supervisorctl start program_name# 重启某个进程supervisorctl restart program_name# 结束所有属于名为 groupworker 这个分组的进程 (start，restart 同理)supervisorctl stop groupworker:# 结束 groupworker:name1 这个进程 (start，restart 同理)supervisorctl stop groupworker:name1# 停止全部进程，注：start、restart、stop 都不会载入最新的配置文件supervisorctl stop all# 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程supervisorctl reload# 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启supervisorctl update 更新配置文件12supervisorctl reread (只更新配置文件)supervisorctl update (只启动有改动的进程)]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 指令学习]]></title>
    <url>%2F2018%2F05%2F02%2Fubuntu-code-learning%2F</url>
    <content type="text"><![CDATA[Ubuntu 指令学习显示端口对应的信息12# 显示8081端口信息lsof -i:8081 杀死进程12# 杀死23919进程kill -9 23919 查询信息12# 在进程中查询新信息ps -aux | grep &quot;basic.py&quot; 显示结尾的信息12# 显示信息，并且在之间查询tail -f -n -10000 uwsgi.log | grep &quot;ERROR&quot; 更新信息，升级12345apt-get updateapt-get upgradeapt-get dist-upgrade upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来. dist-upgrade:可以聪明的解决相依性的问题,如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它. (所以通常这个会被认为是有点风险的升级) 查看磁盘空间大小12345678910111213141516171819202122232425262728293031323334# 查看磁盘剩余空间df -hl# 查看每个根路径的分区大小 df -h# 返回该目录的大小du -sh [目录名] # 返回该文件夹总M数du -sm [文件夹] # 查看更多功能df --help # 查看硬盘的分区sudo fdisk -l# 查看IDE硬盘信息 sudo hdparm -i /dev/hda# 查看STAT硬盘信息 sudo hdparm -I /dev/sda sudo apt-get install blktool sudo blktool /dev/sda id# 查看硬盘剩余空间 df -h #df -H# 查看目录占用空间 du -hs 目录名# 优盘没法卸载 sync fuser -km /media/usbdisk ubuntu 终端常用命令ctrl + l - 清屏 ctrl + c - 终止命令 ctrl + d - 退出 shell，好像也可以表示EOF ctrl + z - 将当前进程置于后台，fg还原。 ctrl + r - 从命令历史中找 ctrl + a - 光标移到行首 ctrl + e - 光标移到行尾 ctrl + u - 清除光标到行首的字符 ctrl + w - 清除光标之前一个单词 ctrl + k - 清除光标到行尾的字符 ctrl + t - 交换光标前两个字符 ctrl + y - 粘贴前一ctrl+u类命令删除的字符 ctrl + p - 上一条命令 ctrl + n - 下一条命令 ctrl + v - 输入控制字符 如ctrl+v ,会输入^M ctrl + f - 光标后移一个字符 ctrl + b - 光标前移一个字符 ctrl + h - 删除光标前一个字符]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的vim配置]]></title>
    <url>%2F2018%2F04%2F13%2Fmyvim%2F</url>
    <content type="text"><![CDATA[在这里保留下自己的vim配置 12345678910111213141516171819202122232425262728293031323334set nusyntax onset nocompatibleset confirmset mouse=aset tabstop=4set shiftwidth=4set expandtabset smarttabset autoindentset smartindentset hlsearchset showmatchset rulerset foldenableset foldmethod=manualautocmd InsertLeave * se noculautocmd InsertEnter * se culif version &gt;= 603 set helplang=cn set encoding=utf-8endif 需要在 vim ~/.vimrc 中配置，配置完成之后需要应用 source ~/.bashrc]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django过程中遇到的问题及解决方案]]></title>
    <url>%2F2018%2F04%2F03%2Fproblem-solving%2F</url>
    <content type="text"><![CDATA[​ 在学习过程中，遇到的一些问题和最后找的解决方案，在此记录保存，不定期更新。这其中的问题可能涉及到Django框架的操作，python语言的编写错误，或着uwsgi的一些错误，都在此记录。 UWSGI 出现 “invalid request block size: xxxx (max 4096)”的错误​ 对于uwsgi来说，默认会设置一个比较小的缓存（buffer 4k）来接收来接收每个请求的头信息,如果在日志中看见”invalid request block size”,它意味着你需要一个大一点的buffer。 ​ 简单的来说，就是URL的地址长度超过了4096个字符，而4096就是uwsgi配置中buffer-size的默认值，所以只需要将buffer-size改大一点即可。 可以在命令中加上buffer-size指出需要的大小 1uwsgi -x uwsgi.ini --buffer-size 32768 或者在配置文件中添加buffer-size = 8192 注意：如果你的日志中接收到了请求块大小为‘21573’，那这可能意味着你使用HTTP协议与一个使用uwsgi协议的实例进行通信。 ​ 问题基本解决，至于为什么这个问题是偶尔出现？那是因为openid登陆的时候会携带一个参数叫next_url，这个地址是用来指定登陆成功之后返回到哪里地址，如果这个next_url太长就会导致url地址超过4096，有时候next_url=/，即网站根地址，url地址长度就不会超过4096。另外还和openid返回的登陆人信息长度有关系，导致有些人从来不会出现这个错误，有些人偶尔出现这个问题。 参考：uwsgi部署到nginx出现invalid request block size: 4161 (max 4096) Django 数据库初始化时出现 django.core.exceptions.AppRegistryNotReady: Apps aren’t loaded yet.主要的报错原因是因为在数据库中使用了 12from django.contrib.auth import get_user_modelUser = get_user_model() ​ 来获得当前用户，这个是一个先查询的，就是说系统运行到这的时候，会先去查询这个用户类是否已经加载好，如果没有加载好就会出现这个错误。 目前没有想打一个比较好的办法解决，就初始阶段的解决方法有两个： 适当调整setting.py中INSTALLED_APPS的先后顺序，使得设计的AUTH_USER_MODEL比较先加载。 修改数据库代码，不这样获得用户，而是直接用字符串的方式获得 1from Project.settings import AUTH_USER_MODEL 之后在外键中直接使用 1base_info = models.OneToOneField(AUTH_USER_MODEL) Django中文编码错误问题​ 编码报错UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xb0 in position 1······ ​ 这类的问题，其中一个原因可能是在对方调用该接口的时候，传递过来的数据编码于本系统的编码格式不一致问题，在商量好双方的接口编码规则之后，可以尝试直接在出错问题的文件中修改系统的默认编码。 12345import sysdefaultencoding = 'utf-8'if sys.getdefaultencoding() != defaultencoding: reload(sys) sys.setdefaultencoding(defaultencoding)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WARNING REMOTE HOST IDENTIFICATION HAS CHANGED!]]></title>
    <url>%2F2018%2F03%2F17%2Fssh-remote%2F</url>
    <content type="text"><![CDATA[在SSH连接云主机的时候出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!在我们连接云主机的时候，相关的配置会保存在/Users/apple/.ssh中的known_hosts文件内，如果云主机修改等操作后，就有可能会出现在这个问题。 解决方式很简单，进入到这个文件内，将相关的IP删除，之后在重新连接，即可。 进入到相关文件 1cd ~/.ssh vim 操作 1vim known_hosts 删除对应的行 重新连接 也可以使用ssh-keygen -R &quot;IP&quot;命令，直接删除相关远程连接的云主机IP 不推荐直接删除这个文件 known_hosts是记录远程主机的公钥的文件]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 虚拟环境]]></title>
    <url>%2F2018%2F03%2F10%2Fpython-vertualenv%2F</url>
    <content type="text"><![CDATA[python 虚拟环境设置virtualenv安装pip install virtualenv 创建虚拟环境virtualenv [新环境名] 使用source ./bin/activate 执行所创建的虚拟环境下的根目录的activate文件 退出deactivate 删除直接删除创建的文件夹就行 virtualenvwrapper安装pip install virtualenvwrapper 配置 创建虚拟环境管理目录: mkdir $HOME/.local/virtualenvs 在~/.bashrc中添加行： 12345678910export VIRTUALENV_USE_DISTRIBUTE=1export WORKON_HOME=$HOME/.local/virtualenvsif [ -e $HOME/.local/bin/virtualenvwrapper.sh ];then source $HOME/.local/bin/virtualenvwrapper.shelse if [ -e /usr/local/bin/virtualenvwrapper.sh ];then source /usr/local/bin/virtualenvwrapper.sh fifiexport PIP_VIRTUALENV_BASE=$WORKON_HOMEexport PIP_RESPECT_VIRTUALENV=true 启动 virtualenvwrapper: source ~/.bashrc 使用 创建虚拟环境 mkvirtualenv [环境名] 也可以在创建的时候加上参数，确定python版本，workon [环境名] --python=python3 删除 rmvirtualenv [环境名] 激活 workon [环境名] 退出 deactivate 列出所有环境 workon 或者 lsvirtualenv -b 查看所有指令virtualenvwrapper —help]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 05]]></title>
    <url>%2F2018%2F02%2F23%2Fdjango-rest-vue05%2F</url>
    <content type="text"><![CDATA[分类 view 123456789class CategoryViewset(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): """ list: 商品分类列表数据 retrieve: 获取商品分类详情 """ queryset = GoodsCategory.objects.filter(category_type=1) serializer_class = CategorySerializer Serializer 1234class CategorySerializer(serializers.ModelSerializer): class Meta: model = GoodsCategory fields = "__all__" url 12#配置category的urlrouter.register(r'categorys', CategoryViewset, base_name="categorys") 跨域问题django-cors-headers 官网 下载安装1pip install django-cors-headers 配置 INSTALLED_APPS 12345INSTALLED_APPS = ( ... 'corsheaders', ...) middleware 123456MIDDLEWARE = [ # Or MIDDLEWARE_CLASSES on Django &lt; 1.10 ... 'corsheaders.middleware.CorsMiddleware', # 只要添加这个 'django.middleware.common.CommonMiddleware', ...] 要放在CommonMiddleware前面 设置CORS_ORIGIN_ALLOW_ALL 1CORS_ORIGIN_ALLOW_ALL = True 用户登录和注册权限认证（DRF自带的token认证） Authentication setting123456REST_FRAMEWORK = &#123; 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.BasicAuthentication', 'rest_framework.authentication.SessionAuthentication', )&#125; 对应的Authentication也有三种，TokenAuthentication在前后端分离的系统中比较常见 TokenAuthentication 1234INSTALLED_APPS = ( ... 'rest_framework.authtoken') 创建对应的Token1234from rest_framework.authtoken.models import Tokentoken = Token.objects.create(user=...)print token.key 获取token的URL配置1234from rest_framework.authtoken import viewsurlpatterns += [ url(r'^api-token-auth/', views.obtain_auth_token)] 在输入用户名密码后会返回对应的token，用于前端保存使用，并且在提交的时候将这个token附加在httpheader中，确保用户的登录并且用于权限认证 在httpheader中添加token1Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b 在setting中配置token的认证方式1234567REST_FRAMEWORK = &#123; 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.BasicAuthentication', 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.TokenAuthentication', )&#125; 将token认证放到view中 将setting中的&#39;rest_framework.authentication.TokenAuthentication&#39;去除 在view中添加认证authentication_classes = (TokenAuthentication, ) 1234567891011from rest_framework.authentication import TokenAuthenticationclass GoodsListViewSet(CacheResponseMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination authentication_classes = (TokenAuthentication, ) JWT方式用户认证参考： 什么是 JWT – JSON WEB TOKEN JSON Web Token - 在Web应用间安全地传递信息 前后端分离之JWT用户认证 REST framework JWT Auth 安装1pip install djangorestframework-jwt 支持 Python (2.7, 3.3, 3.4, 3.5) Django (1.8, 1.9, 1.10) Django REST Framework (3.0, 3.1, 3.2, 3.3, 3.4, 3.5) setting12345678910REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ), 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework_jwt.authentication.JSONWebTokenAuthentication', 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication', ),&#125; url123456789from rest_framework_jwt.views import obtain_jwt_token#...urlpatterns = [ '', # ... url(r'^api-token-auth/', obtain_jwt_token),] 请求1curl -H "Authorization: JWT &lt;your_token&gt;" http://localhost:8000/protected-url/ 配置12345import datetimeJWT_AUTH = &#123; 'JWT_EXPIRATION_DELTA': datetime.timedelta(days=7), 'JWT_AUTH_HEADER_PREFIX': 'JWT',&#125; 自定义用户认证 setting 123AUTHENTICATION_BACKENDS = ( 'users.views.CustomBackend',) view 中的逻辑 1234567891011121314151617from django.contrib.auth.backends import ModelBackendfrom django.contrib.auth import get_user_modelfrom django.db.models import QUser = get_user_model()class CustomBackend(ModelBackend): """ 自定义用户验证 """ def authenticate(self, username=None, password=None, **kwargs): try: user = User.objects.get(Q(username=username)|Q(mobile=username)) if user.check_password(password): return user except Exception as e: return None 简单的信息发送12345678910111213141516171819202122232425import jsonimport requestsclass YunPian(object): def __init__(self, api_key): self.api_key = api_key self.single_send_url = "******" def send_sms(self, code, mobile): parmas = &#123; "apikey": self.api_key, "mobile": mobile, "text": "&#123;code&#125;。如非本人操作，请忽略本短信".format(code=code) &#125; response = requests.post(self.single_send_url, data=parmas) re_dict = json.loads(response.text) return re_dictif __name__ == "__main__": yun_pian = YunPian("****") yun_pian.send_sms("2017", "****") 可以直接在百度搜索本地ip，就能获得本机对外的ip地址 Serializer信息验证12345678code = serializers.CharField(required=True, write_only=True, max_length=4, min_length=4,label="验证码", error_messages=&#123; "blank": "请输入验证码", "required": "请输入验证码", "max_length": "验证码格式错误", "min_length": "验证码格式错误" &#125;, help_text="验证码") Validators123456from rest_framework.validators import UniqueValidatorslug = SlugField( max_length=100, validators=[UniqueValidator(queryset=BlogPost.objects.all())]) 例子： 1username = serializers.CharField(label="用户名", help_text="用户名", required=True, allow_blank=False, validators=[UniqueValidator(queryset=User.objects.all(), message="用户已经存在")]) 信号量post_save signal123456789from django.conf import settingsfrom django.db.models.signals import post_savefrom django.dispatch import receiverfrom rest_framework.authtoken.models import Token@receiver(post_save, sender=settings.AUTH_USER_MODEL)def create_auth_token(sender, instance=None, created=False, **kwargs): if created: Token.objects.create(user=instance) 例子： 12345678910111213from django.db.models.signals import post_savefrom django.dispatch import receiverfrom rest_framework.authtoken.models import Tokenfrom django.contrib.auth import get_user_modelUser = get_user_model()@receiver(post_save, sender=User)def create_user(sender, instance=None, created=False, **kwargs): if created: password = instance.password instance.set_password(password) instance.save() CurrentUserDefault 获取当前用户 123owner = serializers.HiddenField( default=serializers.CurrentUserDefault()) UniqueTogetherValidator 联合索引 123456789101112131415from rest_framework.validators import UniqueTogetherValidatorclass ExampleSerializer(serializers.Serializer): # ... class Meta: # ToDo items belong to a parent list, and have an ordering defined # by the 'position' field. No two items in a given list may share # the same position. validators = [ UniqueTogetherValidator( queryset=ToDoItem.objects.all(), fields=('list', 'position') message="巴拉巴拉" ) ] 也可以在数据库中添加联合索引 123456789101112131415class UserFav(models.Model): """ 用户收藏 """ user = models.ForeignKey(User, verbose_name="用户") goods = models.ForeignKey(Goods, verbose_name="商品", help_text="商品id") add_time = models.DateTimeField(default=datetime.now, verbose_name=u"添加时间") class Meta: verbose_name = '用户收藏' verbose_name_plural = verbose_name unique_together = ("user", "goods") def __str__(self): return self.user.username 用户权限认证IsAuthenticated123456789101112from rest_framework.permissions import IsAuthenticatedfrom rest_framework.response import Responsefrom rest_framework.views import APIViewclass ExampleView(APIView): permission_classes = (IsAuthenticated,) def get(self, request, format=None): content = &#123; 'status': 'request was permitted' &#125; return Response(content) 自定义权限12345678910111213141516from rest_framework import permissionsclass IsOwnerOrReadOnly(permissions.BasePermission): """ Object-level permission to only allow owners of an object to edit it. Assumes the model instance has an `owner` attribute. """ def has_object_permission(self, request, view, obj): # Read permissions are allowed to any request, # so we'll always allow GET, HEAD or OPTIONS requests. if request.method in permissions.SAFE_METHODS: return True # Instance must have an attribute named `owner`. return obj.owner == request.user view: 12345678class UserFavViewset(mixins.CreateModelMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet): permission_classes = (IsAuthenticated, IsOwnerOrReadOnly) serializer_class = UserFavSerializer def get_queryset(self): return UserFav.objects.filter(user=self.request.user) 缓存DRF增强安装1pip install drf-extensions 在view中添加CacheResponseMixin 12class GoodsListViewSet(CacheResponseMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): pass setting的一些配置（过期时间） 123REST_FRAMEWORK_EXTENSIONS = &#123; 'DEFAULT_CACHE_RESPONSE_TIMEOUT': 60 * 15&#125; django redisdjango-redis 中文文档 API限速 Throttling 在setting中配置 12345678910REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle' ), 'DEFAULT_THROTTLE_RATES': &#123; 'anon': '100/day', 'user': '1000/day' &#125;&#125; 在view中 123456789101112from rest_framework.response import Responsefrom rest_framework.throttling import UserRateThrottlefrom rest_framework.views import APIViewclass ExampleView(APIView): throttle_classes = (UserRateThrottle,) def get(self, request, format=None): content = &#123; 'status': 'request was permitted' &#125; return Response(content) sentry错误日志 sentry sentry github django sentry 1pip install raven --upgrade setting 12345678910INSTALLED_APPS = ( 'raven.contrib.django.raven_compat',)import osimport ravenRAVEN_CONFIG = &#123; 'dsn': 'https://&lt;key&gt;:&lt;secret&gt;@sentry.io/&lt;project&gt;',&#125; celery异步 django通过celery添加异步任务]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django Rest Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 04]]></title>
    <url>%2F2018%2F02%2F20%2Fdjango-rest-vue04%2F</url>
    <content type="text"><![CDATA[使用类继承View的方式写接口导入基础view1from django.views.generic.base import View 在类中继承12class GoodsListView(View): pass 数据字典化的方式（序列化）传统查询-循环-赋值方式12345678910111213json_list = []goods = Goods.objects.all()[:10]for good in goods: json_dict = &#123;&#125; json_dict["name"] = good.name json_dict["category"] = good.category.name json_dict["market_price"] = good.market_price json_dict["add_time"] = good.add_time # 这里会出现错误，报错原因是时间格式不能序列化成json json_list.append(json_dict)from django.http import HttpResponseimport jsonreturn HttpResponse(json.dumps(json_list), content_tyoe="application/json") 使用Django自带的model_to_dict12345678from django.forms.models import model_to_dict for good in goods: json_dict = model_to_dict(good) # 这里也有可能报错，有些字段不能序列化 json_list.append(json_dict)from django.http import HttpResponseimport jsonreturn HttpResponse(json.dumps(json_list), content_tyoe="application/json") 使用serializers12345678import jsonfrom django.core import serializersjson_data = serializers.serialize('json', goods)json_data = json.loads(json_data)from django.http import JsonResponsereturn JsonResponse(json_data, safe=False) Django rest Framework Django REST framework 一些依赖包The following packages are optional: coreapi (1.32.0+) - Schema generation support. Markdown (2.1.0+) - Markdown support for the browsable API. django-filter (1.0.1+) - Filtering support. django-crispy-forms - Improved HTML display for filtering. django-guardian (1.1.1+) - Object level permissions support. 安装12345pip install django-guardianpip install coreapipip install django-filterpip install --upgrade django-crispy-formspip install markdown 注意这些包一定要装，不然后面有些依赖会报错 使用文档（documentation） 在url.py文件中引入 1from rest_framework.documentation import include_docs_urls 导入该url，注意结尾不要有“/” 1234urlpatterns = [ # ... url(r'docs/', include_docs_urls(title="doc")),] 一些初始化setting.py文件12345INSTALLED_APPS = [ # ... 'rest_framework', 'crispy_forms',] url.py文件123urlpatterns = [ url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')),] 使用 class-based views（基础的view）使用自己的Serializer（参考） 在对应的app下新建文件，serializers.py 基本内容内容 1234567from rest_framework import serializersclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) linenos = serializers.BooleanField(required=False) 在view文件中 1234567891011121314from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework.views import APIViewfrom rest_framework.response import Responseclass SnippetList(APIView): """ List all snippets, or create a new snippet. """ def get(self, request, format=None): snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) 备用： 123456789STATIC_URL = '/static/'MEDIA_URL = "/media/"STATICFILES_DIRS = ( os.path.join(BASE_DIR, "static"),)MEDIA_ROOT = os.path.join(BASE_DIR, "media") 在setting.py中如果配置了这个媒体路径，Django rest framework 就会在媒体路径之上加上这个路径，这样就能获得图片路径的完整地址 将数据保存到数据库中 在serializers.py文件中，需要保存的字段中，覆写create方法 作为给前端添加数据的一个接口 12345678910111213from rest_framework import serializersfrom snippets.models import Snippetclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) def create(self, validated_data): """ Create and return a new `Snippet` instance, given the validated data. """ return Snippet.objects.create(**validated_data) 在view中添加一个post方法 1234567891011121314151617181920212223from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom django.http import Http404from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework import statusclass SnippetList(APIView): """ List all snippets, or create a new snippet. """ def get(self, request, format=None): snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) def post(self, request, format=None): serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 使用ModelSerializers 在serializer中 1234567from rest_framework import serializersfrom snippets.models import Snippetclass SnippetSerializer(serializers.ModelSerializer): class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 注意：名字要和model中的一致，包括一开始使用的验证，名字也要相同 取出所有字段123class Meta: model = Snippet fields = "__all__" serializers的“外键” 只要在对应的serializers中添加字段覆盖对应的字段就行 1234567891011121314from rest_framework import serializersfrom snippets.models import Snippet, Categoryclass CategorySerializer(serializers.ModelSerializer): class Meta: model = GoodsCategory fields = "__all__"class SnippetSerializer(serializers.ModelSerializer): Category = CategorySerializer() class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 使用 mixins 和 GenericAPIViewGenericAPIView这是用的非常多的一个view，也是非常重要的view 1234567891011121314from rest_framework import mixinsfrom rest_framework import genericsclass SnippetList(mixins.ListModelMixin, mixins.CreateModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) 同样的，在listapiview中也有上面的方法，可以直接继承这个view，减少代码量 1234567from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework import genericsclass SnippetList(generics.ListCreateAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer 一共有以下的view可以继承 配置分页在setting中配置123REST_FRAMEWORK = &#123; 'PAGE_SIZE': 10,&#125; 在view中配置这个配置可以自定义自己的分页配置，这样的话就可以不用在setting中配置了，直接在view中配置 12345678910111213141516171819from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(generics.ListAPIView): """ 商品列表页, 分页， 搜索， 过滤， 排序 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination 使用viewsets1from rest_framework import viewsets 里面的view比较少 GenericViewSet 在view中继承ListModelMixin和GenericViewSet 12345678910from rest_framework import viewsetsfrom rest_framework import mixinsclass GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页, 分页， 搜索， 过滤， 排序 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination viewset的url配置方法 在url.py文件中配置url 12345678910from snippets.views import SnippetViewSetsnippet_list = SnippetViewSet.as_view(&#123; 'get': 'list', 'post': 'create'&#125;)urlpatterns = [ url(r'^snippets/$', snippet_list, name='snippet-list'),] 使用Routers 配置URL12345678910111213from django.conf.urls import url, includefrom rest_framework.routers import DefaultRouterfrom snippets import views# Create a router and register our viewsets with it.router = DefaultRouter()router.register(r'snippets', views.SnippetViewSet)router.register(r'users', views.UserViewSet)# The API URLs are now determined automatically by the router.urlpatterns = [ url(r'^', include(router.urls))] 一些view的继承 过滤功能 在view中添加 12345678910class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页, 分页， 搜索， 过滤， 排序 """ # queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination def get_queryset(self): return Goods.object.filter(shop_price__gt=100) FilteringDjangoFilterBackend官方文档 django-filter 步骤 首先安装 1pip install django-filter 将django-filter加到INSTALLED_APPS中 1234INSTALLED_APPS = [ # ... 'django_filters',] 设置个默认值（可以不设置） 123REST_FRAMEWORK = &#123; 'DEFAULT_FILTER_BACKENDS': ('django_filters.rest_framework.DjangoFilterBackend',)&#125; 使用 12345from django_filters.rest_framework import DjangoFilterBackendclass UserListView(generics.ListAPIView): # ... filter_backends = (DjangoFilterBackend,) 如果使用过滤器，就不需要使用get_queryset方法 例子： 123456789101112131415161718192021from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerfrom django_filters.rest_framework import DjangoFilterBackendclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend,) filter_fields = ('name', 'shop_price') 自定义Filters 新建filters.py文件 123456789101112from rest_framework import genericsfrom django_filters import rest_framework as filtersfrom myapp import Productclass ProductFilter(filters.FilterSet): min_price = filters.NumberFilter(name="price", lookup_expr='gte') max_price = filters.NumberFilter(name="price", lookup_expr='lte') class Meta: model = Product fields = ['category', 'in_stock', 'min_price', 'max_price'] 例子： 12345678910111213141516171819202122import django_filtersfrom django.db.models import Qfrom .models import Goodsclass GoodsFilter(django_filters.rest_framework.FilterSet): """ 商品的过滤类 """ pricemin = django_filters.NumberFilter(name='shop_price', help_text="最低价格",lookup_expr='gte') pricemax = django_filters.NumberFilter(name='shop_price', lookup_expr='lte') top_category = django_filters.NumberFilter(method='top_category_filter') def top_category_filter(self, queryset, name, value): return queryset.filter(Q(category_id=value)|Q(category__parent_category_id=value)|Q(category__parent_category__parent_category_id=value)) class Meta: model = Goods fields = ['pricemin', 'pricemax', 'is_hot', 'is_new'] 将view更改 1234567891011# ... class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend,) # filter_fields = ('name', 'shop_price') filter_class = GoodsFilter 模糊查询 1name = django_filters.CharFilter(name='name', lookup_expr='icontains') 不加lookup_expr=’icontains’这个字段就是全匹配 SearchFilter12345class UserListView(generics.ListAPIView): queryset = User.objects.all() serializer_class = UserSerializer filter_backends = (filters.SearchFilter,) search_fields = ('username', 'email') 例子：(view.py) 1234567891011121314151617181920212223from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerfrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework import filtersclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend, filters.SearchFilter) filter_class = GoodsFilter search_fields = ('^name', 'goods_brief', 'goods_desc') 在不同字段上使用下面的一些符号可以达到不同的效果 ‘^’ Starts-with search. ‘=’ Exact matches. ‘@’ Full-text search. (Currently only supported Django’s MySQL backend.) ‘$’ Regex search. OrderingFilter12345class UserListView(generics.ListAPIView): queryset = User.objects.all() serializer_class = UserSerializer filter_backends = (filters.OrderingFilter,) ordering_fields = ('username', 'email') 例子： 123456789101112131415161718192021222324from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerfrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework import filtersclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter) filter_class = GoodsFilter search_fields = ('^name', 'goods_brief', 'goods_desc') ordering_fields = ('sale', 'time') API GuideThe API guide is your complete reference manual to all the functionality provided by REST framework. Requests Responses Views Generic views Viewsets Routers Parsers Renderers Serializers Serializer fields Serializer relations Validators Authentication Permissions Throttling Filtering Pagination Versioning Content negotiation Metadata Schemas Format suffixes Returning URLs Exceptions Status codes Testing Settings]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django Rest Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 03]]></title>
    <url>%2F2018%2F02%2F17%2Fdjango-rest-vue03%2F</url>
    <content type="text"><![CDATA[前后端分离的优缺点优点 pc，app，pad多端适应 SPA开发模式开始流行 前后端开发职责不清 开发效率问题，前后端互相等待 前端一直配合着后端，能力受限 后端开发语言和模版高度耦合，导致开发语言依赖严重 缺点 前后端学习门槛增加 数据依赖导致文档重要性增加 前端工作量加大 SEO的难度加大 后端开发模式迁移增加成本 Restful API restful api目前是前后端分离最佳实践 轻量，直接通过http，不需要额外的协议，post/get/put/delete操作 面向资源，具有解释性 数据描述简单，一般通过json或者xml做数据通信 参考 理解RESTful架构 RESTful API 设计指南 几个概念前端工程化 浅析前端工程化 前端工程化小记 前端优化带来的思考，浅谈前端工程化 数据双向绑定 mvvm vue.js MVC，MVP 和 MVVM 的图示 组件化开发 前端组件化开发 什么叫组件化开发？ vue开发的几个概念webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 中文官网 vue，vuex，vue-router，axios vue全家桶 vue.js ES6，babel ES6语法，babel可以将ES6转换成ES5 《ECMAScript 6 入门》]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 02]]></title>
    <url>%2F2018%2F02%2F16%2Fdjango-rest-vue02%2F</url>
    <content type="text"><![CDATA[参考： Unofficial Windows Binaries for Python Extension Packages Django REST framework 官网 安装进入到虚拟环境 pip install djangorestframework 安装Django，默认安装最新版本 pip install -i https://pypi.douban.com/simple django 安装markdown，Markdown support for the browsable API. pip install markdown 还需要安装 pip install django-filter 使用mysqlsetting.py 文件中修改：1234567891011121314DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'teacherAndStudentSystem', 'USER': 'root', 'PASSWORD': '', 'HOST': 'localhost', 'PORT': '3306', 'OPTIONS': &#123; 'charset': 'utf8mb4', 'init_command': 'SET default_storage_engine=INNODB;' &#125;, &#125;&#125; 在 MySQLWorkbench 中新建数据库 安装python的mysql驱动pip install mysqlclient 运行发现报错 “django.db.utils.OperationalError: (1193, “Unknown system variable ‘storage_engine’”)” 参考： 博客园 stackoverflow 因为版本的关系，所以只需要改为 SET default_storage_engine=INNODB; 即可 这个表示选择另一种连接方式，后面使用第三方登录的时候要用上 安装 pillowpip install pillow 这个是图形第三方插件 创建apps的package注意需要创建的是Python Package，而不是Directory 修改setting将apps加入到python的根搜索路径下 12345678import osimport sys# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, BASE_DIR)sys.path.insert(0, os.path.join(BASE_DIR, 'apps'))sys.path.insert(0, os.path.join(BASE_DIR, 'extra_apps')) 目前项目目录： vue项目安装需要的包在vue项目的根目录下执行 cnpm install 或 npm install 会生成一个model_modules的文件夹 运行cnpm run dev 或使用 npm run dev 设计app和models富文本编辑器Django-UEditor 参考 Django集成百度富文本编辑器uEditor 对应代码应用 把这第三方包复制到项目中 在setting中设置，加入改包 123456789INSTALLED_APPS = [ 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'users.apps.UsersConfig', 'DjangoUeditor',] 在模型类中导入 1from DjangoUeditor.models import UEditorField 模型中使用 12345678goods_desc = UEditorField( verbose_name=u"内容", imagePath="goods/images/", width=1000, height=300, filePath="goods/files/", default='') 模型类例子在线购物平台的商品模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142from datetime import datetimefrom django.db import modelsfrom DjangoUeditor.models import UEditorField# Create your models here.class GoodsCategory(models.Model): """ 商品类别 """ CATEGORY_TYPE = ( (1, "一级类目"), (2, "二级类目"), (3, "三级类目"), ) name = models.CharField(default="", max_length=30, verbose_name="类别名", help_text="类别名") code = models.CharField(default="", max_length=30, verbose_name="类别code", help_text="类别code") desc = models.TextField(default="", verbose_name="类别描述", help_text="类别描述") category_type = models.IntegerField(choices=CATEGORY_TYPE, verbose_name="类目级别", help_text="类目级别") parent_category = models.ForeignKey("self", null=True, blank=True, verbose_name="父类目级别", help_text="父目录", related_name="sub_cat") is_tab = models.BooleanField(default=False, verbose_name="是否导航", help_text="是否导航") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = "商品类别" verbose_name_plural = verbose_name def __str__(self): return self.nameclass GoodsCategoryBrand(models.Model): """ 品牌名 """ category = models.ForeignKey(GoodsCategory, related_name='brands', null=True, blank=True, verbose_name="商品类目") name = models.CharField(default="", max_length=30, verbose_name="品牌名", help_text="品牌名") desc = models.TextField(default="", max_length=200, verbose_name="品牌描述", help_text="品牌描述") image = models.ImageField(max_length=200, upload_to="brands/") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = "品牌" verbose_name_plural = verbose_name db_table = "goods_goodsbrand" def __str__(self): return self.nameclass Goods(models.Model): """ 商品 """ category = models.ForeignKey(GoodsCategory, verbose_name="商品类目") goods_sn = models.CharField(max_length=50, default="", verbose_name="商品唯一货号") name = models.CharField(max_length=100, verbose_name="商品名") click_num = models.IntegerField(default=0, verbose_name="点击数") sold_num = models.IntegerField(default=0, verbose_name="商品销售量") fav_num = models.IntegerField(default=0, verbose_name="收藏数") goods_num = models.IntegerField(default=0, verbose_name="库存数") market_price = models.FloatField(default=0, verbose_name="市场价格") shop_price = models.FloatField(default=0, verbose_name="本店价格") goods_brief = models.TextField(max_length=500, verbose_name="商品简短描述") goods_desc = UEditorField(verbose_name=u"内容", imagePath="goods/images/", width=1000, height=300, filePath="goods/files/", default='') ship_free = models.BooleanField(default=True, verbose_name="是否承担运费") goods_front_image = models.ImageField(upload_to="goods/images/", null=True, blank=True, verbose_name="封面图") is_new = models.BooleanField(default=False, verbose_name="是否新品") is_hot = models.BooleanField(default=False, verbose_name="是否热销") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '商品' verbose_name_plural = verbose_name def __str__(self): return self.nameclass IndexAd(models.Model): category = models.ForeignKey(GoodsCategory, related_name='category',verbose_name="商品类目") goods =models.ForeignKey(Goods, related_name='goods') class Meta: verbose_name = '首页商品类别广告' verbose_name_plural = verbose_name def __str__(self): return self.goods.nameclass GoodsImage(models.Model): """ 商品轮播图 """ goods = models.ForeignKey(Goods, verbose_name="商品", related_name="images") image = models.ImageField(upload_to="", verbose_name="图片", null=True, blank=True) add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '商品图片' verbose_name_plural = verbose_name def __str__(self): return self.goods.nameclass Banner(models.Model): """ 轮播的商品 """ goods = models.ForeignKey(Goods, verbose_name="商品") image = models.ImageField(upload_to='banner', verbose_name="轮播图片") index = models.IntegerField(default=0, verbose_name="轮播顺序") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '轮播商品' verbose_name_plural = verbose_name def __str__(self): return self.goods.nameclass HotSearchWords(models.Model): """ 热搜词 """ keywords = models.CharField(default="", max_length=20, verbose_name="热搜词") index = models.IntegerField(default=0, verbose_name="排序") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '热搜词' verbose_name_plural = verbose_name def __str__(self): return self.keywords 自定义User类 在模型类中导入 1from django.contrib.auth.models import AbstractUser 继承该AbstractUser类 12class UserProfile(AbstractUser): pass 引用外键 在另一个模型类中导入 1from django.contrib.auth import get_user_model 在外键中使用 1234567User = get_user_model()class ShoppingCart(models.Model): """ 购物车 """ user = models.ForeignKey(User, verbose_name=u"用户") 独立使用Django的model进行一些初始化123456789import sysimport ospwd = os.path.dirname(os.path.realpath(__file__))sys.path.append(pwd+"../")os.environ.setdefault("DJANGO_SETTINGS_MODULE", "Project.settings")import djangodjango.setup() 调用123from goods.models import GoodsCategoryall_categorys = GoodsCategory.objects.all() 顺序不能错 让Django识别媒体文件在settings.py中设置12MEDIA_URL = "/media/"MEDIA_ROOT = os.path.join(BASE_DIR, "media") 在urls.py中配置1234567from Project.settings import MEDIA_ROOTfrom django.views.static import serveurlpatterns = [ # ...more url(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;"document_root": MEDIA_ROOT&#125;),] 目前项目目录]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 01]]></title>
    <url>%2F2018%2F02%2F14%2Fdjango-rest-vue01%2F</url>
    <content type="text"><![CDATA[需要下载的资源 Pycharm WebStorm Node.js Mysql Workbench Pycharm 快捷启动（Linux） vim ~/.bashrc alias pycharm=&quot;bash /hom/bobby/Downloads/pycharm-2016.3.2/bin/pycharm.sh&quot; source ~/.bashrc pycharm Mysql 管理工具 Navicat Mysql Workbench Mysql 安装（Linux）获取安装包sudo apt-get install mysql-server 查看mysql的状态ps aux|grep mysqld 看是否有启动成功，并且可以查看端口地址 进入mysql shell中mysql -uroot -p 之后输入登录密码 mysql shell 的一些操作显示数据库show databases; 退出exit; 配置mysqlvim /etc/mysql/mysql.conf.d/mysqld.cnf 修改其中的 bind-address 配置，将IP改为0.0.0.0 重启mysqlsudo service mysql restart 修改用户权限GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION; 刷新用户权限 flush privileges; 字符集及排序规则 使用 utf8 -- UTF-8 Unicode 以及 utf8_general_ci 安装python（Linux） 安装的时候可以使用 python 豆瓣镜像 -i https://pypi.douban.com/simple 获取python3版本sudo apt-get install python3.5 虚拟环境安装sudo apt-get install python-virtualenv 使用虚拟环境virtualenv py2_env 会创建目录为py2_env的文件夹在该目录下 ps: 移除文件夹 rm -r py2_env/或 rm -f py2_env移除文件，慎用rm -rf py2_env 进入虚拟环境source py2_env/bin/activate 退出虚拟环境deactivate 创建python3的虚拟环境virtualenv -p python3 py3_env 安装pip3版本sudo apt-get install python3-pip 遇到 “OSError: Command /home/ubuntu/Myvirtualenv/py2_env/bin/python2 - setuptools pkg_resources pip wheel failed with error code 1”这个问题，解决方法： export LC_ALL=&quot;en_US.UTF-8&quot; export LC_CTYPE=&quot;en_US.UTF-8&quot; pip install setuptools 参考： setuptools pkg_resources pip wheel failed with error code 1 更新pip版本pip install --upgrade pip 虚拟环境管理安装pip install virtualenvwrapper 查找路径sudo find / -name virtualenvwrapper.sh /home/ubuntu/.local/bin/virtualenvwrapper.sh 配置 进入vim ~/.bashrc 在最后一行添加 export WORKON_HOME=$HOME/.virtualenvssource /home/ubuntu/.local/bin/virtualenvwrapper.sh ESC :wq保存 source ~/.bashrc 运行生效 创建虚拟环境mkvirtualenv py2_workon_env 目录安装所在地cd ~/.virtualenvs 使用 workon 查找全部的虚拟目录 workon py2_workon_env 使用该虚拟目录 deactivate 退出虚拟环境 创建python3的虚拟环境mkvirtualenv --python=python3 py3_workon_env ubuntu@VM-65-204-ubuntu:~$ workonpy2_workon_envpy3_workon_env 安装 Node.js参考： https://nodejs.org/dist/v8.9.3/ nodejs download Linux（Ubuntu）下安装NodeJs linux下安装nodejs+express(最新版) Linux下nodejs的安装配置 安装依赖包 sudo apt-get install g++ sudo apt-get install libssl-dev sudo apt-get install build-essential 下载压缩包wget https://nodejs.org/dist/v8.9.3/node-v8.9.3.tar.gz 解压tar zxvf node-v8.9.3.tar.gz 移动文件 mv source_file new_file 编译文件 进入到node-v8.9.3文件里 ./configure make 安装make install 修改环境配置参考 尝试 sudo apt-get install nodejs-legacy sudo apt-get install npm cnpm 淘宝 NPM 镜像 可以使用这个代替npm，国内镜像，下载速度可以更快 安装htopsudo apt-get install htop 可以查看系统运行的状态]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Httpie]]></title>
    <url>%2F2018%2F02%2F08%2Fhttpie%2F</url>
    <content type="text"><![CDATA[关于 HTTPie （读aych-tee-tee-pie）是一个 HTTP 的命令行客户端。 其目标是让 CLI 和 web 服务之间的交互尽可能的人性化。 这个工具提供了简洁的 http 命令，允许通过自然的语法发送任意 HTTP 请求数据，展示色彩化的输出。 HTTPie 可用于与 HTTP 服务器做测试、调试和常规交互。 特点 直观的语法 格式化和色彩化的终端输出 内置 JSON 支持 支持上传表单和文件 HTTPS、代理和认证 任意请求数据 自定义头部 持久性会话 类 Wget 下载 支持 Python 2.6, 2.7 和 3.x 支持 Linux, Mac OS X 和 Windows 插件 文档 测试覆盖率 安装pip install httpie 参考 HTTPie 工具使用入门 官方文档]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>httpie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Byobu "多窗口"的Terminal]]></title>
    <url>%2F2018%2F02%2F07%2Fbyobu%2F</url>
    <content type="text"><![CDATA[测试密码工具，密码是： lim U2FsdGVkX19kAjk/krG8osh24Qs10Fxpy2ep757J/lPdfAm3sqVZem3wgdAfoAq4RV4RbsAzM7V/EI/fBEU5GZ5pvXqkwTBMuoFSvMCZWReRAgo31x6D4Wpu0Vd7xhuL/yFgLlavwSjgMWFlyL+j+yab7OPPnYKB44C9Zs6rd8Tqco6icxVsb4RB7whB1ZFV0wj+sKMLx6yVB9XYA5VbDt9ElcpUC9JoW5YPCJQCiC9E0wBdFyRo1FksqGRZDVNRb+PKxnKj8AXgqO5V6jDDGS8GuFpdvC7xfg6NC0oHeR0lS5BZdIotFlJD3mO4wOdkNX+z9YU9hGPTcUiqn6w0CxTykljTt8pVfeKg7VRaQ6hS5KSzADBkjZW8OfDsKZotNk4U++TQs4I9NhW2hSVUZgIJ8u0EpS4hr6dVGqL4puY529CkPySESHKMHs0mUhNn4Zf0L0nFcB8ssxex+jlt9djISdMU1Yh4wkFtDFCyzdvsCJ1acAmz5fKl9D5X2/vxtwQuuPRGdcjFoR6Y9DRaUjf1z0fjic06gWoTH9WsXJNcFqO7RxABjsEuDH6wep7dyIGMDDlH/vw6Gj39OLjiZwe0/V4ERZwpMA8dBytDmbtSdnZS4bsOoTsQEZYCmxUNMqRvj3V/ZpdHk1IquxdtBn8cV9GlHOlMYAB03sZM1ijM/FIqj5FSQBkd1EsLmw1+6kcWkil1yoQFBZGFbjcu9dCFRfTwlayBnhYpBOVQWsbSoZ4fN6iHuzNQxiDrPc9qwLZJeEp3xjG8sgQTr1xnp2sTR1qsSkxBkBUUNDnmM1yd3C27D7MXa9tK0DQWRt5eZK2py7usDe5jQ5dsTh2U47/m6jWeab6w2cqINNXU1k47Df4ma95gJcC0qKpJfyvFlhVDAZA1/wLI3R0M3J8aIS42tALVAelVLnFq4Lvp9DjDPUfcO5GBfWPi23qE4CGCFRC8EXzWwDln48HKD0pA1xNFPIGiIPjL0rhM1u6BA2kXQuK4tNYRSdPkl46vXUj4rEHoPM5TaK2TzRLGc8VK7hflMjvPGD9faT3G89MUfFXnnh0A2ZZ2qVYzzSbIn4c9T0iQ7OTMvnC/xP+h2mO9JHpr5YekIPnCh/Wi/GlS3oyPHcn7NwvfWtYr4zlzoRMIimTe1mGlDk6Y+vsN/zPcZXsIPWxddQRxD4yRxV0xqdKyWxYaMSnPQCu2A4jCOQsQuPeAIJXEFIsHIZWhnxmmDN20Xj4s3Bl/JWK2Vds0u+yeBWLGzYZmubKhKHJ0jSX1ApW3cL8jIbuRDOsPEW+QARf14fdKko7NqhJifmxEmqfgFFgsAObwpKlQs8s8vQpKnPc4knyea0at+8DIJ28OIyFr1mjWXG/64GYEHV9wkPDY9F9PD6uPOG5CYW9iX9tSvxKPrOEhrSQj5CpDAH6dNWS9xDIdv6IF7wyrDZew9cTQyyMpPShqYh6/phySPZhAz2hXSMUO5AdeVXu41jcntQZ+LNm2gkqeAd/36obopcCbMbeV0G+CrrhLgYhOsIYVrI9RF9UjZ8ktk3So4kpYGNvLX2VHY8mQFNcrjG60DODNxvq6YZmYc01irBmy+J22n48noQUO/2feKnJDet76ZsjuXMjEMW5WQ2RmNtUny6dNxlrgNYP7DA1OE30qzdYDS/tQb6bmYfFbFZbdT1mvSkB70GgKfzj4C5FiMieG1XeWhSS9psm3nwC45ZOw5dK9XJ1RekP4AQkVFcGOmgazNl3ndCjXj8zlvrttUPLvUgP7Rr2oucH8yAR06zNx/H4nuBNRPx3KZ+krqUquH5wmFBTOorWzPANFKMyDaJjHCfTwBMnkz17T/qNpYRGEI3JjNFJ0QyluGJiWxccdaCs7FveUgL/D38v9vtIDjrGoJ47EncgVhDiwfnz9Uj1P0zZvYhvn06Ez+mUntnVRKWAEZM90w+2gLx/aEGftG/IinmBTlImXRJZo9FJpZg4F3re7vnUc4x6vnTr1cQAmEdHL3imy8LywlHD+DbipTCXPgTsqHkzjX/1ep7qg7/7kjxXSXwSL7OiZ/2tgV7geFOmuz+9yxhN9W6bFhJzi4eTsb7k2VkVOId9cnmuiBSZc4wbxNWbWkQ5J+gPWnE8EpYlDANSRk+65qu2IzIHXBzxIuYUJ8+GIMLxbCFjVLsxK69QZhsZvfbLp7C5T8Ujp3sGepQAhqjX4m24PZcvuATSZqdPMvkd06wCvEh50IMSDOqZhgP9miIsVqKEHtbNzP2TFayBWrMuvAskQMFvegrTfttR3qQUBC0USczj39dGdrRnGAJWDcQ+dgJLF//7ULV+Iez7CfoVBQUS8gqs0KW7/2ZDaKQ5pqJc+i/XlyLJQctXFWjgD9BE7Uo6Kkhz710zr8n+xYd3+qhYXOMDeJYpu6NSonP9js3ST1H6+AlHLY+tor7yJwkVm9BRr/aGepWdIM4qWuUPTEljhxzeuaaUs1iCpq50wcz1YK+6r1ALvrWi+9hE2IyRBjz4VX9U27SQGsXD9ZY4GlQo077zy/gjpgNHVzBr/MywqS9gLBY4kqen3YebeYZnzQ3zZoVRj+al7HyFQrxJ6ka9EAXQc1XgKfnajeJB6lgNm6Uz8E0n8KzwUIT3pNrBWr9H4AB0U6lFREHG0fxhbJxh33zdv6nEuNB2wtt9+KcBh/dmCoMEdNPEkRs5nLJYYtvXqEsaPU37G1A3gfiVfcEGCZRTjXx+3E0M0+1ePUTEZhyThNOemus2vPAiWoRDnWGSruaiW5ZrMZEJnwLumajFCE/1MkshtW4I7rxg2tZj6NfIlY4GimSzKnPSEXxXohAIjJvGHEkaiOo2x9pM07hL8P3X+H9k42x3Vp+b7h78wfiY+8hIom2Y/NxDKW6wyQpXrmO6LKLiVr7GZnwJ+bq+sjqN32RunNiHS++lNH9o/UGu1NJHw3skvt2wqecKoaTvRaA6xjpTC07SY9+NL75OQgOsiAweBURsB1Ds1IPgInIitHhFfrkcnGuggJwZ8V923fLsqPvjFczQjzLZWJ/62QMO+XweVpH6d4kD4cKCfsmBT9Yf+R4QnyqZY5cSwac1BcXrpBp5fDiJlHlCENm2GsVDwdN8B1BdLTl/jiO32u1glCf4mZu+Ivo5ILiwMUS8nCvJci48ZAaCBsaA1bXlouly2soZZcXIZ3tj9DGEP0/jr/UuzuwFXZp8EnRRBIiEHeSk4QdSpejm6ToWzPTrp1Lth5hxq4UkUVEARmid2GH0M1rsJ77zKiEr/H9U5KJ0Pj1nUAh+sUuX+yLk1FJ1hFaoF63kv292uWmdZ7gDnx0CoXgoY88HqK2GqUyXVxPRQQ3mAYqxUqTjzMFqpOGNdDCnwRsEEg3sedYHKs3K8PjfqgQZaSEyE8fOxXDHhA8HXlV9VYyAyLUvL9Z0qo/xuuOmAE8myC397MNrQ+KlYTng1tLWkv1t78isWNidRl+yBSYHRsjlGwlcbnc6kH30GBQjRFlOh34DW+H7xp4gh61XAFgp5CFHNL7V/vbhh2Pz9Wc7E9CkdBJKYeRRfAM2FV1dK1MP/aCWWZkxuUDq4LUKa5oGJDBRnVTM9R0ap+52xm//1gMTvKTj2HOn3PFfeaNIjTGa7Sj+UOyRZyZ76E18DdLaewTKy2DYycFMkchOt3np2Dso4BMAIKg0zFPZIv1TWXGimLy1qkMRs7TiJn3/Jya6BYwXFTDJLMymeo9z1OO7He4y4KxJoL2QoKPXUx53EnqDwyKAUsVED1dWVqoCyWyMtjWS7Ro09cnVF2cvEYKn0Iz4LZqMMUTdYg+uKiic8Gq5kR5sPtCPQbSeok78N11wOPqGeUn+AM9n/5Lljustm2AdbkXWH6syUb5wABRXlVEeO7zi749TBivf6rJEDSbMq+pcEIdCLTDJdTlXklTb4hOiaiJpVhiKJFJ6wCYJ+Cqrp/1L1M+Mm+zRn66uGiILOjmHPwz2ISU/by6zxnTiraJxs0ci4hlR43ILbCtZ0CVJnOP9K2MMD2lcCwK9IzQgAAGcDxs4w2fkAD5e2LSf8pPXZQVOxp9bhCEUzWJjTlJoZHj6AqqPsB2VHBbnU+MUmAZuq+y8ge+tg8df6x1iCjsodtMYYTqQn2/8rnAEIZpfk5Utgohr66bB0bXFsILEgtxOqTMQEOCFUUMQtXw8wfybj5YRDwjsqtrrto8ngrZdTG44q2yh6/5XG3dRlP7pihum2RFnTQ9WXXi2yQKJuTt5H1+2tsQljOjBF2Rifv7U8aP6LY8+fSL/3ViKwBT9G0L7+wSYwv7I/oklSlV/gL0xQFwzO35LKa8Cykb2gRChR7+cKRbWtrm4QUU+y7+CToKeKjwqIYKNbeOOQe/seVXR1z6LIJIxvyagK4HhoT/7moMOCbcCu0BbR17Gz+8o7OSzoDdbkhDBlUpvPyMtGWJF+jmFrkcb+HDEOQClgMey/ESK6lZRU9sfW2ypIjmA0AM3gd9UNqqb45VY90YXiQEMZsLSLbwNtsKW15ummphHqa2Of7fF6ucQdaHgdc+1Y3OohuVCn6rEl7DvjVs+YxsyGJ/DmQSU9Hdw6w0ej14gDYR6TxB9qCTjENLdnCB3dw/dmAwiL2XiueHbotSV3mVG1roXqWN17JGphEsFwusPw5b7oNH6+CVN7b7ZK8qNERTAOgBTz/2tm4AfPkZUXqJZ+tJDmC2GZOZX2DIdDgsNh+ZBqki6HrsfJSfg+7+7V+mFYeXZfNSZ21mqM4AqPyoiy7LCOpObkxl7rHc/PKXWsVVvfN9Ig+Nh0JE8uSoarHb69L9/z+TtlQvapIYJYs91bjfNDQ9BD+ydcWULw8tD3KOvT7c1WBJrr1254jxcLK3zC1L98TbY02Va9Ug0AA/dJ1L+XJMMxuwYuBO/M9ooY61vArrKd1+7Z8NfFSvyD5RymDugTj6h7QR7jyTJiYCgRdgUfqHtDbQvxn7N5kxA4VrYVFhjwLbiNi3ILD83UpQSudhpIevj5qIwDo2nSmlKFaLaK0J4D/dM/9zFLUOjrVHnTxFLQsTStZdz86fsKS8NZJN/T2YKoQI2PCCZmAOlL+g/wufVqnk9y7P9L29mC3C+QGr3dWkHxyr6jyflhwbJOqpkrn0ii7EX8SF7Ko259tQ17R4ZSUXNTJk+SwzIxSGuzMra33udqUvq8NUtfVUk3G8XawdOQTDOQoh5Lc1zcj868+p3ijlUO00FeNandwEUSDI79ldESbCzxCZXN1Y+mP+ur7ajcKXtlLNGAo/2tH8WWxF9UrHFEso846IaYzG9TOkPHBdO76ECjeqrQcKZsxPfA03NQFCS7XXDzaXXmPAdZ+XCiZXstCCtXpheXnFYBFR59/aTlTFj1ZmNwjzfo3D486ODbAxlKXZqruMDCfbm+QYOumdSw+TtFAYWCP3z8rG893ziHlb2rasH/eQLFASzGEVB8JaoyViMji9fsTJWZ0Sqn5o3ORCUk7jS2z1RpQ9jFSPBjZ2tKYaMVi3nuhXdrYi8V/B8fnwdYWBer55UMbx/IQ3f3cuAEHTm9pqjKuWWKOZi9lp99CtCeP0PJnvkZmVF/QvjszPxW96DpSKC9+rWcP7uWNNdir40PeGkfkhi0AUrP389lNvVmbbaY2Fp02ktxWfaa22rOuzK7e3l+qf2HnnByCGP470ZEhr92z0kAsXs4AA572kwMJP+4Wx7WK1OyDiG3WVboINBHgAwS7V2su8sEDS1zrCmYFFEjTMmlv76ca3Ru79j0HCIP0VIZTuPu7CvYiyCUuhHrk8Y6Kc+cWqF18OMyq07jlv/8S0wEN0Vy3YpidmGP0HwTsN+ZPksOVJdPSiJepNGbkfODvJq22dWMQIRe3bVHb31GecN3d7+2rNc2cYafhEQmSYAtsHue/hoko63npnI+mK+bPXBDJgEt6a0+ECKWkZT/IzsaQFzQAoX2Hz8wclixVHKh5awqvdrD+9uMG0zqBXsNi/GNGW89MaPtlNAwhOoY8PTYCUPBEzz8LFmpDw2ze32IMHQ4LI07UBiHARkiF4TWfxzhuNY8cz6zlJkm4kvZTiYGcEJHOhAS6BOzi6n2it7vjg10mpCfOs/+Abw09oHj3dG0NC4sSoAvsCcr3KK6apVc0iD+b3oa50v2YuJRNqDmMftHSiu4FAMseZkIHbERz9WBRL0NZ93d94ohez8FFVPS/UXnsYIMUHFlFgNsuD1LXBMl4RsE1ynjp+exu7+GiZPH+86k5SDWUQRmqdNu5GkDPYUmMm9NTT0Y3GT0TGAw/Sp51QM4kUa5CbNbkuSiBzZ6ZXmaz6sjgdAszelZ7AxfupPu3jsRlRxw+ugnvLbvsZYzVUg57TNP3jsl85RSapjXP2Y0M48Qv85M55Vq9GaOBkDiDQ47kkDSVKsRF/0JjLstACKfgGeLApl5xESs3eagffXaTEeG0j7oiQIMUU+5DpzP+y8ZQqsnXINQWnN2pNZpwCIb3BdgiTWDoQe4gp6Xz1vSXYP55uVQYNHERbasuQI4xREd5QhPvr6HViWzrICdYrgWghUv/oPgu8eR8ocHprXHBrHVUQmXz5Jl8mRKEjES8wDdDlQJV97M9ziJiGANZyYCvKYMuqyQUFQokYR9SD5OeYAiXKmqNtQnKqzsdbugj7ek8K+CYGe3zNiHK9ib7j93UraWbN8AeoItcNDfK6iJN/O9mdrpf1TqvSBeBBw7E6JJF9sI3GHzmOWKr96YEH7WAYMpGTA/bjVx5Prss9yuxe2OU0g4+B7YBf9HSPK7Qy/UGzwBk+97MZE6v19Hi+FRX9TmxDxXWSl+K2IasMqNWMtcUrPZfwy8dapsBHsIKWpR5sBGrrvrRY91ArYg1xuzVE7Cng50egHVU7IwwiC8yEOiSh8aJnusSWusJW+R8j4mFIUR7nxFsp8SKv+nAtkU6e6e/kitN5Nw3SeJZKAo9wRoH7XXOv+bDbHrJb+t0q1uJoFbSgm4xuMuMw8w4JZvtaENeKWppZxeWlml20JkOAwXgEitqZWqtrBMZRwMIu3Rl7qFbOvysI17h5Sr0N0+d9MroHDhxbZhQLZ+T2P5tz1ZP5RY3cWMm0qKAr9/b5Lg/oLTzuosLv7e3XHjRmyFe/+qQlGt+B8BJ0vS/LBscyxkfKQrRWEbktKz3jTnRTKb9VNgsywB6WJtAv8LVzl5AAXjycIW2GUx+/UnO9VKVkNRjDl+6Izf6I31Yu3a76GAbu9iW1QYuUuDSnlIQea+O1ehUbxUzcNNRbU+pNahLZjQD7sdnrR66tsC2TXAcQ0qnfxE2bze0/nh3kN3zuGP98xHP8l4vHGciHTRpLbafFNGnwZYht54Y2GYZ6g9zVpz/JJAw+kkRXF2hOOGFsi5SD5YX3SL1dQ/WiziLXjJZCLw6O1WaVTXemzrAeiOLc78GxBK5DIUVPXJkbCM/jS00qLHy6VkM4CgTl8Lfs9DLdQm+oReW75Mc/Ldfj/j20aX7gCYpYKvmSYiN40MhOuSNTkuCVvyScsOa5HjIFTFZrWl3KkIvBhQjYxVD7pvifuzvS5YQB/uQmsBrlRz56kNUHqY+m2/dV+rUW4grenrwevqG94Z9PPEVF2pr6rNjOZ1yTij4fSRT8N6JoJ9DguPAcCdL0sXo896mLkgrbTrk/KexOh4GTz6ilUbhbEoqLwcXsQy9XzeG1ZMzG5nifTKHfIHDgCArAcHbKyMT55clY2u4mCsU/ADUVwBXLEKFCMEYy+ABgHWuwDA7hDPV0w2KelMe8br/Ql+Yiwli4Tz/wsbMJcvhOc5SHe/MXG0RGOXZBPtcF68Ii+nwPhSbP/y3comMfIde7fRHTWMvhFW5gk1IjnoxXSEhWA3550R+4isuY8UzWODZO14JLHdEWRvurIwmxROeYiwCvMKa/BTPwXH9SOOe+FieJyViAvjj41jP+alOPV2xHVHfFEb1EOajTTJ44M3hEUx/vrg9fwDAq6l3G4AxbgZGD3nQyg/cMsN5jC/3qBkryd9jCsyeOHBghY1Gt/yD0z9yx8s6+l0T4/WOxC1yiWvDgMIwPo9JE4dqNNTNAAGMd9nNrFpF9gs/1F7pE6eM/tp4UsWXCTsvn3gQr1rWBFCqhLNCZ8Ku5fknwUjhBxIoanmNiXYeI1K1VXYz6mkoI8bjoTZLKIDlGXu8f79MNsmpanRc+8kyfo63RgdsQlm5Xx5qt5EovC0XAhOKMGIwh6yjZVlwDroSvgO8HKzA7DCpWongZVIMpx9ldZ/PBK6lO5XYozJNAIDs0BarQh9w0j6UZ8OrRhkQLDcgMy6nt/lZFDCGAozZxk2dtzSCWj4Fb4da/ixNmiZ+HdUbL9ms943RpUq0e19I1taMrHAw4o+uv196yQhLjhOoLQY3x2wZPE290xEeE4s/ZqwhlBDSMB0KCm4OQC/tHIdVhjHYKftcFH5rJVTbv3ak66jz04jzHpdWFgolBPp0B2FAO0OywvN8rAb4wNEmUYfv4jNE2X4SRD0Qi1w0y9n7dG/CaZB+6FfSRywIMa7fsGReElkmwN1efjpN8aWsqsE8jIsAVmW9b3WY28cSRc7AkoR8I7DBVZuxImB/eSmdhflPtJL95YRNby9q8ZEhcDgrLuY2w+hS8zeupExsQGYWAXPg6t7vZPhbywBOWP6r/u0UPDSnKUqv7JGR5NQ5ZI/rI0bdV6PPDnBINz6kYTziagUDpdeFh48gVaGnCs/junS+PATkOp1GUh+U9xNaxwk6UPUrCeHeUqk3sAAwhpsGqfESCAYFnTSs3PxoDoYD7mXyb4Zou/09hjt8kHvDW/nVgy7hGfn97v3SmIQitEwAYPP+ASZPDubtmrmZrWPJ3YKps4dBdW1dC9QrFxqOrBXNBqjwc90eM+3OlmEyZr1Vnq16eO3UDpAUxZXiEHI95Qhq7ZqbEt+fq7uprSu8Hlh0ddVXcQlkd8iSbfQLxp4QHaTq/IDh+rttKu9FAlCSPboGni+jXpmXz8AIXUop6hVHDS2hl8P5+SOxNO3xDiUGBsnRVfACEWGVfVkfDNdHuMYVixGRTXL/RqDlpq+Fjm9PV+ibKdOsAAJjHsV3FmPs+AarwcKzhdnJn35d/He4PPYCtYxTDdE5jCAKEezenImOTPXNOwERzveHNFZP8ZKjqu9vbrwRbRycAS0qlO7guJpTHX/JLjYqCKH6U4LOnbfc3eaaisZhO4j29Bl5IuRxeZAuP08zo5AKhhUg3awNKjNdg3dh6O/Oq8oPquTfhDzk1lxoHBwew7xpyCNjLTBc90oqHd4DnXKLjEaul3CAU9xEv39GnBcOXLUGxquZplWqpeYRMOc7vKbGLD+YE52hZyL6DMej22HjtBC+duSl9wpGhXkTSFO8fiuLhavf556lbDUOQHpATQZBACPBLStNQL1cqtTIpgCqgRGOWT4r7Pt+xYQcTOwt2m5b5XmcDUDP7n25Ti2QKt3sSSFH9DCUwbFg3DdLqK1ffAXQUHYnPKXy8LxulbfMqY/xTDxSDZOfAERzlXSB3tOq/oKHUY5EzYkiC2MhO2reLr72iF9hXl7go4ztyO9cjfyXfitRU4uL+Qwd5xsRpdA5U9IC4TjT+m7QAG9w5I+jbAGbU2PF754mTNMAOVDoZ3e1dtGwHp+9T/vv8yBL8ffyykUJNH9JA3RGjiMN8UUEOADVML+ZgTCsJrRv3dxFqqV3SseB8qL1G7mgLK/XVVXP7QwAZIsGcd6CdOStJK75HrdnQEf+vqSHDmzayf3KHSspAP3S223Rhgq1kUlosVVyHxZ5J1n8hfIzT3HZKFMOoVVoc2wgrRF+GK1tLL+Gl93WWB0lBzG0EHjzDk2WMjJq2RznEwz/5eDBuI51UnvHO/of8DCydOEDbjY8P6gQfMITN5ErsCeDirVJMZV5AsiHpodyCyl0cswWJthU/dw/zMQEh1niZ3CnRIctAfEg1lSiMD8OLo/jSFFzwWebIxYpy3vn+kB1s3cqWN+t7MVov4aMMr7I6XYE4JZ9FGlSRz6rsAy8n48FkHpL/lIeU9gvtRYVpbUdqa6/pbeQ0bL4GhcTLqD7jbz5WMzMD9k4CHDEFWU4D6+13FY08CrVOa+9eAk8orB7nA/8jo9yiFWzB/XXk6bBml9usoCDw5V5UcnsaowIpI5E/S9ZavVunxHwFKdj7cMyTGJlCfzg/XnMuZSGGp4orHrrzR/hTmQk5ovxPfLxYfmH75XjuAByvT9jOMN3Rh8kI6p97JsGuxoShXqoO6K0t0Y5IVMrZvlrnWJ166oVrz9wk8+zwkeoPHtP3mYD0cMgR20tXkf7mVB8AhRD8hcTZ6ke9Z9Tnw/WfXS1VcQLzc1yajXMcLHnHkpVG+5UY3qPBfIW1vw8ZHDu5Rql+YH4S7N9Orl7myhenz4/9Z1oexhGiuwNkmjHubVxWiJkyz+uiRxiOMiXUkkN7zpY4+A+teb2GHaeIpT2vorUc0X6xBu4MY0hYxSxoMT7HMt/Bwnvf/8xYkmbstHESQ6QLQlgZnhPq03tTQjTZKzSAqYX+cptJe5ScZmkq6kLe1lZFBQZ73QiafRRk0ss08DSOiGIqoP+iOFqwzvoolwS3qDEhoOiMeIBlnBilHiZz/7lPh222ECGTcBLxxkcjhkgRFNvNW0LYXKEsb5qsfK1NMlnnWfvPWK4vIvczxiyMdVQIzaSuOz0i2cNNLZpUSYAGzlGSsQI9vWTkL8FKwZGx0JRtAwBCULKTCVczRm0Lw6o72Ru4sCaKzDjQXMkllg8/TXdXM0VsXl2URFasxeFx4yK4ievV1JBhWqxEwrlD7hvTlUvkwsjgZ32222IypcyHorVLpV3uV4ikhGph6fN7UoGey8sQ17Pjc62LavOo66PjHsP6NvNMQwbMmlT7Ok0OAkmCnvBXJBLInmVuw3n0DyIgyplCvJyLg=]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>byobu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 学习笔记—基础01]]></title>
    <url>%2F2018%2F01%2F27%2FDjangoLearning1%2F</url>
    <content type="text"><![CDATA[参考 Django 1.8.2中文文档 Django 2.0 官方文档 Django 中文教学 自强学院 所需指令用指令创建项目django-admin startproject project 一般不用，直接用pycharm创建就行 运行应用python manage.py runserver 8080 运行后，才能根据所生成的网址，访问服务器，后面填写服务器的端口 也可以不写端口，如果没写端口，默认使用8000端口 创建一个应用python manage.py startapp djangoAppName(这里填写所需创建应用的名字)或django-admin startapp djangoAppName可以直接在apps目录下创建 有点类似于模块的意思，分模块开发项目，一个模块对应了view, model等内容，需要创建新的模块的时候，需要使用这个指令。 生成迁移（makemigrations）创建迁移文件 python manage.py makemigrations 创建之后，在所对应的migrations文件夹下面会多出一个.py文件 如果使用的是Django2.0 并且数据库model中使用了ForeignKey，需要在后面添加 on_delete 关键字 在使用这个命令的时候，需要在settings.py文件中的INSTALLED_APPS注册应用信息 执行迁移根据迁移文件，形成sql语句，创建对应的表 python manage.py migrate 创建超级管理员python manage.py createsuperuser 接下来按照提示填写用户名、邮箱、密码 后台URL: 在网址后面添加admin 显示所有的指令python manage.py 会显示所有的指令，并且在后面输入help name就可以查看对应指令的具体信息 Model创建 在对应的模版项目下的models.py文件下创建数据库模型文件 创建模型的时候不用创建主键id，系统会自动生成这个主键的列 Models.py1234567891011121314151617181920212223242526272829303132333435from django.db import modelsclass ModelName1(models.Model): title = models.CharField(max_length=20) date = models.DateTimeField() def __repr__(self): return 'title name is &#123;&#125;, crate at &#123;&#125;'.format(self.title, self.date) def __str__(self): return self.titleclass ModelName2(models.Model): hname = models.CharField(max_length=10) hgender = models.BooleanField() content = models.CharField(max_length=1000) modelName1ForeignKey = models.ForeignKey(ModelName1, on_delete=models.CASCADE) #外键 def __str__(self): return self.name def gender(self): if self.hgender: return '男' else: return '女' gender.short_description = '性别' def name(self): return self.hname name.short_description = '名字' Django2.0 ForeignKey 变化在创建外键的时候遇到报错： TypeError: __init__() missing 1 required positional argument: &#39;on_delete&#39; 查询一番后发现Django2.0版本创建外键时需要在后面加上on_delete 12345class Car(models.Model): manufacturer = models.ForeignKey( 'Manufacturer', on_delete=models.CASCADE, ) 站点管理界面本地化修改settings.py 12LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai' 修改语言和时区 向admin中注册应用在 booktest/admin.py 文件，注册模型 123from django.contrib import adminfrom models import ModelNameadmin.site.register(ModelName) 导入model 类 在admin中注册该模型类 admin.site.register(ModelName) 自定义管理页面 Django提供了admin.ModelAdmin类 通过定义ModelAdmin的子类，来定义模型在Admin界面的显示方式 1234567891011class ModelNameAdmin(admin.ModelAdmin): list_display = ['id', 'title', 'date'] list_filter = ['title'] search_fields = ['title'] list_per_page = 10 fieldsets = [ ('base',&#123;'fields':['title']&#125;), ('super',&#123;'fields':['date']&#125;) ]admin.site.register(BookInfo, BookInfoAdmin) 列表页属性list_display 显示字段，可以点击列头进行排序 1list_display = ['pk', 'title', 'date'] 列表里面填写的是字段的列表名字，表示要在后台页面中显示什么列表字段，先后顺序决定显示顺序 list_filter 过滤字段，过滤框会出现在右侧 1list_filter = ['title'] search_fields 搜索字段，搜索框会出现在上侧 1search_fields = ['title'] 支持模糊查询，根据列表中的字段进行查询 list_per_page 分页，分页框会出现在下侧 1list_per_page = 10 添加、修改页属性fields 属性的先后顺序 1fields = ['date', 'title'] fieldsets 属性分组 1234fieldsets = [ ('basic',&#123;'fields': ['title']&#125;), ('more', &#123;'fields': ['date']&#125;),] 关联对象 对于模型类，有两种注册方式 方式一：与传统模型类相同 方式二：关联注册 按照BookInfor的注册方式完成HeroInfo的注册 接下来实现关联注册 12345678910111213141516171819202122232425262728from django.contrib import adminfrom .models import *# StackedInline TabularInlineclass ModelName2Line(admin.TabularInline): model = HeroInfo extra = 1class ModelName1Admin(admin.ModelAdmin): list_display = ['id', 'title', 'date'] list_filter = ['title'] search_fields = ['title'] list_per_page = 10 fieldsets = [ ('base', &#123;'fields': ['title']&#125;), ('super', &#123;'fields': ['date']&#125;) ] inlines = [ModelName2Line]class ModelName2Admin(admin.ModelAdmin): list_display = ['id', 'name', 'gender', 'content', 'modelName1ForeignKey'] list_filter = ['hgender']admin.site.register(ModelName1, ModelName1Admin)admin.site.register(ModelName2, ModelName2Admin) 可以将内嵌的方式改为表格 1class ModelName2Line(admin.TabularInline) 布尔值的显示 发布性别的显示不是一个直观的结果，可以使用方法进行封装 123456def gender(self): if self.hgender: return '男' else: return '女'gender.short_description = '性别' 在admin注册中使用gender代替hgender 12class ModelName2Admin(admin.ModelAdmin): list_display = ['id', 'name', 'gender', 'content'] 视图 在django中，视图对WEB请求进行回应 视图接收reqeust对象作为第一个参数，包含了请求的信息 视图就是一个Python函数，被定义在views.py中 123456from django.http import HttpResponsedef index(request): return HttpResponse("index")def detail(request,id): return HttpResponse("detail %s" % id) 定义完成视图后，需要配置urls.py，否则无法处理请求 urls.py12345678from django.contrib import adminfrom django.urls import pathfrom DjangoLearn1 import viewsurlpatterns = [ path('admin/', admin.site.urls), path('',views.index)] 此时，就可以访问了，不过考虑到如果这样填写，模块一多，URL的量一大的话，就会出现多个路由，不方便配置，所以推荐如下 在对应模块里面创建一个 urls.py 的文件，将路由信息写到里面 1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 之后，在向主urls.py文件中include进去 1234567from django.urls import include, pathfrom django.contrib import adminurlpatterns = [ path('', include('DjangoLearn1.urls')), path('admin/', admin.site.urls),] 模板 模板是html页面，可以根据视图中传递的数据填充值 在模板中访问视图传递的数据 12&#123;&#123; 输出值，可以是变量，也可以是对象.属性 &#125;&#125;&#123;% 执行代码段 %&#125; 定义HTML模板123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;列表&lt;/h1&gt;&lt;ul&gt;&#123;%for ModeleName1 in ModeleName1List%&#125;&lt;li&gt; &lt;a href="&#123;&#123;ModeleName1.id&#125;&#125;"&gt; &#123;&#123;ModeleName1.title&#125;&#125; &lt;/a&gt;&lt;/li&gt;&#123;%endfor%&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 在模板中访问对象成员时，都以属性的方式访问，即方法也不能加括号 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;详细&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123;ModeleName1.title&#125;&#125;&lt;/h1&gt;&lt;ul&gt; &#123;%for Modele in ModeleName1.ModelName2_set.all%&#125; &lt;li&gt;&#123;&#123;Modele.name&#125;&#125;---&#123;&#123;Modele.content&#125;&#125;&lt;/li&gt; &#123;%endfor%&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 使用模板 编辑views.py文件，在方法中调用模板 Django提供了函数Render()简化视图调用模板、构造上下文 1234567891011from django.shortcuts import renderfrom models import ModeleName1def index(reqeust): ModeleName1List = ModeleName1.objects.all() return render(reqeust, 'booktest/index.html', &#123;'ModeleName1List': ModeleName1List&#125;)def detail(reqeust, id): ModeleName1 = ModeleName1.objects.get(pk=id) return render(reqeust, 'booktest/detail.html', &#123;'ModeleName1': ModeleName1&#125;) 总结 视图 Views： 接受请求，逻辑处理，调用数据，输出响应 配置ulr在自己的应用中匹配url 模型Model：负责与数据库交互 面向对象：模型对象，列表 定义模型类：指出属性及类型，以确定表的结构，迁移 后台管理：创建管理员，启动服务器，admin，注册admin.py 模版：定义显示的样子 加载：读取文件内容到内存 渲染：填内容]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + nexT 学习笔记]]></title>
    <url>%2F2017%2F12%2F30%2FHexoLearn-re%2F</url>
    <content type="text"><![CDATA[前言 本文内容主要是个人在学习hexo和next中所遇到的一些“坑”和解决方法,而详细的流程网上有很多，在文章的结尾我会贴出我在学习中查找到的比较好的文章。 注意本文不是详细操作步骤，如果需要详细步骤，请直接翻到文章结尾。 官方文档 Hexo nexT Hexo 和 nexT 的安装 在安装 Hexo 之前，需要确保电脑环境要有 Node.js 和 Git 环境, 当然，为了更好的安装 Hexo 还需要 npm. 下面是我所使用的版本： 安装之后，最常使用的指令如下： 生成静态页面 1hexo g 在本地运行 1hexo s 部署到GitHub pages（coding） 1hexo d 清除生成的静态文件 1hexo clean 打开 GitHub Pages在第一次创建完仓库之后，打开settings选项，向下翻到GitHub Pages选项会发现不能打开，会有一个提示信息： GitHub Pages is currently disabled. You must first add content to your repository before you can publish a GitHub Pages site 是因为该GitHub Pages没有内容，此时只要点击下面的Choose a theme按钮选择一个主题就可以打开和访问了。 SSH 配置 先查看本机用户home目录下是否存在.ssh目录 1cd ~/.ssh 如果有就不用再创建了，如果想重新创建，可以创建一个不同名字的，也可以将原来的删除，再创建。 使用下面指令删除已存在的SSH： 12ssh-add -Drm -r ~/.ssh 再创建新的SSH密钥(keys) 1$ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 这将按照你提供的邮箱地址，创建一对密钥 将生成的id_rsa.pub文件里面的内容拷贝到GitHub 项目中添加公钥，这里推荐在对应 xxx.github.io 项目中加。（settings-&gt;deploy keys） 最后再用下面指令测试是否连接成功 1ssh -T git@github.com 可参考github提示Permission denied (publickey)，如何才能解决？ 同步到GitHub 配置站点文件下的_config.xml文件下的deploy信息。 安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 关于 https 的问题，如果需要使用自己的域名的话，GitHub pages 是不能打开 Enforce HTTPS 的。所以在配置deploy信息的时候就推荐使用 Clone with SSH 的链接。 绑定域名 在source文件夹下面创建CNAME文件（没有后缀），里面填上自己的域名。 之后在自己的域名商将自己的域名用CNAME方式指向自己GitHub pages的域名。 个人使用的是腾讯云 最后需要注意，需要在站点文件的_config.xml文件配置中的skip_render添加: 12skip_render: - CNAME 表示跳过该文件的渲染。 nexT 主题配置一些我觉得比较实用的效果，参考hexo的next主题个性化配置教程. 添加 README.md在站点文件的source目录下添加一个README.md文件，之后修改站点文件下的_config.xml，将skip_render添加README.md，跳过该文件的渲染。 123skip_render: - CNAME - README.md Schemes个人比较喜欢Gemini样式，相比Pisces样式，该样式不会每篇文章相连过于紧密，会以分块的形式显示出来，比较好看，特别在手机端上效果更显著。具体可以亲自去设置去看看效果。 live2d就是网站右下角的萌物”小人，具体可以参考hexo-helper-live2d。下面简要介绍我的做法： 在站点文件打开终端输入 1npm install --save hexo-helper-live2d 在站点文件下的_config.xml最后配置： 12live2d: model: z16 具体的配置可以看文档，可以修改挺多内容的。模型外观参考截图预览. 动态背景在主题文件的_config.xml中搜索Canvas-nest可以发现有4个动态背景，可以逐个尝试，也可以同时设置为true，个人只选择了Canvas-nest。 footer可以将网站最下的不想要显示的内容设置为false，在主题文件的_config.xml中搜索footer，我的设置如下： 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false busuanzi访问人数在主题文件的_config.xml中搜索busuanzi_count，修改配置，可以在网站底部和文章中显示访问的人数，我的配置如下： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数 site_uv_footer: | # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 访问总量 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读次数 page_pv_footer: 显示统计字数在主题文件的_config.xml中搜索post_wordcount，修改配置，可以在网站底部和文章中显示所统计的字数，我的配置如下： 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 增加本地搜索功能在主题文件的_config.xml中搜索local_search，设置为true。 参考： Hexo博客无法搜索的终极解决方法 在文章底部增加版权信息在主题文件的_config.xml中搜索post_copyright，设置为true。 给文章加密参考： hexo-blog-encrypt 安装： npm install hexo-blog-encrypt 首先在 _config.yml 中启用该插件 123# Securityencrypt: enable: true 在你的文章的头部添加上对应的字段，如 password, abstract, message 123456789---title: hello worlddate: 2016-03-30 21:18:02tags: - fdsafsdafpassword: Mikeabstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read.--- 写文章一般使用 1hexo new xxx xxx表示文件的名字，同时也会自动设置为文章标题（后面可改）以之间创建.md文件，添加文章头信息 1234567title: // 文章标题date: // 创建时间updated: //跟新文章的时间tags: // 文章的标签，如果有多个，[tags1, tags2, ...]categories: // 文章分类keywords: // 文章关键词，如果有多个，[key1, key2, ...]description: //文章描述 其中需要注意： 如果想要有updated，需要在主题文件下的_config.xml文件中配置post_meta，将updated_at设置为true。 12345post_meta: item_text: true created_at: true updated_at: true categories: true keywords和description的作用是为了搜索引擎寻找关键字。 其中description关键字，在主页上显示的时候就会显示这里面的内容，而不是显示前150个字符。还有另一种方法推荐，就是不写description，而是在文章中插入&lt;!-- more --&gt;注释，这样主页就会显示该注释前的内容。 可添加内容下面的内容是推广和维护网站相关。 网站分析个人使用的是腾讯移动分析，而且nexT也可以直接支持，在主题文件的_config.xml中搜索Tencent MTA ID，将自己在网站上注册的 ID 填写上去就可以统计了。 seo推广这里推荐参考Hexo+nexT主题搭建个人博客中seo推广部分。 参考百度搜索资源平台 推荐阅读 Hexo+nexT主题搭建个人博客 hexo初探—让写作飞起来 史上最详细的Hexo博客搭建图文教程 Hexo + GitHub (Coding) Pages 搭建博客 基于 Hexo 和 GitHub Pages 搭建博客 Hexo搭建独立博客，托管到Github和Coding上教程 让更多人看到你的博客 在github上搭建个人网站 如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题？ Hexo+Next主题集成Algolia搜索]]></content>
      <categories>
        <category>博客技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天算是把我的博客网站建立起来了]]></title>
    <url>%2F2017%2F12%2F27%2Fhellomyblog%2F</url>
    <content type="text"><![CDATA[花了三天时间，终于搞定了，这也表示我的文章之旅要开始了。enjoy it !]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
</search>
