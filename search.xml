<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python Cookbook 笔记]]></title>
    <url>%2F2018%2F05%2F29%2Fpython-cookbook-learning%2F</url>
    <content type="text"><![CDATA[《Python CookBook 3》 这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。 数据结构和算法星号（*）表达式 解压可迭代对象赋值给多个变量 可以使用 * （星号表达式）来匹配不确定数量的数据。 1234567def drop_first_last(grades): first, *middle, last = grades print(middle) # 输出： [3, 4, 5] return middleif __name__ == '__main__': drop_first_last([12,3,4,5,6]) 带有星号的变量永远都是列表类型，包括长度是0的空列表，所以用到该变量的代码就不需要做多余的类型检查去确认它是否是列表类型。 扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 而不是通过一些比较复杂的手段去获取这些关联的元素值。 星号表达式能做很多事情，包括对字符串的处理，对可变长数组，元组的处理。 xrange在Python 3中，range()与xrange()合并为range( )。 如果直接使用 range ，会直接占用内存的空间，例如如果要加载一个很大的文件，就有可能会照成内存的爆满。这时候可以使用 xrange 在代替，这个返回的是一个生成器，而不是数列，每次只会返回其中的一个值。 yield Python yield 使用浅析 123456789101112131415from inspect import isgeneratorfunctiondef fab(max): n, a, b = 0, 0, 1 print("++++++++++") while n &lt; max: yield b print("12312312---"+str(b)) a, b = b, a+b n = n+1if __name__ == '__main__': print(isgeneratorfunction(fab)) for n in fab(5): print(n) 输出： 123456789101112True++++++++++112312312---1112312312---1212312312---2312312312---3512312312---5 一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 其中，可以使用 isgeneratorfunction 来判断函数是否是一个特殊的 generator 函数。 其中 yield 的例子来源于文件读取。如果直接对文件对象调用 read() 方法，会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取： 123456789def read_file(fpath): BLOCK_SIZE = 1024 with open(fpath, 'rb') as f: while True: block = f.read(BLOCK_SIZE) if block: yield block else: return collections.deque 保留最后 N 个元素 使用 deque(maxlen=N) 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。 1234567891011from collections import dequelines = deque(maxlen=3) lines.append("1") lines.append("2") lines.append("3") lines.append("4") lines.append("5") print(lines)# 输出： deque(['3', '4', '5'], maxlen=3) 还可以在队列的两端插入和弹出元素，（左边插入：q.appendleft；左边弹出：q.popleft） 在队列两端插入或删除元素时间复杂度都是 O(1) ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 O(N) 。 heapq 查找最大或最小的 N 个元素 123456789import heapqnums = [1,2,34,5,43,523,423,423,4,234,24,1,3,1,3,53,5654,6,4356,12]print(heapq.nlargest(3, nums))print(heapq.nsmallest(2, nums))# 输出：# [5654, 4356, 523]# [1, 1] 还可以接受一个关键字参数，来进行更高级的对比：12345678910111213141516portfolio = [ &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;, &#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;, &#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;, &#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125;, &#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;, &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;]cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])print(cheap)print(expensive)输出：[&#123;'name': 'YHOO', 'shares': 45, 'price': 16.35&#125;, &#123;'name': 'FB', 'shares': 200, 'price': 21.09&#125;, &#123;'name': 'HPQ', 'shares': 35, 'price': 31.75&#125;][&#123;'name': 'AAPL', 'shares': 50, 'price': 543.22&#125;, &#123;'name': 'ACME', 'shares': 75, 'price': 115.65&#125;, &#123;'name': 'IBM', 'shares': 100, 'price': 91.1&#125;] 堆数据结构最重要的特征是 heap[0] 永远是最小的元素。并且剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。 123456&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = list(nums)&gt;&gt;&gt; heapq.heapify(heap)&gt;&gt;&gt; heap[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] 如果只是获取一个最大值（最小值），使用 max()（min()）函数会快一些。 collections.defaultdict 字典中的键映射多个值 defaultdict 的一个特征是它会自动初始化每个 key 刚开始对应的值，所以你只需要关注添加元素操作了。 12345678910from collections import defaultdictd = defaultdict(list)d['a'].append(1)d['a'].append(2)d['b'].append(4)print(d)# 输出： defaultdict(&lt;class 'list'&gt;, &#123;'a': [1, 2], 'b': [4]&#125;) 12345678910from collections import defaultdictd = defaultdict(set)d['a'].add(1)d['a'].add(2)d['b'].add(4)print(d)# 输出： defaultdict(&lt;class 'set'&gt;, &#123;'a': &#123;1, 2&#125;, 'b': &#123;4&#125;&#125;) defaultdict 会自动为将要访问的键（就算目前字典中并不存在这样的键）创建映射实体。 collections.OrderedDict 字典排序 创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。 1234567891011121314from collections import OrderedDictimport jsond = OrderedDict()d['foo'] = 1d['bar'] = 2d['spam'] = 3d['grok'] = 4d['foo'] = 12# Outputs "foo 1", "bar 2", "spam 3", "grok 4"for key in d: print(key, d[key])j = json.dumps(d)print(j) 输出： 12345foo 12bar 2spam 3grok 4&#123;&quot;foo&quot;: 12, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4&#125; OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。 需要注意的是，一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。 zip 字典的运算 对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来。 123456789101112131415prices = &#123; 'ACME': 45.23, 'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75&#125;min_price = min(zip(prices.values(), prices.keys()))print(min_price)max_price = max(zip(prices.values(), prices.keys()))print(max_price)prices_sort = sorted(zip(prices.values(), prices.keys()))print(prices_sort) 输出： 123(10.75, &apos;FB&apos;)(612.78, &apos;AAPL&apos;)[(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;), (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;), (612.78, &apos;AAPL&apos;)] 在使用zip()的时候，在使用zip()给一个变量赋值的时候，就不能再次使用该变量做其他操作，例如：a = zip(prices.values(), prices.keys())，之后调用max(a)，后面如果再次调用min(a)的话就会报错。# ValueError: max() arg is an empty sequence keys and values 查找两字典的相同点 一个字典就是一个键集合与值集合的映射关系。 字典的 keys() 方法返回一个展现键集合的键视图对象。 键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。 所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个 set。 123456789101112131415161718192021a = &#123; 'x': 1, 'y': 2, 'z': 3&#125;b = &#123; 'w': 10, 'x': 11, 'y': 2&#125;print(a.keys() &amp; b.keys())# &#123;'x', 'y'&#125; 在a字典和b字典中相同的keyprint(a.keys() - b.keys())# &#123;'z'&#125; 在a字典中有的在b字典中没有的keyprint(a.items() &amp; b.items())# &#123;('y', 2)&#125; 在a字典和在b字典中相同的健值对c = &#123;key: a[key] for key in a.keys() - &#123;'z'&#125;&#125;print(c)# &#123;'x': 1, 'y': 2&#125; 字典的 items() 方法返回一个包含 (键，值) 对的元素视图对象。 这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。 尽管字典的 values() 方法也是类似，但是它并不支持这里介绍的集合操作。 collections.Counter 序列中出现次数最多的元素 Counter 对象可以接受任意的由可哈希（hashable）元素构成的序列对象。 1234567891011121314from collections import Counterwords = [ 'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes', 'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the', 'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into', 'my', 'eyes', "you're", 'under']word_counts = Counter(words)# 计算列表中出现频率最多的三个单词top_three = word_counts.most_common(3)print(top_three)# [('eyes', 8), ('the', 5), ('look', 4)] 同样的，也可增加新的列表来跟新新的列表中的元素的个数。 123morewords = ['why','are','you','not','looking','in','my','eyes']word_counts.update(morewords)print(word_counts.most_common(3)) 并且，Counter这个类也可以和数学运算符操作相结合。 123456789a = Counter(words)b = Counter(morewords)c = a + bprint(c)# Counter(&#123;'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2, 'around': 2, "don't": 1, "you're": 1, 'under': 1, 'why': 1, 'are': 1, 'you': 1, 'looking': 1, 'in': 1&#125;)c = a - bprint(c)# Counter(&#123;'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2, "don't": 1, "you're": 1, 'under': 1&#125;) operator.itemgetter 通过某个关键字排序一个字典列表 可以利用itemgetter的模块对列表中以某个字段来排序。 123456789101112131415161718192021from operator import itemgetterrows = [ &#123;'fname': 'Brian', 'lname': 'Jones', 'uid': 1003&#125;, &#123;'fname': 'David', 'lname': 'Beazley', 'uid': 1002&#125;, &#123;'fname': 'John', 'lname': 'Cleese', 'uid': 1001&#125;, &#123;'fname': 'Big', 'lname': 'Jones', 'uid': 1004&#125;]rows_by_fname = sorted(rows, key=itemgetter('fname'))rows_by_uid = sorted(rows, key=itemgetter('uid'))print(rows_by_fname)# [&#123;'fname': 'Big', 'lname': 'Jones', 'uid': 1004&#125;,# &#123;'fname': 'Brian', 'lname': 'Jones', 'uid': 1003&#125;,# &#123;'fname': 'David', 'lname': 'Beazley', 'uid': 1002&#125;,# &#123;'fname': 'John', 'lname': 'Cleese', 'uid': 1001&#125;]print(rows_by_uid)# [&#123;'fname': 'John', 'lname': 'Cleese', 'uid': 1001&#125;,# &#123;'fname': 'David', 'lname': 'Beazley', 'uid': 1002&#125;,# &#123;'fname': 'Brian', 'lname': 'Jones', 'uid': 1003&#125;,# &#123;'fname': 'Big', 'lname': 'Jones', 'uid': 1004&#125;] 同样，也能存在多个key 123456rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))print(rows_by_lfname)# [&#123;'fname': 'David', 'lname': 'Beazley', 'uid': 1002&#125;,# &#123;'fname': 'John', 'lname': 'Cleese', 'uid': 1001&#125;,# &#123;'fname': 'Big', 'lname': 'Jones', 'uid': 1004&#125;,# &#123;'fname': 'Brian', 'lname': 'Jones', 'uid': 1003&#125;] rows 被传递给接受一个关键字参数的 sorted() 内置函数。 这个参数是 callable 类型，并且从 rows 中接受一个单一元素，然后返回被用来排序的值。 itemgetter() 函数就是负责创建这个 callable 对象的。 operator.itemgetter() 函数有一个被 rows 中的记录用来查找值的索引参数。可以是一个字典键名称， 一个整形值或者任何能够传入一个对象的 __getitem__() 方法的值。 如果你传入多个索引参数给 itemgetter() ，它生成的 callable 对象会返回一个包含所有元素值的元组， 并且 sorted() 函数会根据这个元组中元素顺序去排序。 但你想要同时在几个字段上面进行排序（比如通过姓和名来排序，也就是例子中的那样）的时候这种方法是很有用的。 该模块也同样适用于 min() 和 max() 等函数。min(rows, key=itemgetter(&#39;uid&#39;)) 或者 max(rows, key=itemgetter(&#39;uid&#39;)) operator.attrgetter 排序不支持原生比较的对象 1234567891011121314151617181920from operator import attrgetterclass User: def __init__(self, user_id): self.user_id = user_id def __repr__(self): return 'User(&#123;&#125;)'.format(self.user_id)users = [User(34), User(23), User(12)]print(users)# [User(34), User(23), User(12)]print(sorted(users, key=lambda u: u.user_id))# [User(12), User(23), User(34)]s = sorted(users, key=attrgetter('user_id'))print(s)# [User(12), User(23), User(34)] 可以直接使用lambda表达式的计算来代替attrgetter，但是如果更加在意速度的话，attrgetter() 函数通常会运行的快点，并且还能同时允许多个字段进行比较。 这个跟 operator.itemgetter() 函数作用于字典类型很类似。也同样支持min和max的操作。 itertools.groupby 通过某个字段将记录分组 groupby() 函数扫描整个序列并且查找连续相同值（或者根据指定 key 函数返回值相同）的元素序列。 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。 一个非常重要的准备步骤是要根据指定的字段将数据排序。 因为 groupby() 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果。 12345678910111213141516171819from operator import itemgetterfrom itertools import groupbyrows = [ &#123;'address': '5412 N CLARK', 'date': '07/01/2012'&#125;, &#123;'address': '5148 N CLARK', 'date': '07/04/2012'&#125;, &#123;'address': '5800 E 58TH', 'date': '07/02/2012'&#125;, &#123;'address': '2122 N CLARK', 'date': '07/03/2012'&#125;, &#123;'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'&#125;, &#123;'address': '1060 W ADDISON', 'date': '07/02/2012'&#125;, &#123;'address': '4801 N BROADWAY', 'date': '07/01/2012'&#125;, &#123;'address': '1039 W GRANVILLE', 'date': '07/04/2012'&#125;,]rows.sort(key=itemgetter('date'))a = groupby(rows, key=itemgetter('date'))for date, items in a: print(date) for item in items: print(' ', item) 如果需要按照分组来访问，可以使用defaultdict()来构建多值字典。 filter() 过滤序列元素 一般来说，如果我们需要对一个列表遍历，取出其中的某些特定的元素，我们可以使用列表推导。 1234mylist = [1, 4, -5, 10, -7, 2, 3, -1]m = [i for i in mylist if i &gt; 0]print(m)# [1, 4, 10, 2, 3] 使用列表推导的一个潜在缺陷就是如果输入非常大的时候会产生一个非常大的结果集，占用大量内存。 如果对内存比较敏感，可以使用生成器表达式迭代产生过滤的元素。 123456pos = (n for n in mylist if n &gt; 0)print(pos)# &lt;generator object &lt;genexpr&gt; at 0x101fa69e8&gt;for i in pos: print(i, end=' ')# 1 4 10 2 3 如果过滤规则比较复杂，不能简单的在列表推导或者生成器表达式中表达出来。 比如，假设过滤的时候需要处理一些异常或者其他复杂情况。这时候可以将过滤代码放到一个函数中， 然后使用内建的 filter() 函数。 1234567891011121314values = ['1', '2', '-3', '-', '4', 'N/A', '5']def is_int(val): try: x = int(val) return True except ValueError: return Falseivals = list(filter(is_int, values))print(ivals)# ['1', '2', '-3', '4', '5'] filter() 函数创建了一个迭代器，因此如果你想得到一个列表的话，就得像示例那样使用 list() 去转换。 另外一个值得关注的过滤工具就是 itertools.compress() ， 它以一个 iterable 对象和一个相对应的 Boolean 选择器序列作为输入参数。 然后输出 iterable 对象中对应选择器为 True 的元素。 当你需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的。 12345678from itertools import compressmore5 = [n &gt; 5 for n in counts]print(more5)# [False, False, True, False, False, True, True, False]more6 = list(compress(addresses, more5))print(more6)# ['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY'] 这里的关键点在于先创建一个 Boolean 序列，指示哪些元素符合条件。 然后 compress() 函数根据这个序列去选择输出对应位置为 True 的元素。 和 filter() 函数类似， compress() 也是返回的一个迭代器。因此，如果你需要得到一个列表， 那么你需要使用 list() 来将结果转换为列表类型。 字典推导12345678910111213prices = &#123; 'ACME': 45.23, 'AAPL': 612.78, 'IBM': 205.55, 'HPQ': 37.20, 'FB': 10.75&#125;p1 = &#123;key: value for key, value in prices.items() if value &gt; 200&#125;print(p1)tech_names = &#123;'AAPL', 'IBM', 'HPQ', 'MSFT'&#125;p2 = &#123;key: value for key, value in prices.items() if key in tech_names&#125;print(p2) 大多数情况下字典推导能做到的，通过创建一个元组序列然后把它传给 dict() 函数也能实现。 12p3 = dict((key, value) for key, value in prices.items() if value &gt; 200)print(p3) 字典推导方式表意更清晰，并且实际上也会运行的更快些 collections.namedtuple() 映射名称到序列元素 collections.namedtuple() 函数通过使用一个普通的元组对象来解决这个问题。 这个函数实际上是一个返回 Python 中标准元组类型子类的一个工厂方法。 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。 12345678910from collections import namedtupleSubscriber = namedtuple('Subscriber', ['addr', 'joined'])sub = Subscriber('jonesy@example.com', '2012-10-19')print(sub)# Subscriber(addr='jonesy@example.com', joined='2012-10-19')print(sub.addr)# jonesy@example.comprint(sub.joined)# 2012-10-19 尽管 namedtuple 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。 12345678s = len(sub)print(s)# 2addr, joined = subprint(addr)# jonesy@example.comprint(joined)# 2012-10-19 因此，如果你从数据库调用中返回了一个很大的元组列表，通过下标去操作其中的元素， 当你在表中添加了新的列的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。 123456789from collections import namedtupleStock = namedtuple('Stock', ['name', 'shares', 'price'])def compute_cost(records): total = 0.0 for rec in records: s = Stock(*rec) total += s.shares * s.price return total 命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。 如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。 但是需要注意的是，不像字典那样，一个命名元组是不可更改的。 如果你真的需要改变属性的值，那么可以使用命名元组实例的 _replace() 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代。 s = s._replace(shares=75) _replace() 方法还有一个很有用的特性就是当你的命名元组拥有可选或者缺失字段时候， 它是一个非常方便的填充数据的方法。 你可以先创建一个包含缺省值的原型元组，然后使用 _replace() 方法创建新的值被更新过的实例。 12345678910from collections import namedtupleStock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])# Create a prototype instancestock_prototype = Stock('', 0, 0.0, None, None)# Function to convert a dictionary to a Stockdef dict_to_stock(s): return stock_prototype._replace(**s) 最后要说的是，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择。 这时候你应该考虑定义一个包含 __slots__ 方法的类 collections.ChainMap 合并多个字典或映射 一个 ChainMap 接受多个字典并将它们在逻辑上变为一个字典。 然后，这些字典并不是真的合并在一起了， ChainMap 类只是在内部创建了一个容纳这些字典的列表 并重新定义了一些常见的字典操作来遍历这个列表。 1234567891011a = &#123;'x': 1, 'z': 3 &#125;b = &#123;'y': 2, 'z': 4 &#125;from collections import ChainMapc = ChainMap(a, b)print(c)# ChainMap(&#123;'x': 1, 'z': 3&#125;, &#123;'y': 2, 'z': 4&#125;)print(c['x']) # 1print(c['z']) # 3print(c['y']) # 2 如果出现重复键，那么第一次出现的映射值会被返回。对于字典的更新或删除操作总是影响的是列表中第一个字典。 123456789101112131415value = ChainMap()value['x'] = 0value = value.new_child()value['x'] = 1value = value.new_child()value['y'] = 2value = value.new_child()value['z'] = 3print(value)# ChainMap(&#123;'z': 3&#125;, &#123;'y': 2&#125;, &#123;'x': 1&#125;, &#123;'x': 0&#125;)value = value.parents# 删除最后加入的字典value = value.parentsprint(value)# ChainMap(&#123;'x': 1&#125;, &#123;'x': 0&#125;) 在原字典中的修改会直接反应到 ChainMap 中。 字符串和文本字符串开头或结尾匹配检查字符串开头或结尾的一个简单方法是使用 str.startswith() 或者是 str.endswith() 方法。 123456789101112131415import osfile_list = os.listdir('.')print(file_list)# ['startandendwith.py', '__init__.py']end_with = [name for name in file_list if name.endswith('.py')]print(end_with)# ['startandendwith.py', '__init__.py']start_with = [name for name in file_list if name.startswith('s')]print(start_with)# ['startandendwith.py']has_end = any(name.endswith('.py') for name in file_list)print(has_end)# Trueprint(any([False, True, False]))# True startswith() 和 endswith() 方法提供了一个非常方便的方式去做字符串开头和结尾的检查。 类似的操作也可以使用切片来实现，但是代码看起来没有那么优雅。 123choices = ['http:', 'ftp:']t = tuple(choices)print(t) tuple() 可以将 list 或者 set 类型的选择项转换为元组类型。 当和其他操作比如普通数据聚合相结合的时候 startswith() 和 endswith() 方法是很不错的。 比如，下面这个语句检查某个文件夹中是否存在指定的文件类型： if any(name.endswith((‘.c’, ‘.h’)) for name in listdir(dirname)): fnmatch() 和 fnmatchcase() 用Shell通配符匹配字符串 123456789101112131415from fnmatch import fnmatch, fnmatchcaseis_fnmatch_1 = fnmatch('foo.txt', '*.txt')print(is_fnmatch_1)# Trueis_fnmatch_2 = fnmatch('foo.txt', '?oo.txt')print(is_fnmatch_2)# Trueis_fnmatch_3 = fnmatch('Dat45.csv', 'Dat[0-9]*')print(is_fnmatch_3)# Truenames = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']name_list = [name for name in names if fnmatch(name, 'Dat*.csv')]print(name_list)# ['Dat1.csv', 'Dat2.csv'] fnmatch() 函数使用底层操作系统的大小写敏感规则(不同的系统是不一样的)来匹配模式。 123456&gt;&gt;&gt; # On OS X (Mac)&gt;&gt;&gt; fnmatch('foo.txt', '*.TXT')False&gt;&gt;&gt; # On Windows&gt;&gt;&gt; fnmatch('foo.txt', '*.TXT')True 如果对这个区别很在意，可以使用 fnmatchcase() 来代替。它完全使用所规定的模式大小写匹配。 fnmatch() 函数匹配能力介于简单的字符串方法和强大的正则表达式之间。 如果在数据处理操作中只需要简单的通配符就能完成的时候，这通常是一个比较合理的方案。 re.sub() 字符串搜索和替换 sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号。 123456import retext = 'Today is 11/27/2012. PyCon starts 3/13/2013.'s = re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)print(s)# Today is 2012-11-27. PyCon starts 2013-3-13. 如果打算用相同的模式做多次替换，考虑先编译它来提升性能。 1234datepat = re.compile(r'(\d+)/(\d+)/(\d+)')s2 = datepat.sub(r'\3-\1-\2', text)print(s2)# Today is 2012-11-27. PyCon starts 2013-3-13. 对于更加复杂的替换，可以传递一个替换回调函数来代替。 123456789from calendar import month_abbrdef chane_date(m): mon_name = month_abbr[int(m.group(1))] return '&#123;&#125; &#123;&#125; &#123;&#125;'.format(m.group(2), mon_name, m.group(3))s3 = datepat.sub(chane_date, text)print(s3)# Today is 27 Nov 2012. PyCon starts 13 Mar 2013. 一个替换回调函数的参数是一个 match 对象，也就是 match() 或者 find() 返回的对象。 使用 group() 方法来提取特定的匹配部分。回调函数最后返回替换字符串。 如果除了替换后的结果外，还想知道有多少替换发生了，可以使用 re.subn() 来代替。函数返回一个元组来表示替换后的值和一共替换的数量。 123s4, n = datepat.subn(chane_date, text)print(s4, n)# Today is 27 Nov 2012. PyCon starts 13 Mar 2013. 2 re.IGNORECASE 字符串忽略大小写的搜索替换 以忽略大小写的方式搜索与替换文本字符串 1234text = 'UPPER PYTHON, lower python, Mixed Python'a = re.findall('python', text, flags=re.IGNORECASE)print(a)# ['PYTHON', 'python', 'Python'] sub() 函数除了接受替换字符串外，还能接受一个回调函数。 re.DOTALLre.compile() 函数接受一个标志参数叫 re.DOTALL ，在这里非常有用。 它可以让正则表达式中的点(.)匹配包括换行符在内的任意字符。 12345678import retext2 = '''/* this is a multiline comment */ '''comment = re.compile(r'/\*(.*?)\*/', re.DOTALL)a = comment.findall(text2)print(a)# [' this is a\n multiline comment '] 这样的对于那些需要换行的字符串就能很好的匹配， 同时，适用于那些文件的读取。也可以用re.compile(r&#39;/\*((?:.|\n)*?)\*/&#39;)来代替，也能达到跨行匹配字符串的效果。 unicodedata 将Unicode文本标准化 123456789101112s1 = 'Spicy Jalape\u00f1o'print(s1)# Spicy Jalapeños2 = 'Spicy Jalapen\u0303o'print(s2)# Spicy Jalapeñoprint(s1==s2)# Falseprint(len(s1))# 14print(len(s2))# 15 这里的文本”Spicy Jalapeño”使用了两种形式来表示。 第一种使用整体字符”ñ”(U+00F1)，第二种使用拉丁字母”n”后面跟一个”~”的组合字符(U+0303)。 在需要比较字符串的程序中使用字符的多种表示会产生问题。 为了修正这个问题，可以使用unicodedata模块先将文本标准化： 123456789101112131415import unicodedatat1 = unicodedata.normalize('NFC', s1)t2 = unicodedata.normalize('NFC', s2)print(t1 == t2)# Trueprint(ascii(t1))# 'Spicy Jalape\xf1o't1 = unicodedata.normalize('NFD', s1)t2 = unicodedata.normalize('NFD', s2)print(t1 == t2)# Trueprint(ascii(t1))# 'Spicy Jalapen\u0303o' normalize() 第一个参数指定字符串标准化的方式。 NFC表示字符应该是整体组成(比如可能的话就使用单一编码)，而NFD表示字符应该分解为多个组合字符表示。 Python同样支持扩展的标准化形式NFKC和NFKD，它们在处理某些字符的时候增加了额外的兼容特性。 标准化对于任何需要以一致的方式处理Unicode文本的程序都是非常重要的。 当处理来自用户输入的字符串而你很难去控制编码的时候尤其如此。 strip主要用来去除多余的空格，当然，也可也以去除多余的其他字符。strip() 方法能用于删除开始或结尾的字符。 lstrip() 和 rstrip() 分别从左和从右执行删除操作。 1234567s = ' hello world \n'print(s.strip())# hello worldprint(s.lstrip())# hello world \nprint(s.rstrip())# hello world 添加参数就可以对应去除参数中的字符。 12345t = '-----hello====='print(t.lstrip('-'))# hello=====print(t.strip('-='))# hello 这些 strip() 方法在读取和清理数据以备后续处理的时候是经常会被用到的。 比如，你可以用它们来去掉空格，引号和完成其他任务。 但是需要注意的是去除操作不会对字符串的中间的文本产生任何影响。如果想处理中间的空格，那么你需要求助其他技术。比如使用 replace() 方法或者是用正则表达式替换。 ljust、rjust、center 字符串对齐 通过参数的设定，可以指定字符串的长度，如果字符串长度不足，就不会添加字符进行填充。否则就会根据参数添加对应的字符进行添加填充，使得整个的字符串的长度达到参数所规定的长度。 123456789101112s = 'Hellow World'text = s.ljust(20)print(text)# Hellow Worldtext = s.rjust(20)print(text)# Hellow Worldtext = s.rjust(20, '-')print(text)# --------Hellow World 并且，format函数也可以对字符串进行填充。 12345678print(format(s, '+&gt;20s'))print(format(s, '-&lt;20s'))print(format(s, '=&gt;20s'))print(format(s, '*^20s'))# ++++++++Hellow World# Hellow World--------# ========Hellow World# ****Hellow World**** 也可以同时格式化多个值： 12s = '&#123;:+&gt;10s&#125; &#123;:-&gt;10s&#125;'.format('Hello', 'World')print(s) 注意：需要写：号，后面的s只是表明变量是字符串类型的，当然，format也可以格式化其他的类型。 所以，在需要对字符串进行格式化的时候，尽量使用format函数来格式化字符串，而不应该采用原来的代码%s类似的形式格式化。同时，这一种形式也可以替代ljust、rjust、center。 format_map 和 vars123456name = 'lim'age = 12s = '&#123;name&#125; is &#123;age&#125; years old.'print(s.format_map(vars()))# lim is 12 years old. 这样可以直接在变量域中寻找字符串中碎对应的变量，与字符串相结合。 vars() 还有一个有意思的特性就是它也适用于对象实例。 12345678910class People: def __init__(self, name, age): self.name = name self.age = ageme = People('jaelyn', 17)output = s.format_map(vars(me))print(output)# jaelyn is 17 years old. format 和 format_map() 的一个缺陷就是它们并不能很好的处理变量缺失的情况， 一种避免这种错误的方法是另外定义一个含有 __missing__() 方法的字典对象 123456789101112131415161718class People(): def __init__(self, name, age): self.name = name # self.age = age def __missing__(self, key): return '&#123;' + key + '&#125;'class safesub(dict): def __missing__(self, key): return '&#123;' + key + '&#125;'me = People('jaelyn', 17)output = s.format_map(safesub(vars(me)))print(output)# jaelyn is &#123;age&#125; years old. textwrap使用 textwrap 模块来格式化字符串的输出。 123456789101112131415161718192021222324252627282930313233343536import textwraps = "Look into my eyes, look into my eyes, the eyes, the eyes, \the eyes, not around the eyes, don't look around the eyes, \look into my eyes, you're under."print(textwrap.fill(s, 70), end='\n\n')"""Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,not around the eyes, don't look around the eyes, look into my eyes,you're under."""print(textwrap.fill(s, 30), end='\n\n')"""Look into my eyes, look intomy eyes, the eyes, the eyes,the eyes, not around the eyes,don't look around the eyes,look into my eyes, you'reunder."""print(textwrap.fill(s, 40, initial_indent='++++++'), end='\n\n')"""++++++Look into my eyes, look into myeyes, the eyes, the eyes, the eyes, notaround the eyes, don't look around theeyes, look into my eyes, you're under."""print(textwrap.fill(s, 40, subsequent_indent='======'), end='\n\n')"""Look into my eyes, look into my eyes,======the eyes, the eyes, the eyes, not======around the eyes, don't look around======the eyes, look into my eyes,======you're under.""" textwrap 模块对于字符串打印是非常有用的，特别是当你希望输出自动匹配终端大小的时候。 你可以使用 os.get_terminal_size() 方法来获取终端的大小尺寸。 12345import osterminal_colum = os.get_terminal_size().columnsprint(terminal_colum)# 261 注意，上面的那条语句需要在控制台执行，不然会报 OSError: [WinError 6] 句柄无效。 的错误。 html.escape 在字符串中处理html和xml 想将HTML或者XML实体如 &amp;entity; 或 &amp;#code; 替换为对应的文本。 再者，需要转换文本中特定的字符(比如&lt;, &gt;, 或 &amp;)。 12345678910import htmls = 'Elements are written as "&lt;tag&gt;text&lt;/tag&gt;".'print(s)# Elements are written as "&lt;tag&gt;text&lt;/tag&gt;".print(html.escape(s))# Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;.print(html.escape(s, quote=False))# Elements are written as "&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;". 如果正在处理的是ASCII文本，并且想将非ASCII文本对应的编码实体嵌入进去， 可以给某些I/O函数传递参数 errors=&#39;xmlcharrefreplace&#39; 来达到这个目。 123s = 'Spicy Jalapeño'print(s.encode('ascii', errors='xmlcharrefreplace'))# b'Spicy Jalape&amp;#241;o' 为了替换文本中的编码实体，需要使用另外一种方法。 如果正在处理HTML或者XML文本，试着先使用一个合适的HTML或者XML解析器。 通常情况下，这些工具会自动替换这些编码值，你无需担心。 有时候，如果你接收到了一些含有编码值的原始文本，需要手动去做替换， 通常你只需要使用HTML或者XML解析器的一些相关工具函数/方法即可。 字符串令牌解析 字符串令牌解析 第一步就是利用命名捕获组的正则表达式来定义所有可能的令牌。?P&lt;TOKENNAME&gt; 用于给一个模式命名，供后面使用。 为了令牌化，使用模式对象很少被人知道的 scanner() 方法。 这个方法会创建一个 scanner 对象， 在这个对象上不断的调用 match() 方法会一步步的扫描目标文本，每步一个匹配。 123456789101112131415161718192021222324252627282930313233343536373839404142import refrom collections import namedtupleNAME = r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'NUM = r'(?P&lt;NUM&gt;\d+)'PLUS = r'(?P&lt;PLUS&gt;\+)'TIMES = r'(?P&lt;TIMES&gt;\*)'EQ = r'(?P&lt;EQ&gt;=)'WS = r'(?P&lt;WS&gt;\s+)'master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))print(master_pat)# re.compile('(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)|(?P&lt;NUM&gt;\\d+)|(?P&lt;PLUS&gt;\\+)|(?P&lt;TIMES&gt;\\*)|(?P&lt;EQ&gt;=)|(?P&lt;WS&gt;\\s+)')scanner = master_pat.scanner('foo = 23 + 42 * 10')result = scanner.match()print(result)# &lt;_sre.SRE_Match object; span=(0, 3), match='foo'&gt;def generate_tokens(pat, text): Token = namedtuple('Token', ['type', 'value']) scanner = pat.scanner(text) for m in iter(scanner.match, None): yield Token(m.lastgroup, m.group())for tok in generate_tokens(master_pat, 'foo = 23 + 42 * 10'): print(tok)"""Token(type='NAME', value='foo')Token(type='WS', value=' ')Token(type='EQ', value='=')Token(type='WS', value=' ')Token(type='NUM', value='23')Token(type='WS', value=' ')Token(type='PLUS', value='+')Token(type='WS', value=' ')Token(type='NUM', value='42')Token(type='WS', value=' ')Token(type='TIMES', value='*')Token(type='WS', value=' ')Token(type='NUM', value='10')""" 通常来讲令牌化是很多高级文本解析与处理的第一步。 为了使用上面的扫描方法，你需要记住这里一些重要的几点。 第一点就是你必须确认你使用正则表达式指定了所有输入中可能出现的文本序列。 如果有任何不可匹配的文本出现了，扫描就会直接停止。这也是为什么上面例子中必须指定空白字符令牌的原因。 令牌的顺序也是有影响的。 re 模块会按照指定好的顺序去做匹配。 因此，如果一个模式恰好是另一个更长模式的子字符串，那么你需要确定长模式写在前面。 namedtuple 这个函数是用来实例化一个对象用的，这样对于一些比较简单的对象，没有太多的内容的话，就可以用这个函数去实例化出来。namedtuple 是一个函数，它用来创建一个自定义的 tuple 对象，并且规定了 tuple 元素的个数，并可以用属性而不是索引来引用 tuple 的某个元素。 实现一个简单的递归下降分析器 实现一个简单的递归下降分析器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#!/usr/bin/env python# -*- encoding: utf-8 -*-"""Topic: 下降解析器Desc :"""import reimport collections# Token specificationNUM = r'(?P&lt;NUM&gt;\d+)'PLUS = r'(?P&lt;PLUS&gt;\+)'MINUS = r'(?P&lt;MINUS&gt;-)'TIMES = r'(?P&lt;TIMES&gt;\*)'DIVIDE = r'(?P&lt;DIVIDE&gt;/)'LPAREN = r'(?P&lt;LPAREN&gt;\()'RPAREN = r'(?P&lt;RPAREN&gt;\))'WS = r'(?P&lt;WS&gt;\s+)'master_pat = re.compile('|'.join([NUM, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN, WS]))# TokenizerToken = collections.namedtuple('Token', ['type', 'value'])def generate_tokens(text): scanner = master_pat.scanner(text) for m in iter(scanner.match, None): tok = Token(m.lastgroup, m.group()) if tok.type != 'WS': yield tok# Parserclass ExpressionEvaluator: ''' Implementation of a recursive descent parser. Each method implements a single grammar rule. Use the ._accept() method to test and accept the current lookahead token. Use the ._expect() method to exactly match and discard the next token on on the input (or raise a SyntaxError if it doesn't match). ''' def parse(self, text): self.tokens = generate_tokens(text) self.tok = None # Last symbol consumed self.nexttok = None # Next symbol tokenized self._advance() # Load first lookahead token return self.expr() def _advance(self): 'Advance one token ahead' self.tok, self.nexttok = self.nexttok, next(self.tokens, None) def _accept(self, toktype): 'Test and consume the next token if it matches toktype' if self.nexttok and self.nexttok.type == toktype: self._advance() return True else: return False def _expect(self, toktype): 'Consume next token if it matches toktype or raise SyntaxError' if not self._accept(toktype): raise SyntaxError('Expected ' + toktype) # Grammar rules follow def expr(self): "expression ::= term &#123; ('+'|'-') term &#125;*" exprval = self.term() while self._accept('PLUS') or self._accept('MINUS'): op = self.tok.type right = self.term() if op == 'PLUS': exprval += right elif op == 'MINUS': exprval -= right return exprval def term(self): "term ::= factor &#123; ('*'|'/') factor &#125;*" termval = self.factor() while self._accept('TIMES') or self._accept('DIVIDE'): op = self.tok.type right = self.factor() if op == 'TIMES': termval *= right elif op == 'DIVIDE': termval /= right return termval def factor(self): "factor ::= NUM | ( expr )" if self._accept('NUM'): return int(self.tok.value) elif self._accept('LPAREN'): exprval = self.expr() self._expect('RPAREN') return exprval else: raise SyntaxError('Expected NUMBER or LPAREN')def descent_parser(): e = ExpressionEvaluator() print(e.parse('2')) print(e.parse('2 + 3')) print(e.parse('2 + 3 * 4')) print(e.parse('2 + (3 + 4) * 5')) # print(e.parse('2 + (3 + * 4)')) # Traceback (most recent call last): # File "&lt;stdin&gt;", line 1, in &lt;module&gt; # File "exprparse.py", line 40, in parse # return self.expr() # File "exprparse.py", line 67, in expr # right = self.term() # File "exprparse.py", line 77, in term # termval = self.factor() # File "exprparse.py", line 93, in factor # exprval = self.expr() # File "exprparse.py", line 67, in expr # right = self.term() # File "exprparse.py", line 77, in term # termval = self.factor() # File "exprparse.py", line 97, in factor # raise SyntaxError("Expected NUMBER or LPAREN") # SyntaxError: Expected NUMBER or LPARENif __name__ == '__main__': descent_parser() 待研究学习，字符串相关 数字日期和时间round 数字的四舍五入 对浮点数执行指定精度的舍入运算。对于简单的舍入运算，使用内置的 round(value, ndigits) 函数即可。 123456print(round(1.23, 1))# 1.2print(round(1.27, 1))# 1.3print(round(1.25361,3))# 1.254 当一个值刚好在两个边界的中间的时候， round 函数返回离它最近的偶数。 也就是说，对1.5或者2.5的舍入运算都会得到2。 传给 round() 函数的 ndigits 参数可以是负数，这种情况下， 舍入运算会作用在十位、百位、千位等上面。 1234567a = 1627731print(round(a, -1))# 1627730print(round(a, -2))# 1627700print(round(a, -3))# 1628000 不要将舍入和格式化输出搞混淆了。 如果你的目的只是简单的输出一定宽度的数，你不需要使用 round() 函数。 而仅仅只需要在格式化的时候指定精度即可。 123x = 1.23456print(format(x, '0.2f'))# 1.23 decimal 执行精确的浮点数运算 对浮点数执行精确的计算操作，并且不希望有任何小误差的出现。 浮点数的一个普遍问题是它们并不能精确的表示十进制数。 并且，即使是最简单的数学运算也会产生小的误差。这些错误是由底层CPU和IEEE 754标准通过自己的浮点单位去执行算术时的特征。 由于Python的浮点数据类型使用底层表示存储数据，因此你没办法去避免这样的误差。 12345678from decimal import Decimala = Decimal('4.2')b = Decimal('2.1')print(a + b)# 6.3print((a + b) == Decimal('6.3'))# True 初看起来，上面的代码好像有点奇怪，比如我们用字符串来表示数字。 然而， Decimal 对象会像普通浮点数一样的工作(支持所有的常用数学运算)。 如果你打印它们或者在字符串格式化函数中使用它们，看起来跟普通数字没什么两样。 Python新手会倾向于使用 decimal 模块来处理浮点数的精确运算。 然而，先理解你的应用程序目的是非常重要的。 如果你是在做科学计算或工程领域的计算、电脑绘图，或者是科学领域的大多数运算， 那么使用普通的浮点类型是比较普遍的做法。 其中一个原因是，在真实世界中很少会要求精确到普通浮点数能提供的17位精度。 因此，计算过程中的那么一点点的误差是被允许的。 第二点就是，原生的浮点数计算要快的多-有时候你在执行大量运算的时候速度也是非常重要的。 总的来说， decimal 模块主要用在涉及到金融的领域。 在这类程序中，哪怕是一点小小的误差在计算过程中蔓延都是不允许的。 因此， decimal 模块为解决这类问题提供了方法。 当Python和数据库打交道的时候也通常会遇到 Decimal 对象，并且，通常也是在处理金融数据的时候。 fractions 分数运算 用来执行包含分数的数学运算。 123456from fractions import Fractiona = Fraction(5, 4)b = Fraction(7, 16)print(a + b)# 27/16 也可以用 numerator 显示分子，用denominator显示分母。或者也可以使用float函数显示分数的浮点类型。 12345678910c = a * bprint(c)# 35/64print(c.numerator)# 35print(c.denominator)# 64print(float(c))# 0.546875 这个函数同样也有很多用法，例如，求出一个分数，该分数的分母不超过所设定的数，并且该分数的值最接近所求的浮点数。 12print(c.limit_denominator(10))# 5/9 或者给出一个小数，求原来的分数，当然，求出来的值是最为接近的值，不代表完全一致。 1234x = 3.75y = Fraction(*x.as_integer_ratio())print(y)# 15/4 在大多数程序中一般不会出现分数的计算问题，但是有时候还是需要用到的。 比如，在一个允许接受分数形式的测试单位并以分数形式执行运算的程序中， 直接使用分数可以减少手动转换为小数或浮点数的工作。 NumPy 大型数组运算 123456x = [1, 2, 3, 4]y = [5, 6, 7, 8]print(x * 2)# [1, 2, 3, 4, 1, 2, 3, 4]print(x + y)# [1, 2, 3, 4, 5, 6, 7, 8] 由此我们可以看出，python 原生的对与数列的处理就是普通的对于数列上的操作，由此看来，像 * 、 + 等操作，是以整个数列为最小单位的操作。 123456789101112import numpy as npax = np.array([1, 2, 3, 4])ay = np.array([5, 6, 7, 8])print(ax * 2)# [2 4 6 8]print(ax + 10)# [11 12 13 14]print(ax + ay)# [ 6 8 10 12]print(ax * ay)# [ 5 12 21 32] 与原生的不同，numpy 的数列操作则是对应里面的每一个元素的操作。 NumPy 中的标量运算(比如 ax * 2 或 ax + 10 )会作用在每一个元素上。 另外，当两个操作数都是数组的时候执行元素对等位置计算，并最终生成一个新的数组。 NumPy 还为数组操作提供了大量的通用函数，这些函数可以作为 math 模块中类似函数的替代。 使用这些通用函数要比循环数组并使用 math 模块中的函数执行计算要快的多。 因此，只要有可能的话尽量选择 NumPy 的数组方案。 底层实现中， NumPy 数组使用了C或者Fortran语言的机制分配内存。 也就是说，它们是一个非常大的连续的并由同类型数据组成的内存区域。 所以，你可以构造一个比普通Python列表大的多的数组。 NumPy 是Python领域中很多科学与工程库的基础，同时也是被广泛使用的最大最复杂的模块。 即便如此，在刚开始的时候通过一些简单的例子和玩具程序也能帮我们完成一些有趣的事情。 通常我们导入 NumPy 模块的时候会使用语句 import numpy as np 。 这样的话你就不用再你的程序里面一遍遍的敲入 numpy ，只需要输入 np 就行了，节省了不少时间。 矩阵与线性代数运算 NumPy 库有一个矩阵对象可以用来解决这个问题。 1234567891011121314m = np.matrix([[1, -2, 3], [0, 4, 5], [7, 8, -9]])print(m)"""[[ 1 -2 3] [ 0 4 5] [ 7 8 -9]]"""print(m.T)"""# 输出矩阵的转置[[ 1 0 7] [-2 4 8] [ 3 5 -9]]""" 可以在 numpy.linalg 子包中找到更多的操作函数。 这个函数有很多强大的功能，如果需要用到一些关于矩阵和线性代数相关的知识和运算的时候，可以参考这个函数，能轻松解决很多问题。 random 随机选择 主要用于生成随机数的函数。 random 模块有大量的函数用来产生随机数和随机选择元素。 1234567891011121314151617181920212223242526272829303132333435import randomvalues = [1, 2, 3, 4, 5, 6]# 在列表中随机生成一个数字a = random.choice(values)print(a)# 1# 在列表中随机生成多个数字组成的新列表b = random.sample(values, 2)print(b)# [1, 2]# 随机打乱列表的位置，没有返回值，会直接在原来的数组上修改，属于原地操作random.shuffle(values)print(values)# [6, 5, 1, 2, 3, 4]print(values[0])# 6# 在1到10之间随机生成一个数字c = random.randint(1, 10)print(c)# 9# 在0到1之间随机生成浮点数d = random.random()print(d)# 0.19051868016253204# 获取N位随机位(二进制)的整数e = random.getrandbits(20)print(e)# 293829 random 模块使用 Mersenne Twister 算法来计算生成随机数。 除了上述介绍的功能，random模块还包含基于均匀分布、高斯分布和其他分布的随机数生成函数。 比如， random.uniform() 计算均匀分布随机数， random.gauss() 计算正态分布随机数。 在 random 模块中的函数不应该用在和密码学相关的程序中。 如果你确实需要类似的功能，可以使用ssl模块中相应的函数。 比如， ssl.RAND_bytes() 可以用来生成一个安全的随机字节序列。 datetime &amp; timedelta 基本的日期与时间转换 执行不同时间单位的转换和计算，请使用 datetime 模块。 如果你想表示指定的日期和时间，先创建一个 datetime 实例然后使用标准的数学运算来操作它们。 12345678910111213141516171819202122232425262728293031323334353637from datetime import timedeltafrom datetime import datetimea = timedelta(days=2, hours=6)b = timedelta(hours=4.5)c = a + bprint(c)# 2 days, 10:30:00print(c.days)# 2print(c.seconds)# 37800print(c.microseconds)# 0print(c.total_seconds())# 210600.0a = datetime(2012, 9, 23)print(a + timedelta(days=10))# 2012-10-03 00:00:00b = datetime(2012, 12, 21)d = b - aprint(d.days)# 89now = datetime.today()print(now)# 2018-05-28 18:44:35.190897print(now + timedelta(minutes=10))# 2018-05-28 18:54:35.190897a = datetime(2012, 3, 1)b = datetime(2012, 2, 28)print(a - b)# 2 days, 0:00:00print((a-b).days)# 2 在计算的时候，需要注意的是 datetime 会自动处理闰年。 对大多数基本的日期和时间处理问题， datetime 模块已经足够了。 如果你需要执行更加复杂的日期操作，比如处理时区，模糊时间范围，节假日计算等等， 可以考虑使用 dateutil 模块。 如果要执行大量的日期计算的话，最好安装第三方包 python-dateutil 来代替。 1234567891011from datetime import datetimefrom dateutil.relativedelta import relativedeltafrom dateutil.rrule import *d = datetime.now()print(d)# 2018-05-28 23:39:37.526316print(d + relativedelta(weekday=FR))# 2018-06-01 23:39:37.526316print(d + relativedelta(weekday=FR(-1)))# 2018-05-25 23:39:37.526316 计算当前月份的日期范围 计算对应的月份的天数，可以用到calendar.monthrange()函数，这个函数会根据所传入的年份和月数量，返回一个元组，包括对应月份的的星期和天数。 这样的话就可以使用循环等操作，获得当月份的所有日期。 12345678910111213141516171819202122from datetime import datetime, date, timedeltaimport calendardef get_month_range(start_date=None): if start_date is None: start_date = date.today().replace(month=2, day=1) # Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for year, month. temp, days_in_month = calendar.monthrange(start_date.year, start_date.month) print(temp) # 3 print(days_in_month) # 28 end_date = start_date + timedelta(days=days_in_month) return (start_date, end_date)a_day = timedelta(days=1)first_day, last_day = get_month_range()while first_day &lt; last_day: print(first_day) first_day += a_day 同样的，也可以采用生成器的方式： 1234567def date_range(start, stop, step): while start &lt; stop: yield start start += stepfor d in date_range(datetime(2012, 9, 1), datetime(2012, 10, 1), timedelta(hours=6)): print(d) 字符串转换为日期 123456text = '2012-09-20'y = datetime.strptime(text, '%Y-%m-%d')z = datetime.now()diff = z- yprint(diff)# 2077 days, 11:13:12.631424 datetime.strptime() 方法支持很多的格式化代码， 比如 %Y 代表4位数年份， %m 代表两位数月份。 还有一点值得注意的是这些格式化占位符也可以反过来使用，将日期输出为指定的格式字符串形式。 1234z = datetime.now()nice_z = datetime.strftime(z, '%Y年%m月%d日')print(nice_z)# 2018年05月29日 还有一点需要注意的是， strptime() 的性能要比你想象中的差很多， 因为它是使用纯Python实现，并且必须处理所有的系统本地设置。 如果你要在代码中需要解析大量的日期并且已经知道了日期字符串的确切格式，可以自己实现一套解析方案来获取更好的性能。 datetime.strptime(text, &#39;%Y-%m-%d&#39;) 将字符串转为日期格式。 datetime.strftime(z, &#39;%Y年%m月%d日&#39;) 将日期格式按照自己所设定的格式转为字符串。（这个函数运行的会很慢，如果需要大量的对字符串的操作，并且有很多格式相似，可以自己用字符串拆分等方式，拆字符串拼接，这样的方式可以比这个函数快7倍） 结合时区的日期操作 pytz 模块一个主要用途是将 datetime 库创建的简单日期对象本地化。 123456789101112131415from datetime import datetimefrom pytz import timezoned = datetime(2018, 5, 28, 11, 22, 41)print(d)d = datetime.now()central = timezone(&apos;Asia/Shanghai&apos;)loc_d = central.localize(d)print(loc_d)# 2018-05-29 11:28:56.614715+08:00bang_d = loc_d.astimezone(timezone(&apos;US/Central&apos;))print(bang_d)# 2018-05-28 22:28:56.614715-05:00 首先需要先本地化时间（localize方法），之后再调用 astimezone 方法用于切换时区时间。 在使用的时候需要注意，在本地化时间上操作的时候，要考虑到夏令时的相关问题，不然会出现时间差 1 小时的情况。 在使用的时候，如果不记得时区的表达方式，可以使用 country_timezones 来获得时区。 123456789import pytzp = pytz.country_timezones['IN']print(p)# ['Asia/Kolkata']p = pytz.country_timezones['CN']print(p)# ['Asia/Shanghai', 'Asia/Urumqi'] 迭代器和生成器next()遍历迭代下一个元素，在文件中表示一行。在执行的时候，如果捕获到最后一行，或者捕获到自定义的结束字符的时候，就会返回StopIteration异常，结束读取。 1234567891011items = [1, 2, 3]it = iter(items)print(next(it))# 1print(next(it))# 2print(next(it))# 3print(next(it))# StopIteration iter() 代理迭代 如果在自己定义的类中需要有自己的定义的迭代，可以定义一个 __iter__() 方法，将迭代操作代理到容器内部的对象上去。 123456789101112131415161718192021222324class Node: def __init__(self, value): self._value = value self._children = [] def __repr__(self): # &#123;!r&#125; 其中 “!r” 对应 repr()； “!s” 对应 str(); “!a” 对应 ascii()。 return 'Node(&#123;!r&#125;)'.format(self._value) def add_children(self, node): self._children.append(node) def __iter__(self): return iter(self._children)if __name__ == '__main__': root = Node(0) child1 = Node(1) child2 = Node(2) root.add_children(child1) root.add_children(child2) for ch in root: print(ch) 这里的 iter() 函数的使用简化了代码， iter(s) 只是简单的通过调用 s.__iter__() 方法来返回对应的迭代器对象， 就跟 len(s) 会调用 s.__len__() 原理是一样的。 实现深度优先的遍历的树形结构 可以在类中迭代方法的方式 1234567891011121314151617181920212223242526272829303132class Node: def __init__(self, value): self._value = value self._children = [] def __repr__(self): return 'Node(&#123;!r&#125;)'.format(self._value) def add_child(self, node): self._children.append(node) def __iter__(self): return iter(self._children) def depth_first(self): yield self for c in self: yield from c.depth_first()if __name__ == '__main__': root = Node(0) child1 = Node(1) child2 = Node(2) root.add_child(child1) root.add_child(child2) child1.add_child(Node(3)) child1.add_child(Node(4)) child2.add_child(Node(5)) for ch in root.depth_first(): print(ch) 在 depth_first 方法中，首先迭代自己，之后在 __iter__ 的迭代中，开始迭代自己的下级，最后在循环中，yield from c.depth_first()放回自己的下级。 在这段代码中，depth_first() 方法简单直观。 它首先返回自己本身并迭代每一个子节点并 通过调用子节点的 depth_first() 方法(使用 yield from 语句)返回对应元素。 reversed() 反向迭代 1234a = [1, 2, 3, 4]for i in reversed(a): print(i, end=' ') # 4 3 2 1 反向迭代仅仅当对象的大小可预先确定或者对象实现了 __reversed__() 的特殊方法时才能生效。 如果两者都不符合，那必须先将对象转换为一个列表才行。 可以通过在自定义类上实现 __reversed__() 方法来实现反向迭代。 12345678910111213141516171819202122class Countdown: def __init__(self, start): self.start = start # Forward iterator def __iter__(self): n = self.start while n &gt; 0: yield n n -= 1 # Reverse iterator def __reversed__(self): n = 1 while n &lt;= self.start: yield n n += 1for rr in reversed(Countdown(30)): print(rr)for rr in Countdown(30): print(rr) 定义一个反向迭代器可以使得代码非常的高效， 因为它不再需要将数据填充到一个列表中然后再去反向迭代这个列表。 带有外部状态的生成器函数 带有外部状态的生成器函数 12345678910111213141516171819202122from collections import dequeclass linehistory: def __init__(self, lines, histlen=3): self.lines = lines self.history = deque(maxlen=histlen) def __iter__(self): for lineno, line in enumerate(self.lines, 1): self.history.append((lineno, line)) yield line def clear(self): self.history.clear()with open('somefile.txt') as f: lines = linehistory(f) for line in lines: if 'python' in line: for lineno, hline in lines.history: print('&#123;&#125;:&#123;&#125;'.format(lineno, hline), end='') 为了使用这个类，你可以将它当做是一个普通的生成器函数。 然而，由于可以创建一个实例对象，于是你可以访问内部属性值， 比如 history 属性或者是 clear() 方法。 一个需要注意的小地方是，如果你在迭代操作时不使用for循环语句，那么你得先调用 iter() 函数。 itertools.islice() 迭代器切片 123456789101112import itertoolsdef count(n, end=10): while n &lt; end: yield n n += 1 yield endc = count(1, end=20)for x in itertools.islice(c, 2, 100): print(x) itertools.islice表示对迭代器或者生成器进行切片，不过不能使用标准的切片方法，标准的切片方法是基于原来的数组是固定长度的情况下才能使用的。这个切片是以函数的形式，接收开始的值和结束的值，位置（长度），之后将切片之后的迭代器返回。 迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。 函数 islice() 返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。 然后才开始一个个的返回元素，并直到切片结束索引位置。 这里要着重强调的一点是 islice() 会消耗掉传入的迭代器中的数据。 必须考虑到迭代器是不可逆的这个事实。 所以如果你需要之后再次访问这个迭代器的话，那你就得先将它里面的数据放入一个列表中。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>Python CookBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervisor 指令学习]]></title>
    <url>%2F2018%2F05%2F15%2Fsupervisor-learn%2F</url>
    <content type="text"><![CDATA[参考资料 * Python 进程管理工具 Supervisor 使用教程 Supervisor 使用简介 supervisor 安装、配置、常用命令 Supervisor重新加载配置启动新的进程 简介Supervisor 是一个进程管理工具，可以简单的进行进程的控制（启动，重启，停止等），可以设置网址，直接在浏览器上可视化的操作进程。 一般情况下，当我们需要以守护进程的方式启动某些进程的时候，例如后台任务（备份数据，同步数据，日志处理，消息推送等）和Web服务进程，经常被用来管理和启动一组Tornado进程实现负载均衡。 有两个重要的组成部分：supervisord和supervisorctl。 安装sudo pip install supervisor 创建配置文件这个命令可以将supervisor的默认配置输出到一个文件中，到时候直接在那上面修改会方便很多， echo_supervisord_conf &gt; /etc/supervisord.conf 箭头后面指向路径，如果出现没有权限的问题，可以使用这条命令 sudo su - root -c &quot;echo_supervisord_conf &gt; /etc/supervisord.conf&quot; 配置文件说明在默认的配置文件中，会将 supervisord.pid 以及 supervisor.sock 是放在 /tmp 目录下，但是 /tmp 目录是存放临时文件，里面的文件是会被 Linux 系统删除的，一旦这些文件丢失，就无法再通过 supervisorctl 来执行 restart 和 stop 命令了，将只会得到 unix:///tmp/supervisor.sock 不存在的错误 。（引用） 12345678910111213141516171819202122232425262728293031323334...unix_http_server];file=/tmp/supervisor.sock ; (the path to the socket file);修改为 /home/supervisor 目录，避免被系统删除file=/home/supervisor/supervisor.sock ; (the path to the socket file)...[supervisord];logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log);修改为 /var/log 目录，避免被系统删除logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log);日志文件多大时进行分割logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB);最多保留多少份日志文件logfile_backups=10 ; (num of main logfile rotation backups;default 10)loglevel=info ; (log level;default info; others: debug,warn,trace);pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid);修改为 /home/supervisor 目录，避免被系统删除pidfile=/home/supervisor/supervisord.pid ; (supervisord pidfile;default supervisord.pid)...;设置启动supervisord的用户，一般情况下不要轻易用root用户来启动，除非你真的确定要这么做;user=chrism ; (default is current user, required if root)...[supervisorctl]; 必须和&apos;unix_http_server&apos;里面的设定匹配;serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socket;修改为 /home/supervisor 目录，避免被系统删除serverurl=unix:///home/supervisor/supervisor.sock ; use a unix:// URL for a unix socket;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket;username=chris ; should be same as http_username if set;password=123 ; should be same as http_password if set... 使用浏览器来管理supervisor 同时提供了通过浏览器来管理进程的方法，只需要注释掉如下几行就可以了。 123456789;[inet_http_server] ; inet (TCP) server disabled by default;port=127.0.0.1:9001 ; (ip_address:port specifier, *:port for ;all iface);username=user ; (default is no username (open server));password=123 ; (default is no password (open server))[supervisorctl]...;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket;username=chris ; should be same as http_username if set;password=123 ; should be same as http_password if set 使用 include在配置文件的最后，有一个 [include] 的配置项，跟 Nginx 一样，可以 include 某个文件夹下的所有配置文件，这样我们就可以为每个进程或相关的几个进程的配置单独写成一个文件。 12[include]files = /etc/supervisor.d/*.ini 进程的配置样例123456789101112; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名[program:your_program_name]command=python server.py --port=9000;numprocs=1 ; 默认为1;process_name=%(program_name)s ; 默认为 %(program_name)s，即 [program:x] 中的 xdirectory=/home/python/tornado_server ; 执行 command 之前，先切换到工作目录user=oxygen ; 使用 oxygen 用户来启动该进程; 程序崩溃时自动重启，重启次数是有限制的，默认为3次autorestart=true redirect_stderr=true ; 重定向输出的日志stdout_logfile = /var/log/supervisor/tornado_server.logloglevel=info 启动 supervisord123456# 使用默认的配置文件 /etc/supervisord.confsupervisord# 明确指定配置文件supervisord -c /etc/supervisord.conf# 使用 user 用户启动 supervisordsupervisord -u user supervisorctl 命令介绍12345678910111213141516# 停止某一个进程，program_name 为 [program:x] 里的 xsupervisorctl stop program_name# 启动某个进程supervisorctl start program_name# 重启某个进程supervisorctl restart program_name# 结束所有属于名为 groupworker 这个分组的进程 (start，restart 同理)supervisorctl stop groupworker:# 结束 groupworker:name1 这个进程 (start，restart 同理)supervisorctl stop groupworker:name1# 停止全部进程，注：start、restart、stop 都不会载入最新的配置文件supervisorctl stop all# 载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程supervisorctl reload# 根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启supervisorctl update 更新配置文件12supervisorctl reread (只更新配置文件)supervisorctl update (只启动有改动的进程)]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>Supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 指令学习]]></title>
    <url>%2F2018%2F05%2F02%2Fubuntu-code-learning%2F</url>
    <content type="text"><![CDATA[Ubuntu 指令学习显示端口对应的信息12# 显示8081端口信息lsof -i:8081 杀死进程12# 杀死23919进程kill -9 23919 查询信息12# 在进程中查询新信息ps -aux | grep &quot;basic.py&quot; 显示结尾的信息12# 显示信息，并且在之间查询tail -f -n -10000 uwsgi.log | grep &quot;ERROR&quot; 更新信息，升级12345apt-get updateapt-get upgradeapt-get dist-upgrade upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来. dist-upgrade:可以聪明的解决相依性的问题,如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它. (所以通常这个会被认为是有点风险的升级) 查看磁盘空间大小12345678910111213141516171819202122232425262728293031323334# 查看磁盘剩余空间df -hl# 查看每个根路径的分区大小 df -h# 返回该目录的大小du -sh [目录名] # 返回该文件夹总M数du -sm [文件夹] # 查看更多功能df --help # 查看硬盘的分区sudo fdisk -l# 查看IDE硬盘信息 sudo hdparm -i /dev/hda# 查看STAT硬盘信息 sudo hdparm -I /dev/sda sudo apt-get install blktool sudo blktool /dev/sda id# 查看硬盘剩余空间 df -h #df -H# 查看目录占用空间 du -hs 目录名# 优盘没法卸载 sync fuser -km /media/usbdisk ubuntu 终端常用命令ctrl + l - 清屏 ctrl + c - 终止命令 ctrl + d - 退出 shell，好像也可以表示EOF ctrl + z - 将当前进程置于后台，fg还原。 ctrl + r - 从命令历史中找 ctrl + a - 光标移到行首 ctrl + e - 光标移到行尾 ctrl + u - 清除光标到行首的字符 ctrl + w - 清除光标之前一个单词 ctrl + k - 清除光标到行尾的字符 ctrl + t - 交换光标前两个字符 ctrl + y - 粘贴前一ctrl+u类命令删除的字符 ctrl + p - 上一条命令 ctrl + n - 下一条命令 ctrl + v - 输入控制字符 如ctrl+v ,会输入^M ctrl + f - 光标后移一个字符 ctrl + b - 光标前移一个字符 ctrl + h - 删除光标前一个字符]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的vim配置]]></title>
    <url>%2F2018%2F04%2F13%2Fmyvim%2F</url>
    <content type="text"><![CDATA[在这里保留下自己的vim配置 12345678910111213141516171819202122232425262728293031323334set nusyntax onset nocompatibleset confirmset mouse=aset tabstop=4set shiftwidth=4set expandtabset smarttabset autoindentset smartindentset hlsearchset showmatchset rulerset foldenableset foldmethod=manualautocmd InsertLeave * se noculautocmd InsertEnter * se culif version &gt;= 603 set helplang=cn set encoding=utf-8endif 需要在 vim ~/.vimrc 中配置，配置完成之后需要应用 source ~/.bashrc]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django过程中遇到的问题及解决方案]]></title>
    <url>%2F2018%2F04%2F03%2Fproblem-solving%2F</url>
    <content type="text"><![CDATA[​ 在学习过程中，遇到的一些问题和最后找的解决方案，在此记录保存，不定期更新。这其中的问题可能涉及到Django框架的操作，python语言的编写错误，或着uwsgi的一些错误，都在此记录。 UWSGI 出现 “invalid request block size: xxxx (max 4096)”的错误​ 对于uwsgi来说，默认会设置一个比较小的缓存（buffer 4k）来接收来接收每个请求的头信息,如果在日志中看见”invalid request block size”,它意味着你需要一个大一点的buffer。 ​ 简单的来说，就是URL的地址长度超过了4096个字符，而4096就是uwsgi配置中buffer-size的默认值，所以只需要将buffer-size改大一点即可。 可以在命令中加上buffer-size指出需要的大小 1uwsgi -x uwsgi.ini --buffer-size 32768 或者在配置文件中添加buffer-size = 8192 注意：如果你的日志中接收到了请求块大小为‘21573’，那这可能意味着你使用HTTP协议与一个使用uwsgi协议的实例进行通信。 ​ 问题基本解决，至于为什么这个问题是偶尔出现？那是因为openid登陆的时候会携带一个参数叫next_url，这个地址是用来指定登陆成功之后返回到哪里地址，如果这个next_url太长就会导致url地址超过4096，有时候next_url=/，即网站根地址，url地址长度就不会超过4096。另外还和openid返回的登陆人信息长度有关系，导致有些人从来不会出现这个错误，有些人偶尔出现这个问题。 参考：uwsgi部署到nginx出现invalid request block size: 4161 (max 4096) Django 数据库初始化时出现 django.core.exceptions.AppRegistryNotReady: Apps aren’t loaded yet.主要的报错原因是因为在数据库中使用了 12from django.contrib.auth import get_user_modelUser = get_user_model() ​ 来获得当前用户，这个是一个先查询的，就是说系统运行到这的时候，会先去查询这个用户类是否已经加载好，如果没有加载好就会出现这个错误。 目前没有想打一个比较好的办法解决，就初始阶段的解决方法有两个： 适当调整setting.py中INSTALLED_APPS的先后顺序，使得设计的AUTH_USER_MODEL比较先加载。 修改数据库代码，不这样获得用户，而是直接用字符串的方式获得 1from Project.settings import AUTH_USER_MODEL 之后在外键中直接使用 1base_info = models.OneToOneField(AUTH_USER_MODEL) Django中文编码错误问题​ 编码报错UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xb0 in position 1······ ​ 这类的问题，其中一个原因可能是在对方调用该接口的时候，传递过来的数据编码于本系统的编码格式不一致问题，在商量好双方的接口编码规则之后，可以尝试直接在出错问题的文件中修改系统的默认编码。 12345import sysdefaultencoding = 'utf-8'if sys.getdefaultencoding() != defaultencoding: reload(sys) sys.setdefaultencoding(defaultencoding)]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WARNING REMOTE HOST IDENTIFICATION HAS CHANGED!]]></title>
    <url>%2F2018%2F03%2F17%2Fssh-remote%2F</url>
    <content type="text"><![CDATA[在SSH连接云主机的时候出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!在我们连接云主机的时候，相关的配置会保存在/Users/apple/.ssh中的known_hosts文件内，如果云主机修改等操作后，就有可能会出现在这个问题。 解决方式很简单，进入到这个文件内，将相关的IP删除，之后在重新连接，即可。 进入到相关文件 1cd ~/.ssh vim 操作 1vim known_hosts 删除对应的行 重新连接 也可以使用ssh-keygen -R &quot;IP&quot;命令，直接删除相关远程连接的云主机IP 不推荐直接删除这个文件 known_hosts是记录远程主机的公钥的文件]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 虚拟环境]]></title>
    <url>%2F2018%2F03%2F10%2Fpython-vertualenv%2F</url>
    <content type="text"><![CDATA[python 虚拟环境设置virtualenv安装pip install virtualenv 创建虚拟环境virtualenv [新环境名] 使用source ./bin/activate 执行所创建的虚拟环境下的根目录的activate文件 退出deactivate 删除直接删除创建的文件夹就行 virtualenvwrapper安装pip install virtualenvwrapper 配置 创建虚拟环境管理目录: mkdir $HOME/.local/virtualenvs 在~/.bashrc中添加行： 12345678910export VIRTUALENV_USE_DISTRIBUTE=1export WORKON_HOME=$HOME/.local/virtualenvsif [ -e $HOME/.local/bin/virtualenvwrapper.sh ];then source $HOME/.local/bin/virtualenvwrapper.shelse if [ -e /usr/local/bin/virtualenvwrapper.sh ];then source /usr/local/bin/virtualenvwrapper.sh fifiexport PIP_VIRTUALENV_BASE=$WORKON_HOMEexport PIP_RESPECT_VIRTUALENV=true 启动 virtualenvwrapper: source ~/.bashrc 使用 创建虚拟环境 mkvirtualenv [环境名] 也可以在创建的时候加上参数，确定python版本，workon [环境名] --python=python3 删除 rmvirtualenv [环境名] 激活 workon [环境名] 退出 deactivate 列出所有环境 workon 或者 lsvirtualenv -b 查看所有指令virtualenvwrapper —help]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>virtualenv</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 05]]></title>
    <url>%2F2018%2F02%2F23%2Fdjango-rest-vue05%2F</url>
    <content type="text"><![CDATA[分类 view 123456789class CategoryViewset(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): """ list: 商品分类列表数据 retrieve: 获取商品分类详情 """ queryset = GoodsCategory.objects.filter(category_type=1) serializer_class = CategorySerializer Serializer 1234class CategorySerializer(serializers.ModelSerializer): class Meta: model = GoodsCategory fields = "__all__" url 12#配置category的urlrouter.register(r'categorys', CategoryViewset, base_name="categorys") 跨域问题django-cors-headers 官网 下载安装1pip install django-cors-headers 配置 INSTALLED_APPS 12345INSTALLED_APPS = ( ... 'corsheaders', ...) middleware 123456MIDDLEWARE = [ # Or MIDDLEWARE_CLASSES on Django &lt; 1.10 ... 'corsheaders.middleware.CorsMiddleware', # 只要添加这个 'django.middleware.common.CommonMiddleware', ...] 要放在CommonMiddleware前面 设置CORS_ORIGIN_ALLOW_ALL 1CORS_ORIGIN_ALLOW_ALL = True 用户登录和注册权限认证（DRF自带的token认证） Authentication setting123456REST_FRAMEWORK = &#123; 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.BasicAuthentication', 'rest_framework.authentication.SessionAuthentication', )&#125; 对应的Authentication也有三种，TokenAuthentication在前后端分离的系统中比较常见 TokenAuthentication 1234INSTALLED_APPS = ( ... 'rest_framework.authtoken') 创建对应的Token1234from rest_framework.authtoken.models import Tokentoken = Token.objects.create(user=...)print token.key 获取token的URL配置1234from rest_framework.authtoken import viewsurlpatterns += [ url(r'^api-token-auth/', views.obtain_auth_token)] 在输入用户名密码后会返回对应的token，用于前端保存使用，并且在提交的时候将这个token附加在httpheader中，确保用户的登录并且用于权限认证 在httpheader中添加token1Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b 在setting中配置token的认证方式1234567REST_FRAMEWORK = &#123; 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.BasicAuthentication', 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.TokenAuthentication', )&#125; 将token认证放到view中 将setting中的&#39;rest_framework.authentication.TokenAuthentication&#39;去除 在view中添加认证authentication_classes = (TokenAuthentication, ) 1234567891011from rest_framework.authentication import TokenAuthenticationclass GoodsListViewSet(CacheResponseMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination authentication_classes = (TokenAuthentication, ) JWT方式用户认证参考： 什么是 JWT – JSON WEB TOKEN JSON Web Token - 在Web应用间安全地传递信息 前后端分离之JWT用户认证 REST framework JWT Auth 安装1pip install djangorestframework-jwt 支持 Python (2.7, 3.3, 3.4, 3.5) Django (1.8, 1.9, 1.10) Django REST Framework (3.0, 3.1, 3.2, 3.3, 3.4, 3.5) setting12345678910REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': ( 'rest_framework.permissions.IsAuthenticated', ), 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework_jwt.authentication.JSONWebTokenAuthentication', 'rest_framework.authentication.SessionAuthentication', 'rest_framework.authentication.BasicAuthentication', ),&#125; url123456789from rest_framework_jwt.views import obtain_jwt_token#...urlpatterns = [ '', # ... url(r'^api-token-auth/', obtain_jwt_token),] 请求1curl -H "Authorization: JWT &lt;your_token&gt;" http://localhost:8000/protected-url/ 配置12345import datetimeJWT_AUTH = &#123; 'JWT_EXPIRATION_DELTA': datetime.timedelta(days=7), 'JWT_AUTH_HEADER_PREFIX': 'JWT',&#125; 自定义用户认证 setting 123AUTHENTICATION_BACKENDS = ( 'users.views.CustomBackend',) view 中的逻辑 1234567891011121314151617from django.contrib.auth.backends import ModelBackendfrom django.contrib.auth import get_user_modelfrom django.db.models import QUser = get_user_model()class CustomBackend(ModelBackend): """ 自定义用户验证 """ def authenticate(self, username=None, password=None, **kwargs): try: user = User.objects.get(Q(username=username)|Q(mobile=username)) if user.check_password(password): return user except Exception as e: return None 简单的信息发送12345678910111213141516171819202122232425import jsonimport requestsclass YunPian(object): def __init__(self, api_key): self.api_key = api_key self.single_send_url = "******" def send_sms(self, code, mobile): parmas = &#123; "apikey": self.api_key, "mobile": mobile, "text": "&#123;code&#125;。如非本人操作，请忽略本短信".format(code=code) &#125; response = requests.post(self.single_send_url, data=parmas) re_dict = json.loads(response.text) return re_dictif __name__ == "__main__": yun_pian = YunPian("****") yun_pian.send_sms("2017", "****") 可以直接在百度搜索本地ip，就能获得本机对外的ip地址 Serializer信息验证12345678code = serializers.CharField(required=True, write_only=True, max_length=4, min_length=4,label="验证码", error_messages=&#123; "blank": "请输入验证码", "required": "请输入验证码", "max_length": "验证码格式错误", "min_length": "验证码格式错误" &#125;, help_text="验证码") Validators123456from rest_framework.validators import UniqueValidatorslug = SlugField( max_length=100, validators=[UniqueValidator(queryset=BlogPost.objects.all())]) 例子： 1username = serializers.CharField(label="用户名", help_text="用户名", required=True, allow_blank=False, validators=[UniqueValidator(queryset=User.objects.all(), message="用户已经存在")]) 信号量post_save signal123456789from django.conf import settingsfrom django.db.models.signals import post_savefrom django.dispatch import receiverfrom rest_framework.authtoken.models import Token@receiver(post_save, sender=settings.AUTH_USER_MODEL)def create_auth_token(sender, instance=None, created=False, **kwargs): if created: Token.objects.create(user=instance) 例子： 12345678910111213from django.db.models.signals import post_savefrom django.dispatch import receiverfrom rest_framework.authtoken.models import Tokenfrom django.contrib.auth import get_user_modelUser = get_user_model()@receiver(post_save, sender=User)def create_user(sender, instance=None, created=False, **kwargs): if created: password = instance.password instance.set_password(password) instance.save() CurrentUserDefault 获取当前用户 123owner = serializers.HiddenField( default=serializers.CurrentUserDefault()) UniqueTogetherValidator 联合索引 123456789101112131415from rest_framework.validators import UniqueTogetherValidatorclass ExampleSerializer(serializers.Serializer): # ... class Meta: # ToDo items belong to a parent list, and have an ordering defined # by the 'position' field. No two items in a given list may share # the same position. validators = [ UniqueTogetherValidator( queryset=ToDoItem.objects.all(), fields=('list', 'position') message="巴拉巴拉" ) ] 也可以在数据库中添加联合索引 123456789101112131415class UserFav(models.Model): """ 用户收藏 """ user = models.ForeignKey(User, verbose_name="用户") goods = models.ForeignKey(Goods, verbose_name="商品", help_text="商品id") add_time = models.DateTimeField(default=datetime.now, verbose_name=u"添加时间") class Meta: verbose_name = '用户收藏' verbose_name_plural = verbose_name unique_together = ("user", "goods") def __str__(self): return self.user.username 用户权限认证IsAuthenticated123456789101112from rest_framework.permissions import IsAuthenticatedfrom rest_framework.response import Responsefrom rest_framework.views import APIViewclass ExampleView(APIView): permission_classes = (IsAuthenticated,) def get(self, request, format=None): content = &#123; 'status': 'request was permitted' &#125; return Response(content) 自定义权限12345678910111213141516from rest_framework import permissionsclass IsOwnerOrReadOnly(permissions.BasePermission): """ Object-level permission to only allow owners of an object to edit it. Assumes the model instance has an `owner` attribute. """ def has_object_permission(self, request, view, obj): # Read permissions are allowed to any request, # so we'll always allow GET, HEAD or OPTIONS requests. if request.method in permissions.SAFE_METHODS: return True # Instance must have an attribute named `owner`. return obj.owner == request.user view: 12345678class UserFavViewset(mixins.CreateModelMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet): permission_classes = (IsAuthenticated, IsOwnerOrReadOnly) serializer_class = UserFavSerializer def get_queryset(self): return UserFav.objects.filter(user=self.request.user) 缓存DRF增强安装1pip install drf-extensions 在view中添加CacheResponseMixin 12class GoodsListViewSet(CacheResponseMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): pass setting的一些配置（过期时间） 123REST_FRAMEWORK_EXTENSIONS = &#123; 'DEFAULT_CACHE_RESPONSE_TIMEOUT': 60 * 15&#125; django redisdjango-redis 中文文档 API限速 Throttling 在setting中配置 12345678910REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES': ( 'rest_framework.throttling.AnonRateThrottle', 'rest_framework.throttling.UserRateThrottle' ), 'DEFAULT_THROTTLE_RATES': &#123; 'anon': '100/day', 'user': '1000/day' &#125;&#125; 在view中 123456789101112from rest_framework.response import Responsefrom rest_framework.throttling import UserRateThrottlefrom rest_framework.views import APIViewclass ExampleView(APIView): throttle_classes = (UserRateThrottle,) def get(self, request, format=None): content = &#123; 'status': 'request was permitted' &#125; return Response(content) sentry错误日志 sentry sentry github django sentry 1pip install raven --upgrade setting 12345678910INSTALLED_APPS = ( 'raven.contrib.django.raven_compat',)import osimport ravenRAVEN_CONFIG = &#123; 'dsn': 'https://&lt;key&gt;:&lt;secret&gt;@sentry.io/&lt;project&gt;',&#125; celery异步 django通过celery添加异步任务]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django Rest Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 04]]></title>
    <url>%2F2018%2F02%2F20%2Fdjango-rest-vue04%2F</url>
    <content type="text"><![CDATA[使用类继承View的方式写接口导入基础view1from django.views.generic.base import View 在类中继承12class GoodsListView(View): pass 数据字典化的方式（序列化）传统查询-循环-赋值方式12345678910111213json_list = []goods = Goods.objects.all()[:10]for good in goods: json_dict = &#123;&#125; json_dict["name"] = good.name json_dict["category"] = good.category.name json_dict["market_price"] = good.market_price json_dict["add_time"] = good.add_time # 这里会出现错误，报错原因是时间格式不能序列化成json json_list.append(json_dict)from django.http import HttpResponseimport jsonreturn HttpResponse(json.dumps(json_list), content_tyoe="application/json") 使用Django自带的model_to_dict12345678from django.forms.models import model_to_dict for good in goods: json_dict = model_to_dict(good) # 这里也有可能报错，有些字段不能序列化 json_list.append(json_dict)from django.http import HttpResponseimport jsonreturn HttpResponse(json.dumps(json_list), content_tyoe="application/json") 使用serializers12345678import jsonfrom django.core import serializersjson_data = serializers.serialize('json', goods)json_data = json.loads(json_data)from django.http import JsonResponsereturn JsonResponse(json_data, safe=False) Django rest Framework Django REST framework 一些依赖包The following packages are optional: coreapi (1.32.0+) - Schema generation support. Markdown (2.1.0+) - Markdown support for the browsable API. django-filter (1.0.1+) - Filtering support. django-crispy-forms - Improved HTML display for filtering. django-guardian (1.1.1+) - Object level permissions support. 安装12345pip install django-guardianpip install coreapipip install django-filterpip install --upgrade django-crispy-formspip install markdown 注意这些包一定要装，不然后面有些依赖会报错 使用文档（documentation） 在url.py文件中引入 1from rest_framework.documentation import include_docs_urls 导入该url，注意结尾不要有“/” 1234urlpatterns = [ # ... url(r'docs/', include_docs_urls(title="doc")),] 一些初始化setting.py文件12345INSTALLED_APPS = [ # ... 'rest_framework', 'crispy_forms',] url.py文件123urlpatterns = [ url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')),] 使用 class-based views（基础的view）使用自己的Serializer（参考） 在对应的app下新建文件，serializers.py 基本内容内容 1234567from rest_framework import serializersclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) linenos = serializers.BooleanField(required=False) 在view文件中 1234567891011121314from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework.views import APIViewfrom rest_framework.response import Responseclass SnippetList(APIView): """ List all snippets, or create a new snippet. """ def get(self, request, format=None): snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) 备用： 123456789STATIC_URL = '/static/'MEDIA_URL = "/media/"STATICFILES_DIRS = ( os.path.join(BASE_DIR, "static"),)MEDIA_ROOT = os.path.join(BASE_DIR, "media") 在setting.py中如果配置了这个媒体路径，Django rest framework 就会在媒体路径之上加上这个路径，这样就能获得图片路径的完整地址 将数据保存到数据库中 在serializers.py文件中，需要保存的字段中，覆写create方法 作为给前端添加数据的一个接口 12345678910111213from rest_framework import serializersfrom snippets.models import Snippetclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) def create(self, validated_data): """ Create and return a new `Snippet` instance, given the validated data. """ return Snippet.objects.create(**validated_data) 在view中添加一个post方法 1234567891011121314151617181920212223from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom django.http import Http404from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework import statusclass SnippetList(APIView): """ List all snippets, or create a new snippet. """ def get(self, request, format=None): snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) def post(self, request, format=None): serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 使用ModelSerializers 在serializer中 1234567from rest_framework import serializersfrom snippets.models import Snippetclass SnippetSerializer(serializers.ModelSerializer): class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 注意：名字要和model中的一致，包括一开始使用的验证，名字也要相同 取出所有字段123class Meta: model = Snippet fields = "__all__" serializers的“外键” 只要在对应的serializers中添加字段覆盖对应的字段就行 1234567891011121314from rest_framework import serializersfrom snippets.models import Snippet, Categoryclass CategorySerializer(serializers.ModelSerializer): class Meta: model = GoodsCategory fields = "__all__"class SnippetSerializer(serializers.ModelSerializer): Category = CategorySerializer() class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 使用 mixins 和 GenericAPIViewGenericAPIView这是用的非常多的一个view，也是非常重要的view 1234567891011121314from rest_framework import mixinsfrom rest_framework import genericsclass SnippetList(mixins.ListModelMixin, mixins.CreateModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) 同样的，在listapiview中也有上面的方法，可以直接继承这个view，减少代码量 1234567from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework import genericsclass SnippetList(generics.ListCreateAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer 一共有以下的view可以继承 配置分页在setting中配置123REST_FRAMEWORK = &#123; 'PAGE_SIZE': 10,&#125; 在view中配置这个配置可以自定义自己的分页配置，这样的话就可以不用在setting中配置了，直接在view中配置 12345678910111213141516171819from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(generics.ListAPIView): """ 商品列表页, 分页， 搜索， 过滤， 排序 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination 使用viewsets1from rest_framework import viewsets 里面的view比较少 GenericViewSet 在view中继承ListModelMixin和GenericViewSet 12345678910from rest_framework import viewsetsfrom rest_framework import mixinsclass GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页, 分页， 搜索， 过滤， 排序 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination viewset的url配置方法 在url.py文件中配置url 12345678910from snippets.views import SnippetViewSetsnippet_list = SnippetViewSet.as_view(&#123; 'get': 'list', 'post': 'create'&#125;)urlpatterns = [ url(r'^snippets/$', snippet_list, name='snippet-list'),] 使用Routers 配置URL12345678910111213from django.conf.urls import url, includefrom rest_framework.routers import DefaultRouterfrom snippets import views# Create a router and register our viewsets with it.router = DefaultRouter()router.register(r'snippets', views.SnippetViewSet)router.register(r'users', views.UserViewSet)# The API URLs are now determined automatically by the router.urlpatterns = [ url(r'^', include(router.urls))] 一些view的继承 过滤功能 在view中添加 12345678910class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页, 分页， 搜索， 过滤， 排序 """ # queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination def get_queryset(self): return Goods.object.filter(shop_price__gt=100) FilteringDjangoFilterBackend官方文档 django-filter 步骤 首先安装 1pip install django-filter 将django-filter加到INSTALLED_APPS中 1234INSTALLED_APPS = [ # ... 'django_filters',] 设置个默认值（可以不设置） 123REST_FRAMEWORK = &#123; 'DEFAULT_FILTER_BACKENDS': ('django_filters.rest_framework.DjangoFilterBackend',)&#125; 使用 12345from django_filters.rest_framework import DjangoFilterBackendclass UserListView(generics.ListAPIView): # ... filter_backends = (DjangoFilterBackend,) 如果使用过滤器，就不需要使用get_queryset方法 例子： 123456789101112131415161718192021from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerfrom django_filters.rest_framework import DjangoFilterBackendclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend,) filter_fields = ('name', 'shop_price') 自定义Filters 新建filters.py文件 123456789101112from rest_framework import genericsfrom django_filters import rest_framework as filtersfrom myapp import Productclass ProductFilter(filters.FilterSet): min_price = filters.NumberFilter(name="price", lookup_expr='gte') max_price = filters.NumberFilter(name="price", lookup_expr='lte') class Meta: model = Product fields = ['category', 'in_stock', 'min_price', 'max_price'] 例子： 12345678910111213141516171819202122import django_filtersfrom django.db.models import Qfrom .models import Goodsclass GoodsFilter(django_filters.rest_framework.FilterSet): """ 商品的过滤类 """ pricemin = django_filters.NumberFilter(name='shop_price', help_text="最低价格",lookup_expr='gte') pricemax = django_filters.NumberFilter(name='shop_price', lookup_expr='lte') top_category = django_filters.NumberFilter(method='top_category_filter') def top_category_filter(self, queryset, name, value): return queryset.filter(Q(category_id=value)|Q(category__parent_category_id=value)|Q(category__parent_category__parent_category_id=value)) class Meta: model = Goods fields = ['pricemin', 'pricemax', 'is_hot', 'is_new'] 将view更改 1234567891011# ... class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend,) # filter_fields = ('name', 'shop_price') filter_class = GoodsFilter 模糊查询 1name = django_filters.CharFilter(name='name', lookup_expr='icontains') 不加lookup_expr=’icontains’这个字段就是全匹配 SearchFilter12345class UserListView(generics.ListAPIView): queryset = User.objects.all() serializer_class = UserSerializer filter_backends = (filters.SearchFilter,) search_fields = ('username', 'email') 例子：(view.py) 1234567891011121314151617181920212223from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerfrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework import filtersclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend, filters.SearchFilter) filter_class = GoodsFilter search_fields = ('^name', 'goods_brief', 'goods_desc') 在不同字段上使用下面的一些符号可以达到不同的效果 ‘^’ Starts-with search. ‘=’ Exact matches. ‘@’ Full-text search. (Currently only supported Django’s MySQL backend.) ‘$’ Regex search. OrderingFilter12345class UserListView(generics.ListAPIView): queryset = User.objects.all() serializer_class = UserSerializer filter_backends = (filters.OrderingFilter,) ordering_fields = ('username', 'email') 例子： 123456789101112131415161718192021222324from rest_framework.pagination import PageNumberPaginationfrom rest_framework import genericsfrom .models import Goodsfrom goods.serializers import GoodsSerializerfrom django_filters.rest_framework import DjangoFilterBackendfrom rest_framework import filtersclass GoodsPagination(PageNumberPagination): page_size = 12 page_size_query_param = 'page_size' page_query_param = "page" max_page_size = 100 class GoodsListViewSet(mixins.ListModelMixin, viewsets.GenericViewSet): """ 商品列表页 """ queryset = Goods.objects.all() serializer_class = GoodsSerializer pagination_class = GoodsPagination filter_backends = (DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter) filter_class = GoodsFilter search_fields = ('^name', 'goods_brief', 'goods_desc') ordering_fields = ('sale', 'time') API GuideThe API guide is your complete reference manual to all the functionality provided by REST framework. Requests Responses Views Generic views Viewsets Routers Parsers Renderers Serializers Serializer fields Serializer relations Validators Authentication Permissions Throttling Filtering Pagination Versioning Content negotiation Metadata Schemas Format suffixes Returning URLs Exceptions Status codes Testing Settings]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django Rest Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 03]]></title>
    <url>%2F2018%2F02%2F17%2Fdjango-rest-vue03%2F</url>
    <content type="text"><![CDATA[前后端分离的优缺点优点 pc，app，pad多端适应 SPA开发模式开始流行 前后端开发职责不清 开发效率问题，前后端互相等待 前端一直配合着后端，能力受限 后端开发语言和模版高度耦合，导致开发语言依赖严重 缺点 前后端学习门槛增加 数据依赖导致文档重要性增加 前端工作量加大 SEO的难度加大 后端开发模式迁移增加成本 Restful API restful api目前是前后端分离最佳实践 轻量，直接通过http，不需要额外的协议，post/get/put/delete操作 面向资源，具有解释性 数据描述简单，一般通过json或者xml做数据通信 参考 理解RESTful架构 RESTful API 设计指南 几个概念前端工程化 浅析前端工程化 前端工程化小记 前端优化带来的思考，浅谈前端工程化 数据双向绑定 mvvm vue.js MVC，MVP 和 MVVM 的图示 组件化开发 前端组件化开发 什么叫组件化开发？ vue开发的几个概念webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 中文官网 vue，vuex，vue-router，axios vue全家桶 vue.js ES6，babel ES6语法，babel可以将ES6转换成ES5 《ECMAScript 6 入门》]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 02]]></title>
    <url>%2F2018%2F02%2F16%2Fdjango-rest-vue02%2F</url>
    <content type="text"><![CDATA[参考： Unofficial Windows Binaries for Python Extension Packages Django REST framework 官网 安装进入到虚拟环境 pip install djangorestframework 安装Django，默认安装最新版本 pip install -i https://pypi.douban.com/simple django 安装markdown，Markdown support for the browsable API. pip install markdown 还需要安装 pip install django-filter 使用mysqlsetting.py 文件中修改：1234567891011121314DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'teacherAndStudentSystem', 'USER': 'root', 'PASSWORD': '', 'HOST': 'localhost', 'PORT': '3306', 'OPTIONS': &#123; 'charset': 'utf8mb4', 'init_command': 'SET default_storage_engine=INNODB;' &#125;, &#125;&#125; 在 MySQLWorkbench 中新建数据库 安装python的mysql驱动pip install mysqlclient 运行发现报错 “django.db.utils.OperationalError: (1193, “Unknown system variable ‘storage_engine’”)” 参考： 博客园 stackoverflow 因为版本的关系，所以只需要改为 SET default_storage_engine=INNODB; 即可 这个表示选择另一种连接方式，后面使用第三方登录的时候要用上 安装 pillowpip install pillow 这个是图形第三方插件 创建apps的package注意需要创建的是Python Package，而不是Directory 修改setting将apps加入到python的根搜索路径下 12345678import osimport sys# Build paths inside the project like this: os.path.join(BASE_DIR, ...)BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.insert(0, BASE_DIR)sys.path.insert(0, os.path.join(BASE_DIR, 'apps'))sys.path.insert(0, os.path.join(BASE_DIR, 'extra_apps')) 目前项目目录： vue项目安装需要的包在vue项目的根目录下执行 cnpm install 或 npm install 会生成一个model_modules的文件夹 运行cnpm run dev 或使用 npm run dev 设计app和models富文本编辑器Django-UEditor 参考 Django集成百度富文本编辑器uEditor 对应代码应用 把这第三方包复制到项目中 在setting中设置，加入改包 123456789INSTALLED_APPS = [ 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'users.apps.UsersConfig', 'DjangoUeditor',] 在模型类中导入 1from DjangoUeditor.models import UEditorField 模型中使用 12345678goods_desc = UEditorField( verbose_name=u"内容", imagePath="goods/images/", width=1000, height=300, filePath="goods/files/", default='') 模型类例子在线购物平台的商品模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142from datetime import datetimefrom django.db import modelsfrom DjangoUeditor.models import UEditorField# Create your models here.class GoodsCategory(models.Model): """ 商品类别 """ CATEGORY_TYPE = ( (1, "一级类目"), (2, "二级类目"), (3, "三级类目"), ) name = models.CharField(default="", max_length=30, verbose_name="类别名", help_text="类别名") code = models.CharField(default="", max_length=30, verbose_name="类别code", help_text="类别code") desc = models.TextField(default="", verbose_name="类别描述", help_text="类别描述") category_type = models.IntegerField(choices=CATEGORY_TYPE, verbose_name="类目级别", help_text="类目级别") parent_category = models.ForeignKey("self", null=True, blank=True, verbose_name="父类目级别", help_text="父目录", related_name="sub_cat") is_tab = models.BooleanField(default=False, verbose_name="是否导航", help_text="是否导航") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = "商品类别" verbose_name_plural = verbose_name def __str__(self): return self.nameclass GoodsCategoryBrand(models.Model): """ 品牌名 """ category = models.ForeignKey(GoodsCategory, related_name='brands', null=True, blank=True, verbose_name="商品类目") name = models.CharField(default="", max_length=30, verbose_name="品牌名", help_text="品牌名") desc = models.TextField(default="", max_length=200, verbose_name="品牌描述", help_text="品牌描述") image = models.ImageField(max_length=200, upload_to="brands/") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = "品牌" verbose_name_plural = verbose_name db_table = "goods_goodsbrand" def __str__(self): return self.nameclass Goods(models.Model): """ 商品 """ category = models.ForeignKey(GoodsCategory, verbose_name="商品类目") goods_sn = models.CharField(max_length=50, default="", verbose_name="商品唯一货号") name = models.CharField(max_length=100, verbose_name="商品名") click_num = models.IntegerField(default=0, verbose_name="点击数") sold_num = models.IntegerField(default=0, verbose_name="商品销售量") fav_num = models.IntegerField(default=0, verbose_name="收藏数") goods_num = models.IntegerField(default=0, verbose_name="库存数") market_price = models.FloatField(default=0, verbose_name="市场价格") shop_price = models.FloatField(default=0, verbose_name="本店价格") goods_brief = models.TextField(max_length=500, verbose_name="商品简短描述") goods_desc = UEditorField(verbose_name=u"内容", imagePath="goods/images/", width=1000, height=300, filePath="goods/files/", default='') ship_free = models.BooleanField(default=True, verbose_name="是否承担运费") goods_front_image = models.ImageField(upload_to="goods/images/", null=True, blank=True, verbose_name="封面图") is_new = models.BooleanField(default=False, verbose_name="是否新品") is_hot = models.BooleanField(default=False, verbose_name="是否热销") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '商品' verbose_name_plural = verbose_name def __str__(self): return self.nameclass IndexAd(models.Model): category = models.ForeignKey(GoodsCategory, related_name='category',verbose_name="商品类目") goods =models.ForeignKey(Goods, related_name='goods') class Meta: verbose_name = '首页商品类别广告' verbose_name_plural = verbose_name def __str__(self): return self.goods.nameclass GoodsImage(models.Model): """ 商品轮播图 """ goods = models.ForeignKey(Goods, verbose_name="商品", related_name="images") image = models.ImageField(upload_to="", verbose_name="图片", null=True, blank=True) add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '商品图片' verbose_name_plural = verbose_name def __str__(self): return self.goods.nameclass Banner(models.Model): """ 轮播的商品 """ goods = models.ForeignKey(Goods, verbose_name="商品") image = models.ImageField(upload_to='banner', verbose_name="轮播图片") index = models.IntegerField(default=0, verbose_name="轮播顺序") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '轮播商品' verbose_name_plural = verbose_name def __str__(self): return self.goods.nameclass HotSearchWords(models.Model): """ 热搜词 """ keywords = models.CharField(default="", max_length=20, verbose_name="热搜词") index = models.IntegerField(default=0, verbose_name="排序") add_time = models.DateTimeField(default=datetime.now, verbose_name="添加时间") class Meta: verbose_name = '热搜词' verbose_name_plural = verbose_name def __str__(self): return self.keywords 自定义User类 在模型类中导入 1from django.contrib.auth.models import AbstractUser 继承该AbstractUser类 12class UserProfile(AbstractUser): pass 引用外键 在另一个模型类中导入 1from django.contrib.auth import get_user_model 在外键中使用 1234567User = get_user_model()class ShoppingCart(models.Model): """ 购物车 """ user = models.ForeignKey(User, verbose_name=u"用户") 独立使用Django的model进行一些初始化123456789import sysimport ospwd = os.path.dirname(os.path.realpath(__file__))sys.path.append(pwd+"../")os.environ.setdefault("DJANGO_SETTINGS_MODULE", "Project.settings")import djangodjango.setup() 调用123from goods.models import GoodsCategoryall_categorys = GoodsCategory.objects.all() 顺序不能错 让Django识别媒体文件在settings.py中设置12MEDIA_URL = "/media/"MEDIA_ROOT = os.path.join(BASE_DIR, "media") 在urls.py中配置1234567from Project.settings import MEDIA_ROOTfrom django.views.static import serveurlpatterns = [ # ...more url(r'^media/(?P&lt;path&gt;.*)$', serve, &#123;"document_root": MEDIA_ROOT&#125;),] 目前项目目录]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Rest framework 学习笔记 01]]></title>
    <url>%2F2018%2F02%2F14%2Fdjango-rest-vue01%2F</url>
    <content type="text"><![CDATA[需要下载的资源 Pycharm WebStorm Node.js Mysql Workbench Pycharm 快捷启动（Linux） vim ~/.bashrc alias pycharm=&quot;bash /hom/bobby/Downloads/pycharm-2016.3.2/bin/pycharm.sh&quot; source ~/.bashrc pycharm Mysql 管理工具 Navicat Mysql Workbench Mysql 安装（Linux）获取安装包sudo apt-get install mysql-server 查看mysql的状态ps aux|grep mysqld 看是否有启动成功，并且可以查看端口地址 进入mysql shell中mysql -uroot -p 之后输入登录密码 mysql shell 的一些操作显示数据库show databases; 退出exit; 配置mysqlvim /etc/mysql/mysql.conf.d/mysqld.cnf 修改其中的 bind-address 配置，将IP改为0.0.0.0 重启mysqlsudo service mysql restart 修改用户权限GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION; 刷新用户权限 flush privileges; 字符集及排序规则 使用 utf8 -- UTF-8 Unicode 以及 utf8_general_ci 安装python（Linux） 安装的时候可以使用 python 豆瓣镜像 -i https://pypi.douban.com/simple 获取python3版本sudo apt-get install python3.5 虚拟环境安装sudo apt-get install python-virtualenv 使用虚拟环境virtualenv py2_env 会创建目录为py2_env的文件夹在该目录下 ps: 移除文件夹 rm -r py2_env/或 rm -f py2_env移除文件，慎用rm -rf py2_env 进入虚拟环境source py2_env/bin/activate 退出虚拟环境deactivate 创建python3的虚拟环境virtualenv -p python3 py3_env 安装pip3版本sudo apt-get install python3-pip 遇到 “OSError: Command /home/ubuntu/Myvirtualenv/py2_env/bin/python2 - setuptools pkg_resources pip wheel failed with error code 1”这个问题，解决方法： export LC_ALL=&quot;en_US.UTF-8&quot; export LC_CTYPE=&quot;en_US.UTF-8&quot; pip install setuptools 参考： setuptools pkg_resources pip wheel failed with error code 1 更新pip版本pip install --upgrade pip 虚拟环境管理安装pip install virtualenvwrapper 查找路径sudo find / -name virtualenvwrapper.sh /home/ubuntu/.local/bin/virtualenvwrapper.sh 配置 进入vim ~/.bashrc 在最后一行添加 export WORKON_HOME=$HOME/.virtualenvssource /home/ubuntu/.local/bin/virtualenvwrapper.sh ESC :wq保存 source ~/.bashrc 运行生效 创建虚拟环境mkvirtualenv py2_workon_env 目录安装所在地cd ~/.virtualenvs 使用 workon 查找全部的虚拟目录 workon py2_workon_env 使用该虚拟目录 deactivate 退出虚拟环境 创建python3的虚拟环境mkvirtualenv --python=python3 py3_workon_env ubuntu@VM-65-204-ubuntu:~$ workonpy2_workon_envpy3_workon_env 安装 Node.js参考： https://nodejs.org/dist/v8.9.3/ nodejs download Linux（Ubuntu）下安装NodeJs linux下安装nodejs+express(最新版) Linux下nodejs的安装配置 安装依赖包 sudo apt-get install g++ sudo apt-get install libssl-dev sudo apt-get install build-essential 下载压缩包wget https://nodejs.org/dist/v8.9.3/node-v8.9.3.tar.gz 解压tar zxvf node-v8.9.3.tar.gz 移动文件 mv source_file new_file 编译文件 进入到node-v8.9.3文件里 ./configure make 安装make install 修改环境配置参考 尝试 sudo apt-get install nodejs-legacy sudo apt-get install npm cnpm 淘宝 NPM 镜像 可以使用这个代替npm，国内镜像，下载速度可以更快 安装htopsudo apt-get install htop 可以查看系统运行的状态]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Httpie]]></title>
    <url>%2F2018%2F02%2F08%2Fhttpie%2F</url>
    <content type="text"><![CDATA[关于 HTTPie （读aych-tee-tee-pie）是一个 HTTP 的命令行客户端。 其目标是让 CLI 和 web 服务之间的交互尽可能的人性化。 这个工具提供了简洁的 http 命令，允许通过自然的语法发送任意 HTTP 请求数据，展示色彩化的输出。 HTTPie 可用于与 HTTP 服务器做测试、调试和常规交互。 特点 直观的语法 格式化和色彩化的终端输出 内置 JSON 支持 支持上传表单和文件 HTTPS、代理和认证 任意请求数据 自定义头部 持久性会话 类 Wget 下载 支持 Python 2.6, 2.7 和 3.x 支持 Linux, Mac OS X 和 Windows 插件 文档 测试覆盖率 安装pip install httpie 参考 HTTPie 工具使用入门 官方文档]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>httpie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Byobu "多窗口"的Terminal]]></title>
    <url>%2F2018%2F02%2F07%2Fbyobu%2F</url>
    <content type="text"><![CDATA[测试密码工具，密码是： lim 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]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>byobu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 学习笔记—基础01]]></title>
    <url>%2F2018%2F01%2F27%2FDjangoLearning1%2F</url>
    <content type="text"><![CDATA[参考 Django 1.8.2中文文档 Django 2.0 官方文档 Django 中文教学 自强学院 所需指令用指令创建项目django-admin startproject project 一般不用，直接用pycharm创建就行 运行应用python manage.py runserver 8080 运行后，才能根据所生成的网址，访问服务器，后面填写服务器的端口 也可以不写端口，如果没写端口，默认使用8000端口 创建一个应用python manage.py startapp djangoAppName(这里填写所需创建应用的名字)或django-admin startapp djangoAppName可以直接在apps目录下创建 有点类似于模块的意思，分模块开发项目，一个模块对应了view, model等内容，需要创建新的模块的时候，需要使用这个指令。 生成迁移（makemigrations）创建迁移文件 python manage.py makemigrations 创建之后，在所对应的migrations文件夹下面会多出一个.py文件 如果使用的是Django2.0 并且数据库model中使用了ForeignKey，需要在后面添加 on_delete 关键字 在使用这个命令的时候，需要在settings.py文件中的INSTALLED_APPS注册应用信息 执行迁移根据迁移文件，形成sql语句，创建对应的表 python manage.py migrate 创建超级管理员python manage.py createsuperuser 接下来按照提示填写用户名、邮箱、密码 后台URL: 在网址后面添加admin 显示所有的指令python manage.py 会显示所有的指令，并且在后面输入help name就可以查看对应指令的具体信息 Model创建 在对应的模版项目下的models.py文件下创建数据库模型文件 创建模型的时候不用创建主键id，系统会自动生成这个主键的列 Models.py1234567891011121314151617181920212223242526272829303132333435from django.db import modelsclass ModelName1(models.Model): title = models.CharField(max_length=20) date = models.DateTimeField() def __repr__(self): return 'title name is &#123;&#125;, crate at &#123;&#125;'.format(self.title, self.date) def __str__(self): return self.titleclass ModelName2(models.Model): hname = models.CharField(max_length=10) hgender = models.BooleanField() content = models.CharField(max_length=1000) modelName1ForeignKey = models.ForeignKey(ModelName1, on_delete=models.CASCADE) #外键 def __str__(self): return self.name def gender(self): if self.hgender: return '男' else: return '女' gender.short_description = '性别' def name(self): return self.hname name.short_description = '名字' Django2.0 ForeignKey 变化在创建外键的时候遇到报错： TypeError: __init__() missing 1 required positional argument: &#39;on_delete&#39; 查询一番后发现Django2.0版本创建外键时需要在后面加上on_delete 12345class Car(models.Model): manufacturer = models.ForeignKey( 'Manufacturer', on_delete=models.CASCADE, ) 站点管理界面本地化修改settings.py 12LANGUAGE_CODE = 'zh-Hans'TIME_ZONE = 'Asia/Shanghai' 修改语言和时区 向admin中注册应用在 booktest/admin.py 文件，注册模型 123from django.contrib import adminfrom models import ModelNameadmin.site.register(ModelName) 导入model 类 在admin中注册该模型类 admin.site.register(ModelName) 自定义管理页面 Django提供了admin.ModelAdmin类 通过定义ModelAdmin的子类，来定义模型在Admin界面的显示方式 1234567891011class ModelNameAdmin(admin.ModelAdmin): list_display = ['id', 'title', 'date'] list_filter = ['title'] search_fields = ['title'] list_per_page = 10 fieldsets = [ ('base',&#123;'fields':['title']&#125;), ('super',&#123;'fields':['date']&#125;) ]admin.site.register(BookInfo, BookInfoAdmin) 列表页属性list_display 显示字段，可以点击列头进行排序 1list_display = ['pk', 'title', 'date'] 列表里面填写的是字段的列表名字，表示要在后台页面中显示什么列表字段，先后顺序决定显示顺序 list_filter 过滤字段，过滤框会出现在右侧 1list_filter = ['title'] search_fields 搜索字段，搜索框会出现在上侧 1search_fields = ['title'] 支持模糊查询，根据列表中的字段进行查询 list_per_page 分页，分页框会出现在下侧 1list_per_page = 10 添加、修改页属性fields 属性的先后顺序 1fields = ['date', 'title'] fieldsets 属性分组 1234fieldsets = [ ('basic',&#123;'fields': ['title']&#125;), ('more', &#123;'fields': ['date']&#125;),] 关联对象 对于模型类，有两种注册方式 方式一：与传统模型类相同 方式二：关联注册 按照BookInfor的注册方式完成HeroInfo的注册 接下来实现关联注册 12345678910111213141516171819202122232425262728from django.contrib import adminfrom .models import *# StackedInline TabularInlineclass ModelName2Line(admin.TabularInline): model = HeroInfo extra = 1class ModelName1Admin(admin.ModelAdmin): list_display = ['id', 'title', 'date'] list_filter = ['title'] search_fields = ['title'] list_per_page = 10 fieldsets = [ ('base', &#123;'fields': ['title']&#125;), ('super', &#123;'fields': ['date']&#125;) ] inlines = [ModelName2Line]class ModelName2Admin(admin.ModelAdmin): list_display = ['id', 'name', 'gender', 'content', 'modelName1ForeignKey'] list_filter = ['hgender']admin.site.register(ModelName1, ModelName1Admin)admin.site.register(ModelName2, ModelName2Admin) 可以将内嵌的方式改为表格 1class ModelName2Line(admin.TabularInline) 布尔值的显示 发布性别的显示不是一个直观的结果，可以使用方法进行封装 123456def gender(self): if self.hgender: return '男' else: return '女'gender.short_description = '性别' 在admin注册中使用gender代替hgender 12class ModelName2Admin(admin.ModelAdmin): list_display = ['id', 'name', 'gender', 'content'] 视图 在django中，视图对WEB请求进行回应 视图接收reqeust对象作为第一个参数，包含了请求的信息 视图就是一个Python函数，被定义在views.py中 123456from django.http import HttpResponsedef index(request): return HttpResponse("index")def detail(request,id): return HttpResponse("detail %s" % id) 定义完成视图后，需要配置urls.py，否则无法处理请求 urls.py12345678from django.contrib import adminfrom django.urls import pathfrom DjangoLearn1 import viewsurlpatterns = [ path('admin/', admin.site.urls), path('',views.index)] 此时，就可以访问了，不过考虑到如果这样填写，模块一多，URL的量一大的话，就会出现多个路由，不方便配置，所以推荐如下 在对应模块里面创建一个 urls.py 的文件，将路由信息写到里面 1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 之后，在向主urls.py文件中include进去 1234567from django.urls import include, pathfrom django.contrib import adminurlpatterns = [ path('', include('DjangoLearn1.urls')), path('admin/', admin.site.urls),] 模板 模板是html页面，可以根据视图中传递的数据填充值 在模板中访问视图传递的数据 12&#123;&#123; 输出值，可以是变量，也可以是对象.属性 &#125;&#125;&#123;% 执行代码段 %&#125; 定义HTML模板123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;列表&lt;/h1&gt;&lt;ul&gt;&#123;%for ModeleName1 in ModeleName1List%&#125;&lt;li&gt; &lt;a href="&#123;&#123;ModeleName1.id&#125;&#125;"&gt; &#123;&#123;ModeleName1.title&#125;&#125; &lt;/a&gt;&lt;/li&gt;&#123;%endfor%&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 在模板中访问对象成员时，都以属性的方式访问，即方法也不能加括号 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;详细&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123;ModeleName1.title&#125;&#125;&lt;/h1&gt;&lt;ul&gt; &#123;%for Modele in ModeleName1.ModelName2_set.all%&#125; &lt;li&gt;&#123;&#123;Modele.name&#125;&#125;---&#123;&#123;Modele.content&#125;&#125;&lt;/li&gt; &#123;%endfor%&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 使用模板 编辑views.py文件，在方法中调用模板 Django提供了函数Render()简化视图调用模板、构造上下文 1234567891011from django.shortcuts import renderfrom models import ModeleName1def index(reqeust): ModeleName1List = ModeleName1.objects.all() return render(reqeust, 'booktest/index.html', &#123;'ModeleName1List': ModeleName1List&#125;)def detail(reqeust, id): ModeleName1 = ModeleName1.objects.get(pk=id) return render(reqeust, 'booktest/detail.html', &#123;'ModeleName1': ModeleName1&#125;) 总结 视图 Views： 接受请求，逻辑处理，调用数据，输出响应 配置ulr在自己的应用中匹配url 模型Model：负责与数据库交互 面向对象：模型对象，列表 定义模型类：指出属性及类型，以确定表的结构，迁移 后台管理：创建管理员，启动服务器，admin，注册admin.py 模版：定义显示的样子 加载：读取文件内容到内存 渲染：填内容]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + nexT 学习笔记]]></title>
    <url>%2F2017%2F12%2F30%2FHexoLearn-re%2F</url>
    <content type="text"><![CDATA[前言 本文内容主要是个人在学习hexo和next中所遇到的一些“坑”和解决方法,而详细的流程网上有很多，在文章的结尾我会贴出我在学习中查找到的比较好的文章。 注意本文不是详细操作步骤，如果需要详细步骤，请直接翻到文章结尾。 官方文档 Hexo nexT Hexo 和 nexT 的安装 在安装 Hexo 之前，需要确保电脑环境要有 Node.js 和 Git 环境, 当然，为了更好的安装 Hexo 还需要 npm. 下面是我所使用的版本： 安装之后，最常使用的指令如下： 生成静态页面 1hexo g 在本地运行 1hexo s 部署到GitHub pages（coding） 1hexo d 清除生成的静态文件 1hexo clean 打开 GitHub Pages在第一次创建完仓库之后，打开settings选项，向下翻到GitHub Pages选项会发现不能打开，会有一个提示信息： GitHub Pages is currently disabled. You must first add content to your repository before you can publish a GitHub Pages site 是因为该GitHub Pages没有内容，此时只要点击下面的Choose a theme按钮选择一个主题就可以打开和访问了。 SSH 配置 先查看本机用户home目录下是否存在.ssh目录 1cd ~/.ssh 如果有就不用再创建了，如果想重新创建，可以创建一个不同名字的，也可以将原来的删除，再创建。 使用下面指令删除已存在的SSH： 12ssh-add -Drm -r ~/.ssh 再创建新的SSH密钥(keys) 1$ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 这将按照你提供的邮箱地址，创建一对密钥 将生成的id_rsa.pub文件里面的内容拷贝到GitHub 项目中添加公钥，这里推荐在对应 xxx.github.io 项目中加。（settings-&gt;deploy keys） 最后再用下面指令测试是否连接成功 1ssh -T git@github.com 可参考github提示Permission denied (publickey)，如何才能解决？ 同步到GitHub 配置站点文件下的_config.xml文件下的deploy信息。 安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 关于 https 的问题，如果需要使用自己的域名的话，GitHub pages 是不能打开 Enforce HTTPS 的。所以在配置deploy信息的时候就推荐使用 Clone with SSH 的链接。 绑定域名 在source文件夹下面创建CNAME文件（没有后缀），里面填上自己的域名。 之后在自己的域名商将自己的域名用CNAME方式指向自己GitHub pages的域名。 个人使用的是腾讯云 最后需要注意，需要在站点文件的_config.xml文件配置中的skip_render添加: 12skip_render: - CNAME 表示跳过该文件的渲染。 nexT 主题配置一些我觉得比较实用的效果，参考hexo的next主题个性化配置教程. 添加 README.md在站点文件的source目录下添加一个README.md文件，之后修改站点文件下的_config.xml，将skip_render添加README.md，跳过该文件的渲染。 123skip_render: - CNAME - README.md Schemes个人比较喜欢Gemini样式，相比Pisces样式，该样式不会每篇文章相连过于紧密，会以分块的形式显示出来，比较好看，特别在手机端上效果更显著。具体可以亲自去设置去看看效果。 live2d就是网站右下角的萌物”小人，具体可以参考hexo-helper-live2d。下面简要介绍我的做法： 在站点文件打开终端输入 1npm install --save hexo-helper-live2d 在站点文件下的_config.xml最后配置： 12live2d: model: z16 具体的配置可以看文档，可以修改挺多内容的。模型外观参考截图预览. 动态背景在主题文件的_config.xml中搜索Canvas-nest可以发现有4个动态背景，可以逐个尝试，也可以同时设置为true，个人只选择了Canvas-nest。 footer可以将网站最下的不想要显示的内容设置为false，在主题文件的_config.xml中搜索footer，我的设置如下： 12345678910111213141516171819footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: user # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). powered: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: false busuanzi访问人数在主题文件的_config.xml中搜索busuanzi_count，修改配置，可以在网站底部和文章中显示访问的人数，我的配置如下： 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数 site_uv_footer: | # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 访问总量 site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读次数 page_pv_footer: 显示统计字数在主题文件的_config.xml中搜索post_wordcount，修改配置，可以在网站底部和文章中显示所统计的字数，我的配置如下： 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 增加本地搜索功能在主题文件的_config.xml中搜索local_search，设置为true。 参考： Hexo博客无法搜索的终极解决方法 在文章底部增加版权信息在主题文件的_config.xml中搜索post_copyright，设置为true。 给文章加密参考： hexo-blog-encrypt 安装： npm install hexo-blog-encrypt 首先在 _config.yml 中启用该插件 123# Securityencrypt: enable: true 在你的文章的头部添加上对应的字段，如 password, abstract, message 123456789---title: hello worlddate: 2016-03-30 21:18:02tags: - fdsafsdafpassword: Mikeabstract: Welcome to my blog, enter password to read.message: Welcome to my blog, enter password to read.--- 写文章一般使用 1hexo new xxx xxx表示文件的名字，同时也会自动设置为文章标题（后面可改）以之间创建.md文件，添加文章头信息 1234567title: // 文章标题date: // 创建时间updated: //跟新文章的时间tags: // 文章的标签，如果有多个，[tags1, tags2, ...]categories: // 文章分类keywords: // 文章关键词，如果有多个，[key1, key2, ...]description: //文章描述 其中需要注意： 如果想要有updated，需要在主题文件下的_config.xml文件中配置post_meta，将updated_at设置为true。 12345post_meta: item_text: true created_at: true updated_at: true categories: true keywords和description的作用是为了搜索引擎寻找关键字。 其中description关键字，在主页上显示的时候就会显示这里面的内容，而不是显示前150个字符。还有另一种方法推荐，就是不写description，而是在文章中插入&lt;!-- more --&gt;注释，这样主页就会显示该注释前的内容。 可添加内容下面的内容是推广和维护网站相关。 网站分析个人使用的是腾讯移动分析，而且nexT也可以直接支持，在主题文件的_config.xml中搜索Tencent MTA ID，将自己在网站上注册的 ID 填写上去就可以统计了。 seo推广这里推荐参考Hexo+nexT主题搭建个人博客中seo推广部分。 参考百度搜索资源平台 推荐阅读 Hexo+nexT主题搭建个人博客 hexo初探—让写作飞起来 史上最详细的Hexo博客搭建图文教程 Hexo + GitHub (Coding) Pages 搭建博客 基于 Hexo 和 GitHub Pages 搭建博客 Hexo搭建独立博客，托管到Github和Coding上教程 让更多人看到你的博客 在github上搭建个人网站 如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题？ Hexo+Next主题集成Algolia搜索]]></content>
      <categories>
        <category>博客技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天算是把我的博客网站建立起来了]]></title>
    <url>%2F2017%2F12%2F27%2Fhellomyblog%2F</url>
    <content type="text"><![CDATA[花了三天时间，终于搞定了，这也表示我的文章之旅要开始了。enjoy it !]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
</search>
