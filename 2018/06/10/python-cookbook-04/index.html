<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  
<script type="text/javascript">
    var _speedMark = new Date();
</script>

<script type="text/javascript" src="http://tajs.qq.com/stats?sId=64866827" charset="UTF-8"></script>


<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="HRlPcTjXKc" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/uploads/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/uploads/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/uploads/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/uploads/safari-pinned-tab.svg?v=5.1.3" color="#222">


  <link rel="manifest" href="/images/uploads/manifest.json">


  <meta name="msapplication-config" content="/images/uploads/browserconfig.xml" />



  <meta name="keywords" content="python3, Cookbook" />










<meta name="description" content="《Python CookBook 3》  这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。 元编程 深入浅出Python装饰器  wraps 简单聊聊Python中的wraps修饰器  简单的说，就是使得我们自定的修饰起函数的一些函数属性更加符合我们的预期。 在我们使用函数的类似于 __doc__ 和 __name__ 等，需要获">
<meta name="keywords" content="python3, Cookbook">
<meta property="og:type" content="article">
<meta property="og:title" content="Python Cookbook 笔记 04">
<meta property="og:url" content="http://jaelyn.coding.me/2018/06/10/python-cookbook-04/index.html">
<meta property="og:site_name" content="Jaelyn&#39;s Blog">
<meta property="og:description" content="《Python CookBook 3》  这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。 元编程 深入浅出Python装饰器  wraps 简单聊聊Python中的wraps修饰器  简单的说，就是使得我们自定的修饰起函数的一些函数属性更加符合我们的预期。 在我们使用函数的类似于 __doc__ 和 __name__ 等，需要获">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-05T04:26:17.106Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python Cookbook 笔记 04">
<meta name="twitter:description" content="《Python CookBook 3》  这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。 元编程 深入浅出Python装饰器  wraps 简单聊聊Python中的wraps修饰器  简单的说，就是使得我们自定的修饰起函数的一些函数属性更加符合我们的预期。 在我们使用函数的类似于 __doc__ 和 __name__ 等，需要获">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'S2RJTOM4KM',
      apiKey: '46aa43b4dc81f6d01e063ef5e5dba1a7',
      indexName: 'blog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jaelyn.coding.me/2018/06/10/python-cookbook-04/"/>





  <title>Python Cookbook 笔记 04 | Jaelyn's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jaelyn's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">jaelyn-lim</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jaelyn.coding.me/2018/06/10/python-cookbook-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaelyn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jaelyn's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Python Cookbook 笔记 04</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-10T11:15:05+08:00">
                2018-06-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-08-05T12:26:17+08:00">
                2018-08-05
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python3/" itemprop="url" rel="index">
                    <span itemprop="name">python3</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读次数
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  14,553
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  64
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html" target="_blank" rel="noopener">《Python CookBook 3》</a></li>
</ul>
<p>这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。</p>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><ul>
<li><a href="http://aju.space/2016/01/14/dive-into-python-decorator.html" target="_blank" rel="noopener">深入浅出Python装饰器</a></li>
</ul>
<h2 id="wraps"><a href="#wraps" class="headerlink" title="wraps"></a>wraps</h2><ul>
<li><a href="https://segmentfault.com/a/1190000009398663" target="_blank" rel="noopener">简单聊聊Python中的wraps修饰器</a></li>
</ul>
<p>简单的说，就是使得我们自定的修饰起函数的一些函数属性更加符合我们的预期。</p>
<p>在我们使用函数的类似于 <code>__doc__</code> 和 <code>__name__</code> 等，需要获得函数的一些属性的时候，如果直接使用，就会输出修饰函数的信息：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""这个是修饰函数"""</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_function</span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""这个是被修饰的函数"""</span></span><br><span class="line">    print(<span class="string">'wrapped'</span>)</span><br><span class="line"></span><br><span class="line">print(wrapped.__doc__)  <span class="comment"># 输出`这个是修饰函数`</span></span><br><span class="line">print(wrapped.__name__)  <span class="comment"># 输出`wrapper_function`</span></span><br></pre></td></tr></table></figure>
<p>这并不符合我们的预期，我们应该想知道的是 <code>wrapped</code> 的信息才对，所以就需要 <code>wraps</code> 修饰器，将原本 <code>wrapped</code> 的信息复制到 <code>wrapper</code> 中，从源码中也可以发现，源码中使用了 <code>partial</code> 和 <code>update_wrapper</code> 这两个函数，其中 <code>update_wrapper</code> 就是将信息复制使用的，而 <code>partial</code> 是填充 <code>update_wrapper</code> 的。</p>
<p>任何时候你定义装饰器的时候，都应该使用 <code>functools</code> 库中的 <code>@wraps</code> 装饰器来注解底层包装函数。</p>
<h2 id="装饰器（修饰器）"><a href="#装饰器（修饰器）" class="headerlink" title="装饰器（修饰器）"></a>装饰器（修饰器）</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p01_put_wrapper_around_function.html" target="_blank" rel="noopener">在函数上添加包装器</a></li>
</ul>
<p>使用修饰器，增加额外的操作，如日志，计时等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(func.__name__, end-start)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timethis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">countdown(<span class="number">1000000</span>)</span><br><span class="line"><span class="comment"># countdown 0.09182381629943848</span></span><br><span class="line">countdown(<span class="number">9999999</span>)</span><br><span class="line"><span class="comment"># countdown 0.823084831237793</span></span><br></pre></td></tr></table></figure>
<p>一个装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timethis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>和下面的效果等同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">countdown = timethis(countdown)</span><br></pre></td></tr></table></figure>
<p>python 自带的一些装饰器也是同样的道理。</p>
<p>在上面的 <code>wrapper()</code> 函数中， 装饰器内部定义了一个使用 <code>*args</code> 和  <code>**kwargs</code> 来接受任意参数的函数。 在这个函数里面调用了原始函数并将其结果返回，不过你还可以添加其他额外的代码(比如计时)。 然后这个新的函数包装器被作为结果返回来代替原始函数。</p>
<p>需要强调的是装饰器并不会修改原始函数的参数签名以及返回值。 使用 <code>*args</code> 和  <code>**kwargs</code> 目的就是确保任何参数都能适用。 而返回结果值基本都是调用原始函数 <code>func(*args, **kwargs)</code> 的返回结果，其中func就是原始函数。</p>
<h2 id="定义一个带参数的装饰器"><a href="#定义一个带参数的装饰器" class="headerlink" title="定义一个带参数的装饰器"></a>定义一个带参数的装饰器</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p04_define_decorator_that_takes_arguments.html" target="_blank" rel="noopener">定义一个带参数的装饰器</a></li>
</ul>
<p>定义了多个包裹的函数，最外层的函数负责接收参数，里面的两层负责接收函数，对函数进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        log = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.DEBUG)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x: int, y: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.CRITICAL, 'example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>最外层的函数 <code>logged()</code> 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数 <code>decorate()</code> 接受一个函数作为参数，然后在函数上面放置一个包装器。 这里的关键点是包装器是可以使用传递给 <code>logged()</code> 的参数的。</p>
<p>简单的说可以概括为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator(x, y, z)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以等价为下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func = decorator(x, y, z)(func)</span><br></pre></td></tr></table></figure>
<p><code>decorator(x, y, z)</code> 的返回结果必须是一个可调用对象，它接受一个函数作为参数并包装它。</p>
<h2 id="可自定义属性的装饰器"><a href="#可自定义属性的装饰器" class="headerlink" title="可自定义属性的装饰器"></a>可自定义属性的装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps, partial</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach_wrapper</span><span class="params">(obj, func=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(attach_wrapper, obj)</span><br><span class="line">    setattr(obj, func.__name__, func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        log = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @attach_wrapper(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_level</span><span class="params">(newlevle)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> level</span><br><span class="line">            level = newlevle</span><br><span class="line"></span><br><span class="line"><span class="meta">        @attach_wrapper(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_message</span><span class="params">(newmsg)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> logmsg</span><br><span class="line">            logmsg = newmsg</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.DEBUG)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x: int, y: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.CRITICAL, 'example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>__main__:add</span></span><br><span class="line">add.set_message(<span class="string">'add called'</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>__main__:add called</span></span><br><span class="line">add.set_level(logging.WARNING)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># WARNING:__main__:add called</span></span><br><span class="line">spam()</span><br><span class="line"><span class="comment"># Spam!</span></span><br><span class="line"><span class="comment"># CRITICAL:example:spam</span></span><br></pre></td></tr></table></figure>
<p>其中，在函数 <code>set_message()</code> 和 <code>set_level()</code> 中，作为属性赋值给包装器，每个函数里面，允许使用 <code>nonlocal</code> 来访问上一层包裹的函数（闭包），修改函数内部的变量。</p>
<p>如果有多个装饰器，调用的顺序是从里到外调用，最先调用最里面的装饰器，最后调用最外层的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>等效于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure>
<h2 id="带可选参数的装饰器"><a href="#带可选参数的装饰器" class="headerlink" title="带可选参数的装饰器"></a>带可选参数的装饰器</h2><p>自定义一个装饰器，可以选择接收参数，<code>@decorator(x, y, z)</code> ， 也可以选择不接收参数，直接 <code>@decorator</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps, partial</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func=None, *, level=logging.DEBUG, name=None, message=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(logged, level=level, name=name, message=message)</span><br><span class="line">    logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">    log = logging.getLogger(logname)</span><br><span class="line">    logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span>  func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        log.log(level, logmsg)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(level=logging.DEBUG, name='example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam !'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>__main__:add</span></span><br><span class="line">spam()</span><br><span class="line"><span class="comment"># Spam !</span></span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>example:spam</span></span><br></pre></td></tr></table></figure>
<p>对于不加参数的装饰器的调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>上面的调用次序可以和下面的等同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">add = logged(add)</span><br></pre></td></tr></table></figure>
<p>这时候，被装饰函数会被当做第一个参数直接传递给 <code>logged</code> 装饰器。 因此，<code>logged()</code> 中的第一个参数就是被包装函数本身。所有其他参数都必须有默认值。</p>
<p>而对于带有参数的装饰器的调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logged(level=logging.CRITICAL, name='example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br></pre></td></tr></table></figure>
<p>可以和下面的调用次序等同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br><span class="line">spam = logged(level=logging.CRITICAL, name=<span class="string">'example'</span>)(spam)</span><br></pre></td></tr></table></figure>
<p>初始调用 <code>logged()</code> 函数时，被包装函数并没有传递进来。 因此在装饰器内，它必须是可选的。这个反过来会迫使其他参数必须使用关键字来指定。 并且，但这些参数被传递进来后，装饰器要返回一个接受一个函数参数并包装它的函数。 为了这样做，我们使用了一个技巧，就是利用 <code>functools.partial</code> 。 它会返回一个未完全初始化的自身，除了被包装函数外其他参数都已经确定下来了。</p>
<blockquote>
<p>原本如果没有参数的时候，默认装饰器会将函数作为第一个参数传入，但是如果有参数的话，被包装的函数就没有传递进来，又因为使用了通配符的关系，后面的参数就全都需要关键字参数的形式传递进来，之后使用的 <code>partial</code> 函数，又将自身 <code>logged</code> 返回，使得又再一次调用自己的这个装饰器，只不过就带上了参数，返回自身。</p>
</blockquote>
<h2 id="利用装饰器强制函数上的类型检查"><a href="#利用装饰器强制函数上的类型检查" class="headerlink" title="利用装饰器强制函数上的类型检查"></a>利用装饰器强制函数上的类型检查</h2><p>作为函数的规范，希望在函数的参数上加上参数的类型检查。</p>
<p>一般来说，python 的设计思想是不需要类型检查的，这样不仅会增加代码量，而且也使得python哲学失去意义，站在python的角度来说，不需要对变量进行类型的设定，同样也不需要对变量进行类型检查，python 有很强的自省，如果有什么异常会直接抛出，它认定我们是已经长大的成人了，不需要对这些进行而外的限制，使得我们能更加关注于逻辑的开发，而不是把焦点放在不必要的类型检查，而这所有的前提就是我们能处理自己的错误，或者说不会乱搞。</p>
<p>有时候我们需要对参数进行检查的时候，我们可以写一个装饰器，对函数进行参数的检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span><span class="params">(*ty_args, **ty_kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="comment"># If in optimized mode, disable type checking</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> __debug__:</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Map function argument names to supplied types</span></span><br><span class="line">        sig = signature(func)</span><br><span class="line">        bound_types = sig.bind_partial(*ty_args, **ty_kwargs).arguments</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            bound_values = sig.bind(*args, **kwargs)</span><br><span class="line">            <span class="comment"># Enforce type assertions across supplied arguments</span></span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">in</span> bound_types:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, bound_types[name]):</span><br><span class="line">                        <span class="keyword">raise</span> TypeError(</span><br><span class="line">                            <span class="string">'Argument &#123;&#125; must be &#123;&#125;'</span>.format(name, bound_types[name])</span><br><span class="line">                            )</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>
<p>使用的时候就按照正常的装饰器的调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@typeassert(int, int)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    print(add(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line">    print(add(<span class="string">'1233'</span>, <span class="number">23</span>))</span><br></pre></td></tr></table></figure>
<p>首先，装饰器只会在函数定义时被调用一次。 有时候你去掉装饰器的功能，那么你只需要简单的返回被装饰函数即可。 下面的代码中，如果全局变量　<code>__debug__</code> 被设置成了False(当你使用-O或-OO参数的优化模式执行程序时)， 那么就直接返回未修改过的函数本身：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># If in optimized mode, disable type checking</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> __debug__:</span><br><span class="line">        <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure>
<p>其次，这里还对被包装函数的参数签名进行了检查，我们使用了 <code>inspect.signature()</code> 函数。 简单来讲，它运行你提取一个可调用对象的参数签名信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(x, y, z=<span class="number">42</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sig = signature(spam)</span><br><span class="line">print(sig)</span><br><span class="line"><span class="comment"># (x, y, z=42)</span></span><br><span class="line">print(sig.parameters)</span><br><span class="line"><span class="comment"># OrderedDict([('x', &lt;Parameter "x"&gt;), ('y', &lt;Parameter "y"&gt;), ('z', &lt;Parameter "z=42"&gt;)])</span></span><br><span class="line">print(sig.parameters[<span class="string">'z'</span>].name)</span><br><span class="line"><span class="comment"># z</span></span><br><span class="line">print(sig.parameters[<span class="string">'z'</span>].default)</span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line">print(sig.parameters[<span class="string">'z'</span>].kind)</span><br><span class="line"><span class="comment"># POSITIONAL_OR_KEYWORD</span></span><br></pre></td></tr></table></figure>
<p>这个模块的功能主要是获得其他函数的参数信息。</p>
<p>装饰器的开始部分，我们使用了 <code>bind_partial()</code> 方法来执行从指定类型到名称的部分绑定。 下面是例子演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types = sig.bind_partial(int,z=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types</span><br><span class="line">&lt;inspect.BoundArguments object at <span class="number">0x10069bb50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types.arguments</span><br><span class="line">OrderedDict([('x', &lt;class 'int'&gt;), ('z', &lt;class 'int'&gt;)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在这个部分绑定中，你可以注意到缺失的参数被忽略了(比如并没有对y进行绑定)。 不过最重要的是创建了一个有序字典 <code>bound_types.arguments</code> 。 这个字典会将参数名以函数签名中相同顺序映射到指定的类型值上面去。 在我们的装饰器例子中，这个映射包含了我们要强制指定的类型断言。</p>
<p>在装饰器创建的实际包装函数中使用到了 <code>sig.bind()</code> 方法。 <code>bind()</code> 跟 <code>bind_partial()</code> 类似，但是它不允许忽略任何参数。因此有了下面的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_values = sig.bind(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_values.arguments</span><br><span class="line">OrderedDict([(<span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="number">3</span>)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>综合来说</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name <span class="keyword">in</span> bound_types.arguments:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, bound_types.arguments[name]):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> TypeError()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>不过对于一些有默认值的参数并不适用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@typeassert(int, list)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(x, items=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> items <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="meta">... </span>        items = []</span><br><span class="line"><span class="meta">... </span>    items.append(x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> items</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar(<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"contract.py"</span>, line <span class="number">33</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">TypeError: Argument items must be &lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">bar</span><span class="params">(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span></span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用元类控制实例的创建"><a href="#使用元类控制实例的创建" class="headerlink" title="使用元类控制实例的创建"></a>使用元类控制实例的创建</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p13_using_mataclass_to_control_instance_creation.html" target="_blank" rel="noopener">使用元类控制实例的创建</a></li>
</ul>
<p>通过改变实例创建方式来实现单例、缓存或其他类似的特性。</p>
<p>主要使用 <code>__call__()</code> 元类来操作，通过限制这个元类，来限制类的实例的创建。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoInstances</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Can't instantiate directly"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=NoInstances)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grok</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'Spam.grok'</span>)</span><br></pre></td></tr></table></figure>
<p>或者实现单例模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__instance = <span class="keyword">None</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Spam'</span>)</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Spam()</span><br><span class="line">Creating Spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>也可以创建弱引用的缓存实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cached</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.__cache = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> self.__cache:</span><br><span class="line">            <span class="keyword">return</span> self.__cache[args]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj = super().__call__(*args)</span><br><span class="line">            self.__cache[args] = obj</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Cached)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Spam(&#123;!r&#125;)'</span>.format(name))</span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Spam(<span class="string">'Guido'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Guido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Spam(<span class="string">'Diana'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Diana'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Spam(<span class="string">'Guido'</span>) <span class="comment"># Cached</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c <span class="comment"># Cached value returned</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>如果没有使用元类的方式，也可以在全局里面定义变量保存类的实例，在写函数，全局引用这个实例，如果有这个对象的话，就返回这个对象本身，没有的话，就创建一个新的实例，赋值给变量。</p>
<h2 id="定义有可选参数的元类"><a href="#定义有可选参数的元类" class="headerlink" title="定义有可选参数的元类"></a>定义有可选参数的元类</h2><p>定义一个元类，允许类定义时提供可选参数，这样可以控制或配置类型的创建过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStream</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reada</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>然而，在自定义元类中我们还可以提供其他的关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=MyMeta, debug=True, synchronize=True)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>为了使元类支持这些关键字参数，你必须确保在 <code>__prepare__()</code> , <code>__new__()</code> 和 <code>__init__()</code> 方法中 都使用强制关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># Optional</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> super().__prepare__(name, bases)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, ns, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, ns)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, ns, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        super().__init__(name, bases, ns)</span><br></pre></td></tr></table></figure>
<p>给一个元类添加可选关键字参数需要你完全弄懂类创建的所有步骤， 因为这些参数会被传递给每一个相关的方法。 <code>__prepare__()</code> 方法在所有类定义开始执行前首先被调用，用来创建类命名空间。 通常来讲，这个方法只是简单的返回一个字典或其他映射对象。 <code>__new__()</code> 方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。 <code>__init__()</code> 方法最后被调用，用来执行其他的一些初始化工作。</p>
<p>当我们构造元类的时候，通常只需要定义一个 <code>__new__()</code> 或 <code>__init__()</code> 方法，但不是两个都定义。 但是，如果需要接受其他的关键字参数的话，这两个方法就要同时提供，并且都要提供对应的参数签名。 默认的 <code>__prepare__()</code> 方法接受任意的关键字参数，但是会忽略它们， 所以只有当这些额外的参数可能会影响到类命名空间的创建时你才需要去定义 <code>__prepare__()</code> 方法。</p>
<p>将这些属性定义为参数的好处在于它们不会污染类的名称空间， 这些属性仅仅只从属于类的创建阶段，而不是类中的语句执行阶段。 另外，它们在 <code>__prepare__()</code> 方法中是可以被访问的，因为这个方法会在所有类主体执行前被执行。 但是类变量只能在元类的 <code>__new__()</code> 和 <code>__init__()</code> 方法中可见。</p>
<h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p16_enforce_argument_signature_on_args_kwargs.html" target="_blank" rel="noopener"> *args和**kwargs的强制参数签名</a></li>
</ul>
<p>你有一个函数或方法，它使用*args和**kwargs作为参数，这样使得它比较通用， 但有时候你想检查传递进来的参数是不是某个你想要的类型。</p>
<p>对任何涉及到操作函数调用签名的问题，你都应该使用 <code>inspect</code> 模块中的签名特性。 我们最主要关注两个类：<code>Signature</code> 和 <code>Parameter</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> Signature, Parameter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parms = [</span><br><span class="line">    Parameter(<span class="string">'x'</span>, Parameter.POSITIONAL_OR_KEYWORD),</span><br><span class="line">    Parameter(<span class="string">'y'</span>, Parameter.POSITIONAL_OR_KEYWORD, default=<span class="number">42</span>),</span><br><span class="line">    Parameter(<span class="string">'z'</span>, Parameter.KEYWORD_ONLY, default=<span class="keyword">None</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sig = Signature(parms)</span><br><span class="line">print(sig)</span><br><span class="line"><span class="comment"># (x, y=42, *, z=None)</span></span><br></pre></td></tr></table></figure>
<p>一旦你有了一个签名对象，你就可以使用它的 <code>bind()</code> 方法很容易的将它绑定到 <code>*args</code> 和 <code>**kwargs</code> 上去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    bound_values = sig.bind(*args, **kwargs)</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">        print(name, value)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># x 1</span></span><br><span class="line"><span class="comment"># y 2</span></span><br><span class="line"><span class="comment"># z 3</span></span><br></pre></td></tr></table></figure>
<p>可以看出来，通过将签名和传递的参数绑定起来，可以强制函数调用遵循特定的规则，比如必填、默认、重复等等。</p>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> Signature, Parameter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_sig</span><span class="params">(*names)</span>:</span></span><br><span class="line">    parms = [Parameter(name, Parameter.POSITIONAL_OR_KEYWORD)</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line">    <span class="keyword">return</span> Signature(parms)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Structure</span>:</span></span><br><span class="line">    __signature__ = make_sig()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        bound_values = self.__signature__.bind(*args, **kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    __signature__ = make_sig(<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    __signature__ = make_sig(<span class="string">'x'</span>, <span class="string">'y'</span>)</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> inspect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(inspect.signature(Stock))</span><br><span class="line">(name, shares, price)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">490.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: <span class="string">'price'</span> parameter lacking default value</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">490.1</span>, shares=<span class="number">50</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: multiple values <span class="keyword">for</span> argument <span class="string">'shares'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="types-new-class"><a href="#types-new-class" class="headerlink" title="types.new_class"></a>types.new_class</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p18_define_classes_programmatically.html" target="_blank" rel="noopener">以编程方式定义类</a></li>
</ul>
<p>以字符串的方式去创建一个新的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, shares, price)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.shares = shares</span><br><span class="line">    self.price = price</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.shares * self.price</span><br><span class="line"></span><br><span class="line">cls_dict = &#123;</span><br><span class="line">    <span class="string">'__init__'</span> : __init__,</span><br><span class="line">    <span class="string">'cost'</span> : cost,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a class</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">Stock = types.new_class(<span class="string">'Stock'</span>, (), &#123;&#125;, <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line">Stock.__module__ = __name__</span><br><span class="line"></span><br><span class="line">s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># &lt;__main__.Stock object at 0x10409af60&gt;</span></span><br><span class="line">print(s.cost())</span><br><span class="line"><span class="comment"># 4555.0</span></span><br></pre></td></tr></table></figure>
<p>这种方法中，一个比较难理解的地方是在调用完 <code>types.new_class()</code> 对 <code>Stock.__module__</code> 的赋值。 每次当一个类被定义后，它的 <code>__module__</code> 属性包含定义它的模块名。 这个名字用于生成 <code>__repr__()</code> 方法的输出。它同样也被用于很多库，比如 <code>pickle</code> 。 因此，为了让你创建的类是“正确”的，你需要确保这个属性也设置正确了。</p>
<p><code>new_class()</code> 第四个参数最神秘，它是一个用来接受类命名空间的映射对象的函数。 通常这是一个普通的字典，但是它实际上是 <code>__prepare__()</code> 方法返回的任意对象。</p>
<h2 id="避免重复的属性方法"><a href="#避免重复的属性方法" class="headerlink" title="避免重复的属性方法"></a>避免重复的属性方法</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p21_avoid_repetitive_property_methods.html" target="_blank" rel="noopener">避免重复的属性方法</a></li>
</ul>
<p>当我们在类中有需要重复的去执行相同逻辑的操作，可以采用闭包的形式去简化代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name ,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'name must be a string'</span>)</span><br><span class="line">        self._name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'age must be an int'</span>)</span><br><span class="line">        self._age = value</span><br></pre></td></tr></table></figure>
<p>如果有更多的变量的值的话，我们就需要写更多的代码，而这样是个不可取的。为此，我们可以采用闭包的形式，将有相似操作的内容都用闭包处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typed_property</span><span class="params">(name, expected_type)</span>:</span></span><br><span class="line">    storage_name = <span class="string">'_'</span> + name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self, storage_name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @prop.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'&#123;&#125; must be a &#123;&#125;'</span>.format(name, expected_type))</span><br><span class="line">        setattr(self, storage_name, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prop</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = typed_property(<span class="string">'name'</span>, str)</span><br><span class="line">    age = typed_property(<span class="string">'age'</span>, int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>
<p>例子中的函数 <code>typed_property()</code> 看上去有点难理解，其实它所做的仅仅就是为你生成属性并返回这个属性对象。 因此，当在一个类中使用它的时候，效果跟将它里面的代码放到类定义中去是一样的。 尽管属性的 <code>getter</code> 和 <code>setter</code> 方法访问了本地变量如 <code>name</code> , <code>expected_type</code> 以及 <code>storate_name</code> ，这个很正常，这些变量的值会保存在闭包当中。</p>
<h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p24_parse_and_analyzing_python_source.html" target="_blank" rel="noopener">解析与分析Python源码</a></li>
</ul>
<p><code>ast</code> 模块能被用来将Python源码编译成一个可被分析的抽象语法树（AST）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ex = ast.parse(<span class="string">'2 + 3*4 + x'</span>, mode=<span class="string">'eval'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ex</span><br><span class="line">&lt;_ast.Expression object at <span class="number">0x1007473d0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(ex)</span><br><span class="line"><span class="string">"Expression(body=BinOp(left=BinOp(left=Num(n=2), op=Add(),</span></span><br><span class="line"><span class="string">right=BinOp(left=Num(n=3), op=Mult(), right=Num(n=4))), op=Add(),</span></span><br><span class="line"><span class="string">right=Name(id='x', ctx=Load())))"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>top = ast.parse(<span class="string">'for i in range(10): print(i)'</span>, mode=<span class="string">'exec'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>top</span><br><span class="line">&lt;_ast.Module object at <span class="number">0x100747390</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(top)</span><br><span class="line"><span class="string">"Module(body=[For(target=Name(id='i', ctx=Store()),</span></span><br><span class="line"><span class="string">iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=10)],</span></span><br><span class="line"><span class="string">keywords=[], starargs=None, kwargs=None),</span></span><br><span class="line"><span class="string">body=[Expr(value=Call(func=Name(id='print', ctx=Load()),</span></span><br><span class="line"><span class="string">args=[Name(id='i', ctx=Load())], keywords=[], starargs=None,</span></span><br><span class="line"><span class="string">kwargs=None))], orelse=[])])"</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h1><h2 id="all"><a href="#all" class="headerlink" title="__all__"></a><code>__all__</code></h2><p>如果定义了 <code>__all__</code> , 那么只有被列举出的东西会被导出。</p>
<p>如果你将 <code>__all__</code> 定义成一个空列表, 没有东西将被导入。 如果 <code>__all__</code> 包含未定义的名字, 在导入时引起<code>AttributeError</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># somemodule.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grok</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">blah = <span class="number">42</span></span><br><span class="line"><span class="comment"># Only export 'spam' and 'grok'</span></span><br><span class="line">__all__ = [<span class="string">'spam'</span>, <span class="string">'grok'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="将模块分割成多个文件"><a href="#将模块分割成多个文件" class="headerlink" title="将模块分割成多个文件"></a>将模块分割成多个文件</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p04_split_module_into_multiple_files.html" target="_blank" rel="noopener">将模块分割成多个文件</a></li>
</ul>
<p>想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。</p>
<p>一个类似于这样的文件，可以尝试将一个模块分为两个类，方便对不同内容的功能分开管理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mymodule.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.bar'</span>)</span><br></pre></td></tr></table></figure>
<p>这时候需要将这两个类（A和B）分成两个文件，并且需要在 python 模块中将这两个文件的内容导入。</p>
<p>首先用mymodule目录来替换文件mymodule.py。 这这个目录下，创建以下文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymodule/</span><br><span class="line">    __init__.py</span><br><span class="line">    a.py</span><br><span class="line">    b.py</span><br></pre></td></tr></table></figure>
<p>最后，在 <strong>init</strong>.py 中，将2个文件粘合在一起：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> .a <span class="keyword">import</span> A</span><br><span class="line"><span class="keyword">from</span> .b <span class="keyword">import</span> B</span><br></pre></td></tr></table></figure>
<p>有时候，如果需要导入的模块很大的话，我们就可以考虑延时导入，对于一些很大的模块，我们可以在需要的时候才导入所需要的模块。</p>
<p><code>__init__.py</code>文件一次导入所有必需的组件的。但是对于一个很大的模块，可能你只想组件在需要时被加载。 要做到这一点，<code>__init__.py</code>有细微的变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> .a <span class="keyword">import</span> A</span><br><span class="line">    <span class="keyword">return</span> A()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> .b <span class="keyword">import</span> B</span><br><span class="line">    <span class="keyword">return</span> B()</span><br></pre></td></tr></table></figure>
<p>在这个版本中，类A和类B被替换为在第一次访问时加载所需的类的函数。对于用户，这看起来不会有太大的不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import mymodule</span><br><span class="line">&gt;&gt;&gt; a = mymodule.A()</span><br><span class="line">&gt;&gt;&gt; a.spam()</span><br><span class="line">A.spam</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>延迟加载的主要缺点是继承和类型检查可能会中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if isinstance(x, mymodule.A): # Error</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if isinstance(x, mymodule.a.A): # Ok</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="利用命名空间导入目录分散的代码"><a href="#利用命名空间导入目录分散的代码" class="headerlink" title="利用命名空间导入目录分散的代码"></a>利用命名空间导入目录分散的代码</h2><p>你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作为独立的包来安装。</p>
<p>从本质上讲，你要定义一个顶级Python包，作为一个大集合分开维护子包的命名空间。这个问题经常出现在大的应用框架中，框架开发者希望鼓励用户发布插件或附加包。</p>
<p>在统一不同的目录里统一相同的命名空间，但是要删去用来将组件联合起来的<code>__init__.py</code>文件。假设你有Python代码的两个不同的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo-package/</span><br><span class="line">    spam/</span><br><span class="line">        blah.py</span><br><span class="line"></span><br><span class="line">bar-package/</span><br><span class="line">    spam/</span><br><span class="line">        grok.py</span><br></pre></td></tr></table></figure>
<p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有<code>__init__.py</code>文件。</p>
<p>我们可以在另外的文件中导入所需。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">'foo-package'</span>, <span class="string">'bar-package'</span>])</span><br><span class="line"><span class="keyword">import</span> spam.blah</span><br><span class="line"><span class="keyword">import</span> spam.grok</span><br></pre></td></tr></table></figure>
<p>在这里工作的机制被称为“包命名空间”的一个特征。从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p>
<p>包命名空间的关键是确保顶级目录中没有<code>__init__.py</code>文件来作为共同的命名空间。缺失<code>__init__.py</code>文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其<code>__path__</code>变量中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">'foo-package'</span>, <span class="string">'bar-package'</span>])</span><br><span class="line"><span class="comment"># import spam.blah</span></span><br><span class="line"><span class="comment"># import spam.grok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spam</span><br><span class="line">print(spam.__path__)</span><br><span class="line"><span class="comment"># _NamespacePath(['foo-package/spam', 'bar-package/spam'])</span></span><br></pre></td></tr></table></figure>
<p>一个包是否被作为一个包命名空间的主要方法是检查其<code>__file__</code>属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的“namespace”这个词体现出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(spam)</span><br><span class="line"><span class="comment"># &lt;module 'spam' (namespace)&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="__main__"></a><code>__main__</code></h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p07_make_directory_or_zip_runnable_as_main_script.html" target="_blank" rel="noopener">运行目录或压缩文件</a></li>
</ul>
<p>您有一个已成长为包含多个文件的应用，它已远不再是一个简单的脚本，你想向用户提供一些简单的方法运行这个程序。</p>
<p>如果你的应用程序已经有多个文件，你可以把你的应用程序放进它自己的目录并添加一个<code>__main__.py</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myapplication/</span><br><span class="line">    spam.py</span><br><span class="line">    bar.py</span><br><span class="line">    grok.py</span><br><span class="line">    __main__.py</span><br></pre></td></tr></table></figure>
<p>如果<code>__main__.py</code>存在，就可以简单地在顶级目录运行Python解释器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash % python3 myapplication</span><br></pre></td></tr></table></figure>
<h2 id="importlib-import-module"><a href="#importlib-import-module" class="headerlink" title="importlib.import_module"></a>importlib.import_module</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p10_import_modules_using_name_given_in_string.html" target="_blank" rel="noopener">通过字符串名导入模块</a></li>
</ul>
<p>使用<code>importlib.import_module()</code>函数来手动导入名字为字符串给出的一个模块或者包的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import importlib</span><br><span class="line">&gt;&gt;&gt; math = importlib.import_module(&apos;math&apos;)</span><br><span class="line">&gt;&gt;&gt; math.sin(2)</span><br><span class="line">0.9092974268256817</span><br><span class="line">&gt;&gt;&gt; mod = importlib.import_module(&apos;urllib.request&apos;)</span><br><span class="line">&gt;&gt;&gt; u = mod.urlopen(&apos;http://www.python.org&apos;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><code>import_module</code>只是简单地执行和<code>import</code>相同的步骤，但是返回生成的模块对象。你只需要将其存储在一个变量，然后像正常的模块一样使用。</p>
<p>如果你正在使用的包，<code>import_module()</code>也可用于相对导入。但是，你需要给它一个额外的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line"># Same as &apos;from . import b&apos;</span><br><span class="line">b = importlib.import_module(&apos;.b&apos;, __package__)</span><br></pre></td></tr></table></figure>
<p>使用<code>import_module()</code>手动导入模块的问题通常出现在以某种方式编写修改或覆盖模块的代码时候。例如，也许你正在执行某种自定义导入机制，需要通过名称来加载一个模块，通过补丁加载代码。</p>
<p>在旧的代码，有时你会看到用于导入的内建函数<code>__import__()</code>。尽管它能工作，但是<code>importlib.import_module()</code> 通常更容易使用。</p>
<h2 id="安装私有的包"><a href="#安装私有的包" class="headerlink" title="安装私有的包"></a>安装私有的包</h2><p>安装一个包，只是提供给自己使用，而不是系统上的所有用户使用。</p>
<p>Python有一个用户安装目录，通常类似”~/.local/lib/python3.3/site-packages”。 要强制在这个目录中安装包，可使用安装选项“–user”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py install --user</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user packagename</span><br></pre></td></tr></table></figure>
<h2 id="pyvenv"><a href="#pyvenv" class="headerlink" title="pyvenv"></a>pyvenv</h2><p>使用 <code>pyvenv</code> 命令创建一个新的“虚拟”环境。 这个命令被安装在Python解释器同一目录，或Windows上面的Scripts目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash % pyvenv Spam</span><br><span class="line">bash %</span><br></pre></td></tr></table></figure>
<p>这个解释器的特点就是他的site-packages目录被设置为新创建的环境。 如果你要安装第三方包，它们会被安装在那里，而不是通常系统的site-packages目录。</p>
<p>创建虚拟环境通常是为了安装和管理第三方包。 正如你在例子中看到的那样，<code>sys.path</code> 变量包含来自于系统Python的目录， 而 site-packages目录已经被重定位到一个新的目录。</p>
<p>有了一个新的虚拟环境，下一步就是安装一个包管理器，比如distribute或pip。 但安装这样的工具和包的时候，你需要确保你使用的是虚拟环境的解释器。 它会将包安装到新创建的site-packages目录中去。</p>
<p>尽管一个虚拟环境看上去是Python安装的一个复制， 不过它实际上只包含了少量几个文件和一些符号链接。 所有标准库函文件和可执行解释器都来自原来的Python安装。 因此，创建这样的环境是很容易的，并且几乎不会消耗机器资源。</p>
<p>默认情况下，虚拟环境是空的，不包含任何额外的第三方库。如果你想将一个已经安装的包作为虚拟环境的一部分， 可以使用“–system-site-packages”选项来创建虚拟环境，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash % pyvenv --system-site-packages Spam</span><br><span class="line">bash %</span><br></pre></td></tr></table></figure>
<h1 id="网络与Web编程"><a href="#网络与Web编程" class="headerlink" title="网络与Web编程"></a>网络与Web编程</h1><h2 id="urllib-request"><a href="#urllib-request" class="headerlink" title="urllib.request"></a>urllib.request</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c11/p01_interact_with_http_services_as_client.html" target="_blank" rel="noopener">作为客户端与HTTP服务交互</a></li>
</ul>
<p>发送一个简单的HTTP GET请求到远程的服务上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base URL being accessed</span></span><br><span class="line">url = <span class="string">'http://httpbin.org/get'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of query parameters (if any)</span></span><br><span class="line">parms = &#123;</span><br><span class="line">   <span class="string">'name1'</span> : <span class="string">'value1'</span>,</span><br><span class="line">   <span class="string">'name2'</span> : <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encode the query string</span></span><br><span class="line">querystring = parse.urlencode(parms)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a GET request and read the response</span></span><br><span class="line">u = request.urlopen(url+<span class="string">'?'</span> + querystring)</span><br><span class="line">resp = u.read()</span><br></pre></td></tr></table></figure>
<p>使用POST方法在请求主体中发送查询参数，可以将参数编码后作为可选参数提供给 <code>urlopen()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base URL being accessed</span></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of query parameters (if any)</span></span><br><span class="line">parms = &#123;</span><br><span class="line">   <span class="string">'name1'</span> : <span class="string">'value1'</span>,</span><br><span class="line">   <span class="string">'name2'</span> : <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encode the query string</span></span><br><span class="line">querystring = parse.urlencode(parms)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a POST request and read the response</span></span><br><span class="line">u = request.urlopen(url, querystring.encode(<span class="string">'ascii'</span>))</span><br><span class="line">resp = u.read()</span><br></pre></td></tr></table></figure>
<p>如果你需要在发出的请求中提供一些自定义的HTTP头，例如修改 <code>user-agent</code> 字段,可以创建一个包含字段值的字典，并创建一个Request实例然后将其传给 <code>urlopen()</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extra headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-agent'</span> : <span class="string">'none/ofyourbusiness'</span>,</span><br><span class="line">    <span class="string">'Spam'</span> : <span class="string">'Eggs'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = request.Request(url, querystring.encode(<span class="string">'ascii'</span>), headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a request and read the response</span></span><br><span class="line">u = request.urlopen(req)</span><br><span class="line">resp = u.read()</span><br></pre></td></tr></table></figure>
<p>使用 <code>requests</code> 库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base URL being accessed</span></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of query parameters (if any)</span></span><br><span class="line">parms = &#123;</span><br><span class="line">   <span class="string">'name1'</span> : <span class="string">'value1'</span>,</span><br><span class="line">   <span class="string">'name2'</span> : <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extra headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-agent'</span> : <span class="string">'none/ofyourbusiness'</span>,</span><br><span class="line">    <span class="string">'Spam'</span> : <span class="string">'Eggs'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.post(url, data=parms, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decoded text returned by the request</span></span><br><span class="line">text = resp.text</span><br></pre></td></tr></table></figure>
<p><code>get</code> 请求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://gank.io/api/xiandu/categories'</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>
<p>关于requests库，一个值得一提的特性就是它能以多种方式从请求中返回响应结果的内容。从上面的代码来看， <code>resp.text</code> 带给我们的是以Unicode解码的响应文本。但是，如果去访问 <code>resp.content</code> ，就会得到原始的二进制数据。另一方面，如果访问 <code>resp.json</code> ，那么就会得到JSON格式的响应内容。</p>
<h1 id="网络与web"><a href="#网络与web" class="headerlink" title="网络与web"></a>网络与web</h1><h2 id="创建TCP服务器"><a href="#创建TCP服务器" class="headerlink" title="创建TCP服务器"></a><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c11/p02_creating_tcp_server.html" target="_blank" rel="noopener">创建TCP服务器</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> BaseRequestHandler, TCPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoHandler</span><span class="params">(BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Got connection from'</span>, self.client_address)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            msg = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.request.send(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    serv = TCPServer((<span class="string">''</span>, <span class="number">20000</span>), EchoHandler)</span><br><span class="line">    serv.serve_forever()</span><br></pre></td></tr></table></figure>
<p>定义了一个特殊的处理类，实现了一个 <code>handle()</code> 方法，用来为客户端连接服务。 <code>request</code> 属性是客户端socket，<code>client_address</code> 有客户端地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Jun 19 10:07:25 on ttys001</span><br><span class="line">JaelynLim:~ Jaelyn$ python</span><br><span class="line">Python 2.7.11 (v2.7.11:6d1b6a68f775, Dec  5 2015, 12:54:16)</span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; from socket import socket</span><br><span class="line">&gt;&gt;&gt; from socket import AF_INET, SOCK_STREAM</span><br><span class="line">&gt;&gt;&gt; s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">&gt;&gt;&gt; s.connect((&apos;localhost&apos;, 20000))</span><br><span class="line">&gt;&gt;&gt; s.send(b&apos;Hello&apos;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; s.recv(8192)</span><br><span class="line">&apos;Hello&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码进行访问测试，<code>Got connection from (&#39;127.0.0.1&#39;, 53691)</code> 。</p>
<p><code>socketserver</code> 可以让我们很容易的创建简单的TCP服务器。 但是，你需要注意的是，默认情况下这种服务器是单线程的，一次只能为一个客户端连接服务。 如果你想处理多个客户端，可以初始化一个 <code>ForkingTCPServer</code> 或者是 <code>ThreadingTCPServer</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> ThreadingTCPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    serv = ThreadingTCPServer((<span class="string">''</span>, <span class="number">20000</span>), EchoHandler)</span><br><span class="line">    serv.serve_forever()</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://gist.github.com/kevinkindom/108ffd675cb9253f8f71" target="_blank" rel="noopener">Python Socket 编程详细介绍</a></li>
<li><a href="http://blog.51cto.com/yangrong/1339593" target="_blank" rel="noopener">python socket编程详细介绍</a></li>
</ul>
<h2 id="ipaddress"><a href="#ipaddress" class="headerlink" title="ipaddress"></a>ipaddress</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c11/p04_generate_range_of_ip_addresses_from_cidr_address.html" target="_blank" rel="noopener">通过CIDR地址生成对应的IP地址集</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"></span><br><span class="line">net = ipaddress.ip_network(<span class="string">'123.45.67.64/27'</span>)</span><br><span class="line">print(net)</span><br><span class="line"><span class="comment"># 123.45.67.64/27</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> net:</span><br><span class="line">    print(a)</span><br><span class="line"><span class="comment"># 123.45.67.64</span></span><br><span class="line"><span class="comment"># 123.45.67.65</span></span><br><span class="line"><span class="comment"># 123.45.67.66</span></span><br><span class="line"><span class="comment"># 123.45.67.67</span></span><br><span class="line"><span class="comment"># 123.45.67.68</span></span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>
<h2 id="cgi"><a href="#cgi" class="headerlink" title="cgi"></a>cgi</h2><ul>
<li><a href="https://www.biaodianfu.com/cgi-fastcgi-wsgi.html" target="_blank" rel="noopener">网关协议学习：CGI、FastCGI、WSGI</a></li>
</ul>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="启动与停止线程"><a href="#启动与停止线程" class="headerlink" title="启动与停止线程"></a>启动与停止线程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'T-minus'</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,), daemon=<span class="keyword">True</span>)</span><br><span class="line">t.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'123123'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="判断线程是否已经启动"><a href="#判断线程是否已经启动" class="headerlink" title="判断线程是否已经启动"></a>判断线程是否已经启动</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p02_determining_if_thread_has_started.html" target="_blank" rel="noopener">判断线程是否已经启动</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n, started_evt)</span>:</span></span><br><span class="line">    print(<span class="string">'countdown starting'</span>)</span><br><span class="line">    <span class="comment"># started_evt.set()</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'T-mius'</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">6</span>:</span><br><span class="line">            started_evt.set()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">started_evt = Event()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'launching countdown'</span>)</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>, started_evt))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">started_evt.wait()</span><br><span class="line">print(<span class="string">'countdown is runing'</span>)</span><br></pre></td></tr></table></figure>
<p>当我们需要判断某个线程的状态，进而来进行不同的操作的时候，我们可以使用 <code>Event()</code> 事件来判断，这个对象有一个信号标志，开始为假，如果线程中需要等待一个 <code>event</code> 对象，而这个标志为假的话 ，就会一直等待。直到标志位为真，而标志位的设定，可以通过 <code>set()</code> 方法来设定，这将会唤醒所有等待这个对象的线程。如果遇到的 <code>event</code> 对象的标志位为真的话，会直接忽略，继续其他操作。</p>
<p>书籍原话：</p>
<blockquote>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 <code>threading</code> 库中的 <code>Event</code> 对象。 <code>Event</code> 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Condition</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicTimer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        self._initerval = interval</span><br><span class="line">        self._flag = <span class="number">0</span></span><br><span class="line">        self._cv = Condition()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        t = threading.Thread(target=self.run)</span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            time.sleep(self._initerval)</span><br><span class="line">            <span class="keyword">with</span> self._cv:</span><br><span class="line">                self._flag ^= <span class="number">1</span></span><br><span class="line">                self._cv.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_for_tick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            last_flag = self._flag</span><br><span class="line">            <span class="keyword">while</span> last_flag == self._flag:</span><br><span class="line">                self._cv.wait()</span><br><span class="line"></span><br><span class="line">ptimer = PeriodicTimer(<span class="number">5</span>)</span><br><span class="line">ptimer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(nticks)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> nticks &gt; <span class="number">0</span>:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        print(<span class="string">'T-minus'</span>, nticks)</span><br><span class="line">        nticks -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span><span class="params">(last)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; last:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        print(<span class="string">'counting'</span>, n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threading.Thread(target=countdown, args=(<span class="number">10</span>,)).start()</span><br><span class="line">threading.Thread(target=countup, args=(<span class="number">5</span>,)).start()</span><br></pre></td></tr></table></figure>
<p><code>Condition</code> 是处理多个线程同步的模块。具体要用再查资料去吧。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html" target="_blank" rel="noopener">进程间通信</a></li>
</ul>
<p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code>queue</code> 库中的队列了。创建一个被多个线程共享的 <code>Queue</code> 对象，这些线程通过使用 <code>put()</code> 和 <code>get()</code> 操作来向队列中添加或者删除元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p><code>Queue</code> 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。 当使用队列时，协调生产者和消费者的关闭问题可能会有一些麻烦。一个通用的解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。</p>
<p>一个例子：创建线程安全优先级队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="keyword">while</span> len(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p><code>heapq</code> 是python的堆数据结构模块，这里定义了 <code>Condition</code>  ，在获取或者添加数据的时候，必须要获得锁的权限，才可以执行操作，确保数据的安全。</p>
<p>当我们使用队列进行进程间通信的时候，有时候我们不清楚数据什么时候会接受数据并开始工作，这个时候我们可以使用 <code>Queue</code> 中的 <code>task_done()</code> 和 <code>join()</code>  ，采用一种生产者消费者的模式进行数据的获取，并且这样能清楚的知道数据什么时候获取，什么时候消费，并且什么时候全部处理完毕。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Indicate completion</span></span><br><span class="line">        in_q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for all produced items to be consumed</span></span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure>
<p>如果一个线程需要在一个“消费者”线程处理完特定的数据项时立即得到通知，你可以把要发送的数据和一个 <code>Event</code> 放到一起使用，这样“生产者”就可以通过这个Event对象来监测处理的过程了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Make an (data, event) pair and hand it to the consumer</span></span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((data, evt))</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Wait for the consumer to process the item</span></span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Indicate completion</span></span><br><span class="line">        evt.set()</span><br></pre></td></tr></table></figure>
<p>书本对 <code>Queue</code> 方法的建议：</p>
<blockquote>
<p><code>Queue</code> 对象提供一些在当前上下文很有用的附加特性。比如在创建 Queue 对象时提供可选的 <code>size</code> 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。在通信的线程之间进行“流量控制”是一个看起来容易实现起来困难的问题。如果你发现自己曾经试图通过摆弄队列大小来解决一个问题，这也许就标志着你的程序可能存在脆弱设计或者固有的可伸缩问题。 <code>get()</code> 和 <code>put()</code> 方法都支持非阻塞方式和设定超时，这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况，比如，一个非阻塞的 <code>put()</code> 方法和一个固定大小的队列一起使用，这样当队列已满时就可以执行不同的代码。比如输出一条日志信息并丢弃。</p>
<p>最后，有 <code>q.qsize()</code> ， <code>q.full()</code> ， <code>q.empty()</code> 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 <code>empty()</code> 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。所以，你最好不要在你的代码中使用这些方法。</p>
</blockquote>
<h2 id="Lock-对象"><a href="#Lock-对象" class="headerlink" title="Lock 对象"></a><code>Lock</code> 对象</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p04_locking_critical_sections.html" target="_blank" rel="noopener">给关键部分加锁</a></li>
</ul>
<p>要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 <code>Lock</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedCounter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initial_value = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">             self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">             self._value -= delta</span><br></pre></td></tr></table></figure>
<p><code>Lock</code> 对象和 <code>with</code> 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p05_locking_with_deadlock_avoidance.html" target="_blank" rel="noopener">防止死锁的加锁机制</a></li>
</ul>
<p>演示一个死锁的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _id, balance, lock)</span>:</span></span><br><span class="line">        self.id = _id</span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.lock = lock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        self.balance -= amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        self.balance += amount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(_from, to, amount)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _from.lock.acquire():  <span class="comment"># 锁住自己的账户</span></span><br><span class="line">        _from.withdraw(amount)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># 让交易时间变长，2个交易线程时间上重叠，有足够时间来产生死锁</span></span><br><span class="line">        print(<span class="string">'wait for lock...'</span>)</span><br><span class="line">        <span class="keyword">if</span> to.lock.acquire():  <span class="comment"># 锁住对方的账户</span></span><br><span class="line">            to.deposit(amount)</span><br><span class="line">            to.lock.release()</span><br><span class="line">        _from.lock.release()</span><br><span class="line">    print(<span class="string">'finish...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Account(<span class="string">'a'</span>, <span class="number">1000</span>, threading.Lock())</span><br><span class="line">b = Account(<span class="string">'b'</span>, <span class="number">1000</span>, threading.Lock())</span><br><span class="line">threading.Thread(target=transfer, args=(a, b, <span class="number">100</span>)).start()</span><br><span class="line">threading.Thread(target=transfer, args=(b, a, <span class="number">200</span>)).start()</span><br></pre></td></tr></table></figure>
<p>如果需要解决的话，可以使用 Event() 事件来接连处理两个线程。在两个线程之间加上等待，处理完一个数据之后再将状态置为真。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p06_storing_thread_specific_state.html" target="_blank" rel="noopener">保存线程的状态信息</a></li>
</ul>
<h2 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> AF_INET, SOCK_STREAM, socket</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_client</span><span class="params">(sock, client_addr)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Handle a client connection</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">'Got connection from'</span>, client_addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        msg = sock.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(<span class="string">'Client closed connection'</span>)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(addr)</span>:</span></span><br><span class="line">    pool = ThreadPoolExecutor(<span class="number">128</span>)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        pool.submit(echo_client, client_sock, client_addr)</span><br><span class="line"></span><br><span class="line">echo_server((<span class="string">''</span>,<span class="number">15000</span>))</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>AF_INET</code> 表示采用 IPV4 的协议。</li>
<li><code>SOCK_STREAM</code> 表示使用双向 socket 通信。</li>
</ul>
<p>对于服务端来说，创建 socket ，绑定地址和端口号，设置监听 <code>listen</code> （这个时候就开始接收消息了，参数指的是最大可获取的连接数），之后设置死循环，开始获取客户端的连接 <code>accept()</code> ，返回客户端的 <code>socket</code> 和IP地址，之后就可以进行别的操作了。</p>
<p>在这个线程池中，将线程提交到线程池，使用 <code>submit()</code>  ，这个时候，就会在线程池中之行这个线程，之后可以通过 <code>result()</code>  或者 <code>done()</code>  等方法，得到这个线程的执行状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_client</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Handle a client connection</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sock, client_addr = q.get()</span><br><span class="line">    print(<span class="string">'Got connection from'</span>, client_addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        msg = sock.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(<span class="string">'Client closed connection'</span>)</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(addr, nworkers)</span>:</span></span><br><span class="line">    <span class="comment"># Launch the client workers</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(nworkers):</span><br><span class="line">        t = Thread(target=echo_client, args=(q,))</span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run the server</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        q.put((client_sock, client_addr))</span><br><span class="line"></span><br><span class="line">echo_server((<span class="string">''</span>,<span class="number">15000</span>), <span class="number">128</span>)</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>Queue</code>  模块，也可以实现线程池的操作，在获得线程的时候，就可以将线程放到队列中，之后在需要的地方在取出来操作。</p>
<p>两者相比来说，使用 <code>ThreadPoolExecutor</code> 相对于手动实现的一个好处在于它使得 任务提交者更方便的从被调用函数中获取返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    u = urllib.request.urlopen(url)</span><br><span class="line">    data = u.read()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Submit work to the pool</span></span><br><span class="line">a = pool.submit(fetch_url, <span class="string">'http://www.python.org'</span>)</span><br><span class="line">b = pool.submit(fetch_url, <span class="string">'http://www.pypy.org'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the results back</span></span><br><span class="line">x = a.result()</span><br><span class="line">y = b.result()</span><br></pre></td></tr></table></figure>
<p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，<code>a.result()</code> 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p>
<p>除此之外，还有一个好处就是限制线程的数量，使用线程池的话，在一开始初始化的时候，就可以设定一个线程的最大数量，之后在使用的时候，就不用当心线程数量过多照成的系统问题。</p>
<p>同样的，我们也可以使用限制线程内存的方式，限制开启的线程数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">threading.stack_size(<span class="number">65536</span>)</span><br></pre></td></tr></table></figure>
<h2 id="简单的并行编程"><a href="#简单的并行编程" class="headerlink" title="简单的并行编程"></a>简单的并行编程</h2><p>当我们需要使得 CPU 执行密集型工作的时候，希望利用多核 CPU 同时执行，使得运行速度快一些。</p>
<p><code>concurrent.futures</code> 库提供了一个 <code>ProcessPoolExecutor</code> 类， 可被用来在一个单独的Python解释器中执行计算密集型函数。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p08_perform_simple_parallel_programming.html" target="_blank" rel="noopener">简单的并行编程</a></li>
</ul>
<p>书上的一个例子，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># findrobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_robots</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all of the hosts that access robots.txt in a single log file</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    robots = set()</span><br><span class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> io.TextIOWrapper(f,encoding=<span class="string">'ascii'</span>):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            <span class="keyword">if</span> fields[<span class="number">6</span>] == <span class="string">'/robots.txt'</span>:</span><br><span class="line">                robots.add(fields[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> robots</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all_robots</span><span class="params">(logdir)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all hosts across and entire sequence of files</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    files = glob.glob(logdir+<span class="string">'/*.log.gz'</span>)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    <span class="keyword">for</span> robots <span class="keyword">in</span> map(find_robots, files):</span><br><span class="line">        all_robots.update(robots)</span><br><span class="line">    <span class="keyword">return</span> all_robots</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    robots = find_all_robots(<span class="string">'logs'</span>)</span><br><span class="line">    <span class="keyword">for</span> ipaddr <span class="keyword">in</span> robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用 <code>map</code> 方法，<code>map()</code>函数接收两个参数，一个是函数，一个是序列，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</p>
<blockquote>
<p><code>glob</code> 模块，用它可以查找符合特定规则的文件路径名。</p>
<p>glob.glob 获取指定文件夹下面的指定文件，返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。</p>
</blockquote>
<p>这个代码是一个 <strong>MapReduce</strong> 的设计思路，<strong>MapReduce</strong> 是<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>提出的一个<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">软件架构</a>，用于大规模数据集（大于1<a href="https://zh.wikipedia.org/wiki/Terabyte" target="_blank" rel="noopener">TB</a>）的<a href="https://zh.wikipedia.org/wiki/%E4%B8%A6%E8%A1%8C%E9%81%8B%E7%AE%97" target="_blank" rel="noopener">并行运算</a>。</p>
<p>当前的软件实现是指定一个 <em>Map（映射）</em> 函数，用来把一组键值对映射成一组新的键值对，指定并发的 <em>Reduce（归纳）</em> 函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">MapReduce</a></li>
<li><a href="https://www.zhihu.com/question/23345991" target="_blank" rel="noopener">关于MapReduce的理解？</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317852443934a86aa5bb5ea47fbbd5f35282b331335000" target="_blank" rel="noopener">map/reduce</a></li>
</ul>
<p>函数 <code>find_robots()</code> 在一个文件名集合上做map操作，并将结果汇总为一个单独的结果， 也就是 <code>find_all_robots()</code> 函数中的 <code>all_robots</code> 集合。</p>
<p>当我们需要采用并发式编程的时候，我们就要采用 <code>concurrent.futures</code> ，把 <code>map</code> 操作替换掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># findrobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_robots</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all of the hosts that access robots.txt in a single log file</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    robots = set()</span><br><span class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> io.TextIOWrapper(f,encoding=<span class="string">'ascii'</span>):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            <span class="keyword">if</span> fields[<span class="number">6</span>] == <span class="string">'/robots.txt'</span>:</span><br><span class="line">                robots.add(fields[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> robots</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all_robots</span><span class="params">(logdir)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all hosts across and entire sequence of files</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    files = glob.glob(logdir+<span class="string">'/*.log.gz'</span>)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    <span class="keyword">with</span> futures.ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> robots <span class="keyword">in</span> pool.map(find_robots, files):</span><br><span class="line">            all_robots.update(robots)</span><br><span class="line">    <span class="keyword">return</span> all_robots</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    robots = find_all_robots(<span class="string">'logs'</span>)</span><br><span class="line">    <span class="keyword">for</span> ipaddr <span class="keyword">in</span> robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure>
<p>而实际的优化效果会依据不同的CPU而决定的。</p>
<p>ProcessPoolExecutor<code>的典型用法是和</code>with` 一起使用的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    ...</span><br><span class="line">    do work <span class="keyword">in</span> parallel using pool</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>书本原画介绍：</p>
<p>其原理是，一个 <code>ProcessPoolExecutor</code> 创建N个独立的Python解释器， N是系统上面可用CPU的个数。你可以通过提供可选参数给 <code>ProcessPoolExecutor(N)</code> 来修改 处理器数量。这个处理池会一直运行到with块中最后一个语句执行完成， 然后处理池被关闭。不过，程序会一直等待直到所有提交的工作被处理完成。</p>
<p>被提交到池中的工作必须被定义为一个函数。有两种方法去提交。 如果你想让一个列表推导或一个 <code>map()</code> 操作并行执行的话，可使用 <code>pool.map()</code> ，如果需要单独提交单个任务的时候，可以使用 <code>pool.submit()</code> 来提交。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A function that performs a lot of work</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(x)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nonparallel code</span></span><br><span class="line">results = map(work, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parallel implementation</span></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    results = pool.map(work, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Some function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(x)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># Example of submitting work to the pool</span></span><br><span class="line">    future_result = pool.submit(work, arg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Obtaining the result (blocks until done)</span></span><br><span class="line">    r = future_result.result()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如果你手动提交一个任务，结果是一个 <code>Future</code> 实例。 要获取最终结果，你需要调用它的 <code>result()</code> 方法。 它会阻塞进程直到结果被返回来。如果不想阻塞的话，可以使用一个回调函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">when_done</span><span class="params">(r)</span>:</span></span><br><span class="line">    print(<span class="string">'Got:'</span>, r.result())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">     future_result = pool.submit(work, arg)</span><br><span class="line">     future_result.add_done_callback(when_done)</span><br></pre></td></tr></table></figure>
<p>书本上对使用这个的建议：（尽量保持需要并发执行的函数的简单性）</p>
<p>回调函数接受一个 <code>Future</code> 实例，被用来获取最终的结果（比如通过调用它的 <code>result()</code> 方法）。 尽管处理池很容易使用，在设计大程序的时候还是有很多需要注意的地方，如下几点：</p>
<ul>
<li>这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</li>
<li>被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不支持。</li>
<li>函数参数和返回值必须兼容pickle，因为要使用到进程间的通信，所有解释器之间的交换数据必须被序列化</li>
<li>被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，</li>
</ul>
<p>一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁——函数不要去修改环境。</p>
<ul>
<li>在Unix上进程池通过调用 <code>fork()</code> 系统调用被创建，</li>
</ul>
<p>它会克隆Python解释器，包括fork时的所有程序状态。 而在Windows上，克隆解释器时不会克隆状态。 实际的fork操作会在第一次调用 <code>pool.map()</code> 或 <code>pool.submit()</code> 后发生。</p>
<ul>
<li>当你混合使用进程池和多线程的时候要特别小心。</li>
</ul>
<p>你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的main线程中创建进程池）。</p>
<h2 id="Python的全局锁问题"><a href="#Python的全局锁问题" class="headerlink" title="Python的全局锁问题"></a>Python的全局锁问题</h2><p>尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。 GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p09_dealing_with_gil_stop_worring_about_it.html" target="_blank" rel="noopener">Python的全局锁问题</a></li>
</ul>
<p>在我们尝试使用多线程来提高程序的运行速度的时候，我们应该更加注重代码算法上的提高，这会比单纯的时候多线程会快上很多。多线程的意义更多的是在于网络编程和图形化编程。</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，不能是lambda、闭包可调用实例等， 并且函数参数和返回值必须要兼容pickle。 同样，要执行的任务量必须足够大以弥补额外的通信开销。</p>
<h2 id="定义一个Actor任务"><a href="#定义一个Actor任务" class="headerlink" title="定义一个Actor任务"></a>定义一个Actor任务</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p10_defining_an_actor_task.html" target="_blank" rel="noopener">定义一个Actor任务</a></li>
</ul>
<p>一种简单的进行并发和分布式计算的解决方案，只需要一个队列和一个线程就能实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sentinel used for shutdown</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActorExit</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._mailbox = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Send a message to the actor</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._mailbox.put(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Receive an incoming message</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        msg = self._mailbox.get()</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> ActorExit:</span><br><span class="line">            <span class="keyword">raise</span> ActorExit()</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Close the actor, thus shutting it down</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.send(ActorExit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Start concurrent execution</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._terminated = Event()</span><br><span class="line">        t = Thread(target=self._bootstrap)</span><br><span class="line"></span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run()</span><br><span class="line">        <span class="keyword">except</span> ActorExit:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._terminated.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._terminated.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Run method to be implemented by the user</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample ActorTask</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintActor</span><span class="params">(Actor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            print(<span class="string">'Got:'</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample use</span></span><br><span class="line">p = PrintActor()</span><br><span class="line">p.start()</span><br><span class="line">p.send(<span class="string">'Hello'</span>)</span><br><span class="line">p.send(<span class="string">'World'</span>)</span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>
<p>这个例子中，你使用actor实例的 <code>send()</code> 方法发送消息给它们。 其机制是，这个方法会将消息放入一个队里中， 然后将其转交给处理被接受消息的一个内部线程。 <code>close()</code> 方法通过在队列中放入一个特殊的哨兵值（ActorExit）来关闭这个actor。 用户可以通过继承Actor并定义实现自己处理逻辑run()方法来定义新的actor。 <code>ActorExit</code> 异常的使用就是用户自定义代码可以在需要的时候来捕获终止请求 （异常被get()方法抛出并传播出去）。</p>
<p>这个模式可以这样理解，其中，有个重点，<code>Queue()</code> 队列的 <code>get()</code> 方法是阻塞的，也就是说，在没有获得数据的时候，线程会阻塞在其中等待，直到有数据传递进来后，才开始获得数据，进行接下来的操作。</p>
<p>也就是因为这个特性，才可以在开启新的线程后直接使用死循环等待。</p>
<p>在开始创建这个 <code>Actor</code> 对象并且运行 <code>start</code> 的时候，开启新的线程和新建 <code>Event</code> 事件，之后运行 <code>run</code> 方法，死循环，等待队列中获取数据。</p>
<p>当一条数据传递过来之后（ <code>send</code> ），数据添加到队列中，<code>get</code> 方法获得数据，执行 <code>run</code> 方法的操作。</p>
<p>当执行 <code>close</code> 方法的时候，将 <code>ActorExit</code> 异常丢进队列中，<code>get</code>  方法获得异常的数据，抛出异常，获取异常，跳出循环，将 <code>Event</code> 线程的设置标志。</p>
<p>其中的 <code>Event</code> 事件，实现对线程的管理。可以实现，在把异常放进队列中的之前，对主线程进行阻塞，直到有异常状态放到队列中。</p>
<h2 id="实现消息发布-订阅模型"><a href="#实现消息发布-订阅模型" class="headerlink" title="实现消息发布/订阅模型"></a>实现消息发布/订阅模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exchange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._subscribers = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        self._subscribers.add(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        self._subscribers.remove(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        print(len(self._subscribers))</span><br><span class="line">        print(list(self._subscribers))</span><br><span class="line">        <span class="keyword">for</span> subscriber <span class="keyword">in</span> self._subscribers:</span><br><span class="line">            subscriber.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of all created exchanges</span></span><br><span class="line">_exchanges = defaultdict(Exchange)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Return the Exchange instance associated with a given name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_exchange</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _exchanges[name]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        print(msg)</span><br><span class="line"></span><br><span class="line">task_a = Task()</span><br><span class="line">task_b = Task()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of getting an exchange</span></span><br><span class="line">exc = get_exchange(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Examples of subscribing tasks to it</span></span><br><span class="line">exc.attach(task_a)</span><br><span class="line">exc.attach(task_b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of sending messages</span></span><br><span class="line">exc.send(<span class="string">'msg1'</span>)</span><br><span class="line">exc.send(<span class="string">'msg2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of unsubscribing</span></span><br><span class="line">exc.detach(task_a)</span><br><span class="line">exc.detach(task_b)</span><br></pre></td></tr></table></figure>
<p>设计模式中的一种，<code>Exchange</code> 类相当于一个交换机的模式，其中有订阅，发送消息等功能，通过 <code>get_exchange</code> 获得该对象，所实现的效果就是，对于需要发送的消息任务来说，可以一次性将消息发送给多个关联任务。</p>
<p>在使用过程中，获得对象，在对象中添加多个任务，发送消息的时候，就可以将消息发送给所有绑定的任务中。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Jaelyn
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://jaelyn.coding.me/2018/06/10/python-cookbook-04/" title="Python Cookbook 笔记 04">http://jaelyn.coding.me/2018/06/10/python-cookbook-04/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python3/" rel="tag"><i class="fa fa-tag"></i> python3</a>
          
            <a href="/tags/Cookbook/" rel="tag"><i class="fa fa-tag"></i> Cookbook</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/05/mac-pycharm-quick-click/" rel="next" title="Mac 下的 PyCharm 快捷键">
                <i class="fa fa-chevron-left"></i> Mac 下的 PyCharm 快捷键
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/20/python-cookbook-05/" rel="prev" title="Python Cookbook 笔记 05">
                Python Cookbook 笔记 05 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Jaelyn" />
            
              <p class="site-author-name" itemprop="name">Jaelyn</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Jaelyn-Lim" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/u/2660619527" target="_blank" title="微博">
                    
                      <i class="fa fa-fw fa-globe"></i>微博</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#元编程"><span class="nav-number">1.</span> <span class="nav-text">元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#wraps"><span class="nav-number">1.1.</span> <span class="nav-text">wraps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器（修饰器）"><span class="nav-number">1.2.</span> <span class="nav-text">装饰器（修饰器）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义一个带参数的装饰器"><span class="nav-number">1.3.</span> <span class="nav-text">定义一个带参数的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可自定义属性的装饰器"><span class="nav-number">1.4.</span> <span class="nav-text">可自定义属性的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带可选参数的装饰器"><span class="nav-number">1.5.</span> <span class="nav-text">带可选参数的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用装饰器强制函数上的类型检查"><span class="nav-number">1.6.</span> <span class="nav-text">利用装饰器强制函数上的类型检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用元类控制实例的创建"><span class="nav-number">1.7.</span> <span class="nav-text">使用元类控制实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义有可选参数的元类"><span class="nav-number">1.8.</span> <span class="nav-text">定义有可选参数的元类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inspect"><span class="nav-number">1.9.</span> <span class="nav-text">inspect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#types-new-class"><span class="nav-number">1.10.</span> <span class="nav-text">types.new_class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免重复的属性方法"><span class="nav-number">1.11.</span> <span class="nav-text">避免重复的属性方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ast"><span class="nav-number">1.12.</span> <span class="nav-text">ast</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块与包"><span class="nav-number">2.</span> <span class="nav-text">模块与包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#all"><span class="nav-number">2.1.</span> <span class="nav-text">__all__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将模块分割成多个文件"><span class="nav-number">2.2.</span> <span class="nav-text">将模块分割成多个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用命名空间导入目录分散的代码"><span class="nav-number">2.3.</span> <span class="nav-text">利用命名空间导入目录分散的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main"><span class="nav-number">2.4.</span> <span class="nav-text">__main__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#importlib-import-module"><span class="nav-number">2.5.</span> <span class="nav-text">importlib.import_module</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装私有的包"><span class="nav-number">2.6.</span> <span class="nav-text">安装私有的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pyvenv"><span class="nav-number">2.7.</span> <span class="nav-text">pyvenv</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络与Web编程"><span class="nav-number">3.</span> <span class="nav-text">网络与Web编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#urllib-request"><span class="nav-number">3.1.</span> <span class="nav-text">urllib.request</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络与web"><span class="nav-number">4.</span> <span class="nav-text">网络与web</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建TCP服务器"><span class="nav-number">4.1.</span> <span class="nav-text">创建TCP服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipaddress"><span class="nav-number">4.2.</span> <span class="nav-text">ipaddress</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgi"><span class="nav-number">4.3.</span> <span class="nav-text">cgi</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发编程"><span class="nav-number">5.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#启动与停止线程"><span class="nav-number">5.1.</span> <span class="nav-text">启动与停止线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断线程是否已经启动"><span class="nav-number">5.2.</span> <span class="nav-text">判断线程是否已经启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">5.3.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock-对象"><span class="nav-number">5.4.</span> <span class="nav-text">Lock 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个线程池"><span class="nav-number">5.5.</span> <span class="nav-text">创建一个线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的并行编程"><span class="nav-number">5.6.</span> <span class="nav-text">简单的并行编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python的全局锁问题"><span class="nav-number">5.7.</span> <span class="nav-text">Python的全局锁问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义一个Actor任务"><span class="nav-number">5.8.</span> <span class="nav-text">定义一个Actor任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现消息发布-订阅模型"><span class="nav-number">5.9.</span> <span class="nav-text">实现消息发布/订阅模型</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jaelyn</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">85.3k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500569228");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=64866827";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  


  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "500569228");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>

  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":100,"height":200},"mobile":{"show":false},"log":false});</script></body>
</html>
