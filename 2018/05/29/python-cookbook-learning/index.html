<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  
<script type="text/javascript">
    var _speedMark = new Date();
</script>

<script type="text/javascript" src="http://tajs.qq.com/stats?sId=64866827" charset="UTF-8"></script>


<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />










  <meta name="baidu-site-verification" content="HRlPcTjXKc" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/uploads/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/uploads/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/uploads/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/uploads/safari-pinned-tab.svg?v=5.1.3" color="#222">


  <link rel="manifest" href="/images/uploads/manifest.json">


  <meta name="msapplication-config" content="/images/uploads/browserconfig.xml" />



  <meta name="keywords" content="python CookBook, python, python3" />










<meta name="description" content="《Python CookBook 3》  这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。">
<meta name="keywords" content="python CookBook, python, python3">
<meta property="og:type" content="article">
<meta property="og:title" content="Python Cookbook 笔记">
<meta property="og:url" content="http://jaelyn.coding.me/2018/05/29/python-cookbook-learning/index.html">
<meta property="og:site_name" content="Jaelyn&#39;s Blog">
<meta property="og:description" content="《Python CookBook 3》  这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-22T10:17:21.346Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python Cookbook 笔记">
<meta name="twitter:description" content="《Python CookBook 3》  这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'S2RJTOM4KM',
      apiKey: '46aa43b4dc81f6d01e063ef5e5dba1a7',
      indexName: 'blog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jaelyn.coding.me/2018/05/29/python-cookbook-learning/"/>





  <title>Python Cookbook 笔记 | Jaelyn's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jaelyn's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">jaelyn-lim</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jaelyn.coding.me/2018/05/29/python-cookbook-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaelyn">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jaelyn's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Python Cookbook 笔记</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T17:42:42+08:00">
                2018-05-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2018-07-22T18:17:21+08:00">
                2018-07-22
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读次数
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  46,377
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  201
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html" target="_blank" rel="noopener">《Python CookBook 3》</a></li>
</ul>
<p>这个文章是在我学习这本书过程的笔记（复制粘贴），主要用于自己方便查看。还有记录了我的觉得比较有用（没学过）的操作。<br><a id="more"></a></p>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="星号（-）表达式"><a href="#星号（-）表达式" class="headerlink" title="星号（*）表达式"></a>星号（*）表达式</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p02_unpack_elements_from_iterables.html" target="_blank" rel="noopener">解压可迭代对象赋值给多个变量</a></li>
</ul>
<p>可以使用 * （星号表达式）来匹配不确定数量的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_first_last</span><span class="params">(grades)</span>:</span></span><br><span class="line">    first, *middle, last = grades</span><br><span class="line">    print(middle) <span class="comment"># 输出： [3, 4, 5]</span></span><br><span class="line">    <span class="keyword">return</span> middle</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    drop_first_last([<span class="number">12</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>带有星号的变量永远都是列表类型</strong>，包括长度是0的空列表，所以用到该变量的代码就不需要做多余的类型检查去确认它是否是列表类型。</p>
</blockquote>
<p>扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 而不是通过一些比较复杂的手段去获取这些关联的元素值。</p>
<blockquote>
<p>星号表达式能做很多事情，包括对字符串的处理，对可变长数组，元组的处理。</p>
</blockquote>
<h2 id="xrange"><a href="#xrange" class="headerlink" title="xrange"></a>xrange</h2><p>在Python 3中，range()与xrange()合并为range( )。</p>
<p>如果直接使用 <code>range</code> ，会直接占用内存的空间，例如如果要加载一个很大的文件，就有可能会照成内存的爆满。这时候可以使用 <code>xrange</code> 在代替，这个返回的是一个生成器，而不是数列，每次只会返回其中的一个值。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><ul>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/index.html" target="_blank" rel="noopener">Python yield 使用浅析</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> isgeneratorfunction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(max)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    print(<span class="string">"++++++++++"</span>)</span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        print(<span class="string">"12312312---"</span>+str(b))</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        n = n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(isgeneratorfunction(fab))</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> fab(<span class="number">5</span>):</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">++++++++++</span><br><span class="line">1</span><br><span class="line">12312312---1</span><br><span class="line">1</span><br><span class="line">12312312---1</span><br><span class="line">2</span><br><span class="line">12312312---2</span><br><span class="line">3</span><br><span class="line">12312312---3</span><br><span class="line">5</span><br><span class="line">12312312---5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个带有 yield 的函数就是一个 generator，它和普通函数不同，生成一个 generator 看起来像函数调用，但不会执行任何函数代码，直到对其调用 next()（在 for 循环中会自动调用 next()）才开始执行。虽然执行流程仍按函数的流程执行，但每执行到一个 yield 语句就会中断，并返回一个迭代值，下次执行时从 yield 的下一个语句继续执行。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。</p>
</blockquote>
<p>其中，可以使用 <code>isgeneratorfunction</code> 来判断函数是否是一个特殊的 <code>generator</code> 函数。</p>
<p>其中 <code>yield</code> 的例子来源于文件读取。如果直接对文件对象调用 read() 方法，会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(fpath)</span>:</span></span><br><span class="line">   BLOCK_SIZE = <span class="number">1024</span></span><br><span class="line">   <span class="keyword">with</span> open(fpath, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">       <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">           block = f.read(BLOCK_SIZE)</span><br><span class="line">           <span class="keyword">if</span> block:</span><br><span class="line">               <span class="keyword">yield</span> block</span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h2 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p03_keep_last_n_items.html" target="_blank" rel="noopener">保留最后 N 个元素</a>  </li>
</ul>
<blockquote>
<p>使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">lines = deque(maxlen=<span class="number">3</span>)</span><br><span class="line">    lines.append(<span class="string">"1"</span>)</span><br><span class="line">    lines.append(<span class="string">"2"</span>)</span><br><span class="line">    lines.append(<span class="string">"3"</span>)</span><br><span class="line">    lines.append(<span class="string">"4"</span>)</span><br><span class="line">    lines.append(<span class="string">"5"</span>)</span><br><span class="line">    print(lines)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： deque(['3', '4', '5'], maxlen=3)</span></span><br></pre></td></tr></table></figure>
<p>还可以在队列的两端插入和弹出元素，（左边插入：<code>q.appendleft</code>；左边弹出：<code>q.popleft</code>）</p>
<blockquote>
<p>在队列两端插入或删除元素时间复杂度都是 O(1) ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 O(N) 。</p>
</blockquote>
<h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p04_find_largest_or_smallest_n_items.html" target="_blank" rel="noopener">查找最大或最小的 N 个元素</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">43</span>,<span class="number">523</span>,<span class="number">423</span>,<span class="number">423</span>,<span class="number">4</span>,<span class="number">234</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">53</span>,<span class="number">5654</span>,<span class="number">6</span>,<span class="number">4356</span>,<span class="number">12</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums))</span><br><span class="line">print(heapq.nsmallest(<span class="number">2</span>, nums))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [5654, 4356, 523]</span></span><br><span class="line"><span class="comment"># [1, 1]</span></span><br></pre></td></tr></table></figure>
<p>还可以接受一个关键字参数，来进行更高级的对比：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">print(cheap)</span><br><span class="line">print(expensive)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;]</span><br><span class="line">[&#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;]</span><br></pre></td></tr></table></figure></p>
<p>堆数据结构最重要的特征是 <code>heap[0]</code> 永远是最小的元素。并且剩余的元素可以很容易的通过调用 <code>heapq.heappop()</code> 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]</span><br><span class="line">&gt;&gt;&gt; import heapq</span><br><span class="line">&gt;&gt;&gt; heap = list(nums)</span><br><span class="line">&gt;&gt;&gt; heapq.heapify(heap)</span><br><span class="line">&gt;&gt;&gt; heap</span><br><span class="line">[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果只是获取一个最大值（最小值），使用 <code>max()</code>（<code>min()</code>）函数会快一些。</p>
</blockquote>
<h2 id="collections-defaultdict"><a href="#collections-defaultdict" class="headerlink" title="collections.defaultdict"></a>collections.defaultdict</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p06_map_keys_to_multiple_values_in_dict.html" target="_blank" rel="noopener">字典中的键映射多个值</a></li>
</ul>
<p><code>defaultdict</code> 的一个特征是它会自动初始化每个 key 刚开始对应的值，所以你只需要关注添加元素操作了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(list)</span><br><span class="line">d[<span class="string">'a'</span>].append(<span class="number">1</span>)</span><br><span class="line">d[<span class="string">'a'</span>].append(<span class="number">2</span>)</span><br><span class="line">d[<span class="string">'b'</span>].append(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： defaultdict(&lt;class 'list'&gt;, &#123;'a': [1, 2], 'b': [4]&#125;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(set)</span><br><span class="line">d[<span class="string">'a'</span>].add(<span class="number">1</span>)</span><br><span class="line">d[<span class="string">'a'</span>].add(<span class="number">2</span>)</span><br><span class="line">d[<span class="string">'b'</span>].add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出： defaultdict(&lt;class 'set'&gt;, &#123;'a': &#123;1, 2&#125;, 'b': &#123;4&#125;&#125;)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>defaultdict</code> 会自动为将要访问的键（就算目前字典中并不存在这样的键）创建映射实体。</p>
</blockquote>
<h2 id="collections-OrderedDict"><a href="#collections-OrderedDict" class="headerlink" title="collections.OrderedDict"></a>collections.OrderedDict</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p07_keep_dict_in_order.html" target="_blank" rel="noopener">字典排序</a></li>
</ul>
<p>创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">'foo'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'bar'</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">'spam'</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">'grok'</span>] = <span class="number">4</span></span><br><span class="line">d[<span class="string">'foo'</span>] = <span class="number">12</span></span><br><span class="line"><span class="comment"># Outputs "foo 1", "bar 2", "spam 3", "grok 4"</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    print(key, d[key])</span><br><span class="line">j = json.dumps(d)</span><br><span class="line">print(j)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo 12</span><br><span class="line">bar 2</span><br><span class="line">spam 3</span><br><span class="line">grok 4</span><br><span class="line">&#123;&quot;foo&quot;: 12, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4&#125;</span><br></pre></td></tr></table></figure>
<p><code>OrderedDict</code> 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。</p>
<blockquote>
<p>需要注意的是，一个 <code>OrderedDict</code> 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。</p>
</blockquote>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p08_calculating_with_dict.html" target="_blank" rel="noopener">字典的运算</a></li>
</ul>
<p>对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line">    <span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line">    <span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line">    <span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line">    <span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">min_price = min(zip(prices.values(), prices.keys()))</span><br><span class="line">print(min_price)</span><br><span class="line">max_price = max(zip(prices.values(), prices.keys()))</span><br><span class="line">print(max_price)</span><br><span class="line"></span><br><span class="line">prices_sort = sorted(zip(prices.values(), prices.keys()))</span><br><span class="line">print(prices_sort)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(10.75, &apos;FB&apos;)</span><br><span class="line">(612.78, &apos;AAPL&apos;)</span><br><span class="line">[(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;), (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;), (612.78, &apos;AAPL&apos;)]</span><br></pre></td></tr></table></figure>
<p>在使用<code>zip()</code>的时候，在使用<code>zip()</code>给一个变量赋值的时候，就不能再次使用该变量做其他操作，例如：<code>a = zip(prices.values(), prices.keys())</code>，之后调用<code>max(a)</code>，后面如果再次调用<code>min(a)</code>的话就会报错。<code># ValueError: max() arg is an empty sequence</code></p>
<h2 id="keys-and-values"><a href="#keys-and-values" class="headerlink" title="keys and values"></a>keys and values</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p09_find_commonalities_in_dicts.html" target="_blank" rel="noopener">查找两字典的相同点</a></li>
</ul>
<p>一个字典就是一个键集合与值集合的映射关系。 字典的 <code>keys()</code> 方法返回一个展现键集合的键视图对象。 键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。 所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个 <code>set</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">    <span class="string">'x'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'y'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'z'</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = &#123;</span><br><span class="line">    <span class="string">'w'</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">'x'</span>: <span class="number">11</span>,</span><br><span class="line">    <span class="string">'y'</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(a.keys() &amp; b.keys())</span><br><span class="line"><span class="comment"># &#123;'x', 'y'&#125; 在a字典和b字典中相同的key</span></span><br><span class="line">print(a.keys() - b.keys())</span><br><span class="line"><span class="comment"># &#123;'z'&#125; 在a字典中有的在b字典中没有的key</span></span><br><span class="line">print(a.items() &amp; b.items())</span><br><span class="line"><span class="comment"># &#123;('y', 2)&#125; 在a字典和在b字典中相同的健值对</span></span><br><span class="line">c = &#123;key: a[key] <span class="keyword">for</span> key <span class="keyword">in</span> a.keys() - &#123;<span class="string">'z'</span>&#125;&#125;</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># &#123;'x': 1, 'y': 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>字典的 items() 方法返回一个包含 (键，值) 对的元素视图对象。 这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。</p>
<blockquote>
<p>尽管字典的 values() 方法也是类似，但是它并不支持这里介绍的集合操作。</p>
</blockquote>
<h2 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p12_determine_most_freqently_items_in_seq.html" target="_blank" rel="noopener">序列中出现次数最多的元素</a></li>
</ul>
<p><code>Counter</code> 对象可以接受任意的由可哈希（<code>hashable</code>）元素构成的序列对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">words = [</span><br><span class="line">    <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>,</span><br><span class="line">    <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'not'</span>, <span class="string">'around'</span>, <span class="string">'the'</span>,</span><br><span class="line">    <span class="string">'eyes'</span>, <span class="string">"don't"</span>, <span class="string">'look'</span>, <span class="string">'around'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'look'</span>, <span class="string">'into'</span>,</span><br><span class="line">    <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">"you're"</span>, <span class="string">'under'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">word_counts = Counter(words)</span><br><span class="line"><span class="comment"># 计算列表中出现频率最多的三个单词</span></span><br><span class="line">top_three = word_counts.most_common(<span class="number">3</span>)</span><br><span class="line">print(top_three)</span><br><span class="line"><span class="comment"># [('eyes', 8), ('the', 5), ('look', 4)]</span></span><br></pre></td></tr></table></figure>
<p>同样的，也可增加新的列表来跟新新的列表中的元素的个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">morewords = [<span class="string">'why'</span>,<span class="string">'are'</span>,<span class="string">'you'</span>,<span class="string">'not'</span>,<span class="string">'looking'</span>,<span class="string">'in'</span>,<span class="string">'my'</span>,<span class="string">'eyes'</span>]</span><br><span class="line">word_counts.update(morewords)</span><br><span class="line">print(word_counts.most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>并且，<code>Counter</code>这个类也可以和数学运算符操作相结合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = Counter(words)</span><br><span class="line">b = Counter(morewords)</span><br><span class="line"></span><br><span class="line">c = a + b</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># Counter(&#123;'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2, 'around': 2, "don't": 1, "you're": 1, 'under': 1, 'why': 1, 'are': 1, 'you': 1, 'looking': 1, 'in': 1&#125;)</span></span><br><span class="line">c = a - b</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># Counter(&#123;'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2, "don't": 1, "you're": 1, 'under': 1&#125;)</span></span><br></pre></td></tr></table></figure>
<h2 id="operator-itemgetter"><a href="#operator-itemgetter" class="headerlink" title="operator.itemgetter"></a>operator.itemgetter</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p13_sort_list_of_dicts_by_key.html" target="_blank" rel="noopener">通过某个关键字排序一个字典列表</a></li>
</ul>
<p>可以利用<code>itemgetter</code>的模块对列表中以某个字段来排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line">rows = [</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'Brian'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'David'</span>, <span class="string">'lname'</span>: <span class="string">'Beazley'</span>, <span class="string">'uid'</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">rows_by_fname = sorted(rows, key=itemgetter(<span class="string">'fname'</span>))</span><br><span class="line">rows_by_uid = sorted(rows, key=itemgetter(<span class="string">'uid'</span>))</span><br><span class="line">print(rows_by_fname)</span><br><span class="line"><span class="comment"># [&#123;'fname': 'Big', 'lname': 'Jones', 'uid': 1004&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'Brian', 'lname': 'Jones', 'uid': 1003&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'David', 'lname': 'Beazley', 'uid': 1002&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'John', 'lname': 'Cleese', 'uid': 1001&#125;]</span></span><br><span class="line">print(rows_by_uid)</span><br><span class="line"><span class="comment"># [&#123;'fname': 'John', 'lname': 'Cleese', 'uid': 1001&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'David', 'lname': 'Beazley', 'uid': 1002&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'Brian', 'lname': 'Jones', 'uid': 1003&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'Big', 'lname': 'Jones', 'uid': 1004&#125;]</span></span><br></pre></td></tr></table></figure>
<p>同样，也能存在多个<code>key</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rows_by_lfname = sorted(rows, key=itemgetter(<span class="string">'lname'</span>,<span class="string">'fname'</span>))</span><br><span class="line">print(rows_by_lfname)</span><br><span class="line"><span class="comment"># [&#123;'fname': 'David', 'lname': 'Beazley', 'uid': 1002&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'John', 'lname': 'Cleese', 'uid': 1001&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'Big', 'lname': 'Jones', 'uid': 1004&#125;,</span></span><br><span class="line"><span class="comment"># &#123;'fname': 'Brian', 'lname': 'Jones', 'uid': 1003&#125;]</span></span><br></pre></td></tr></table></figure>
<p><code>rows</code> 被传递给接受一个关键字参数的 <code>sorted()</code> 内置函数。 这个参数是 <code>callable</code> 类型，并且从 <code>rows</code> 中接受一个单一元素，然后返回被用来排序的值。 <code>itemgetter()</code> 函数就是负责创建这个 <code>callable</code> 对象的。</p>
<p><code>operator.itemgetter()</code> 函数有一个被 <code>rows</code> 中的记录用来查找值的索引参数。可以是一个字典键名称， 一个整形值或者任何能够传入一个对象的 <code>__getitem__()</code> 方法的值。 如果你传入多个索引参数给 <code>itemgetter()</code> ，它生成的 <code>callable</code> 对象会返回一个包含所有元素值的元组， 并且 <code>sorted()</code> 函数会根据这个元组中元素顺序去排序。 但你想要同时在几个字段上面进行排序（比如通过姓和名来排序，也就是例子中的那样）的时候这种方法是很有用的。</p>
<blockquote>
<p>该模块也同样适用于 min() 和 max() 等函数。<br><code>min(rows, key=itemgetter(&#39;uid&#39;))</code> 或者 <code>max(rows, key=itemgetter(&#39;uid&#39;))</code></p>
</blockquote>
<h2 id="operator-attrgetter"><a href="#operator-attrgetter" class="headerlink" title="operator.attrgetter"></a>operator.attrgetter</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p14_sort_objects_without_compare_support.html" target="_blank" rel="noopener">排序不支持原生比较的对象</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, user_id)</span>:</span></span><br><span class="line">        self.user_id = user_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'User(&#123;&#125;)'</span>.format(self.user_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">users = [User(<span class="number">34</span>),  User(<span class="number">23</span>), User(<span class="number">12</span>)]</span><br><span class="line">print(users)</span><br><span class="line"><span class="comment"># [User(34), User(23), User(12)]</span></span><br><span class="line">print(sorted(users, key=<span class="keyword">lambda</span> u: u.user_id))</span><br><span class="line"><span class="comment"># [User(12), User(23), User(34)]</span></span><br><span class="line">s = sorted(users, key=attrgetter(<span class="string">'user_id'</span>))</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># [User(12), User(23), User(34)]</span></span><br></pre></td></tr></table></figure>
<p>可以直接使用<code>lambda</code>表达式的计算来代替<code>attrgetter</code>，但是如果更加在意速度的话，<code>attrgetter()</code> 函数通常会运行的快点，并且还能同时允许多个字段进行比较。 这个跟 <code>operator.itemgetter()</code> 函数作用于字典类型很类似。也同样支持<code>min</code>和<code>max</code>的操作。</p>
<h2 id="itertools-groupby"><a href="#itertools-groupby" class="headerlink" title="itertools.groupby"></a>itertools.groupby</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p15_group_records_based_on_field.html" target="_blank" rel="noopener">通过某个字段将记录分组</a></li>
</ul>
<p><code>groupby()</code> 函数扫描整个序列并且查找连续相同值（或者根据指定 key 函数返回值相同）的元素序列。 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。</p>
<blockquote>
<p>一个非常重要的准备步骤是要根据指定的字段将数据排序。 因为 groupby() 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line">rows = [</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5412 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5148 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5800 E 58TH'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'2122 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/03/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5645 N RAVENSWOOD'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'1060 W ADDISON'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'4801 N BROADWAY'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'1039 W GRANVILLE'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line">]</span><br><span class="line">rows.sort(key=itemgetter(<span class="string">'date'</span>))</span><br><span class="line">a = groupby(rows, key=itemgetter(<span class="string">'date'</span>))</span><br><span class="line"><span class="keyword">for</span> date, items <span class="keyword">in</span> a:</span><br><span class="line">    print(date)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        print(<span class="string">' '</span>, item)</span><br></pre></td></tr></table></figure>
<p>如果需要按照分组来访问，可以使用<code>defaultdict()</code>来构建多值字典。</p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p16_filter_sequence_elements.html" target="_blank" rel="noopener">过滤序列元素</a></li>
</ul>
<p>一般来说，如果我们需要对一个列表遍历，取出其中的某些特定的元素，我们可以使用列表推导。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>, <span class="number">-7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">-1</span>]</span><br><span class="line">m = [i <span class="keyword">for</span> i <span class="keyword">in</span> mylist <span class="keyword">if</span> i &gt; <span class="number">0</span>]</span><br><span class="line">print(m)</span><br><span class="line"><span class="comment"># [1, 4, 10, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>使用列表推导的一个潜在缺陷就是如果输入非常大的时候会产生一个非常大的结果集，占用大量内存。 如果对内存比较敏感，可以使用生成器表达式迭代产生过滤的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pos = (n <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>)</span><br><span class="line">print(pos)</span><br><span class="line"><span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x101fa69e8&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pos:</span><br><span class="line">    print(i, end=<span class="string">' '</span>)</span><br><span class="line"><span class="comment"># 1 4 10 2 3</span></span><br></pre></td></tr></table></figure>
<p>如果过滤规则比较复杂，不能简单的在列表推导或者生成器表达式中表达出来。 比如，假设过滤的时候需要处理一些异常或者其他复杂情况。这时候可以将过滤代码放到一个函数中， 然后使用内建的 <code>filter()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">values = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'-3'</span>, <span class="string">'-'</span>, <span class="string">'4'</span>, <span class="string">'N/A'</span>, <span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_int</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = int(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ivals = list(filter(is_int, values))</span><br><span class="line">print(ivals)</span><br><span class="line"><span class="comment"># ['1', '2', '-3', '4', '5']</span></span><br></pre></td></tr></table></figure>
<p><code>filter()</code> 函数创建了一个迭代器，因此如果你想得到一个列表的话，就得像示例那样使用 <code>list()</code> 去转换。</p>
<blockquote>
<p>另外一个值得关注的过滤工具就是 <code>itertools.compress()</code> ， 它以一个 <code>iterable</code> 对象和一个相对应的 <code>Boolean</code> 选择器序列作为输入参数。 然后输出 <code>iterable</code> 对象中对应选择器为 <code>True</code> 的元素。 当你需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</span><br><span class="line"></span><br><span class="line">more5 = [n &gt; <span class="number">5</span> <span class="keyword">for</span> n <span class="keyword">in</span> counts]</span><br><span class="line">print(more5)</span><br><span class="line"><span class="comment"># [False, False, True, False, False, True, True, False]</span></span><br><span class="line">more6 = list(compress(addresses, more5))</span><br><span class="line">print(more6)</span><br><span class="line"><span class="comment"># ['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']</span></span><br></pre></td></tr></table></figure>
<p>这里的关键点在于先创建一个 <code>Boolean</code> 序列，指示哪些元素符合条件。 然后 <code>compress()</code> 函数根据这个序列去选择输出对应位置为 True 的元素。</p>
<blockquote>
<p>和 <code>filter()</code> 函数类似， <code>compress()</code> 也是返回的一个迭代器。因此，如果你需要得到一个列表， 那么你需要使用 <code>list()</code> 来将结果转换为列表类型。</p>
</blockquote>
<h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line">    <span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line">    <span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line">    <span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line">    <span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line">p1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>&#125;</span><br><span class="line">print(p1)</span><br><span class="line"></span><br><span class="line">tech_names = &#123;<span class="string">'AAPL'</span>, <span class="string">'IBM'</span>, <span class="string">'HPQ'</span>, <span class="string">'MSFT'</span>&#125;</span><br><span class="line">p2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> key <span class="keyword">in</span> tech_names&#125;</span><br><span class="line">print(p2)</span><br></pre></td></tr></table></figure>
<p>大多数情况下字典推导能做到的，通过创建一个元组序列然后把它传给 <code>dict()</code> 函数也能实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p3 = dict((key, value) <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>)</span><br><span class="line">print(p3)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字典推导方式表意更清晰，并且实际上也会运行的更快些</p>
</blockquote>
<h2 id="collections-namedtuple"><a href="#collections-namedtuple" class="headerlink" title="collections.namedtuple()"></a>collections.namedtuple()</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p18_map_names_to_sequence_elements.html" target="_blank" rel="noopener">映射名称到序列元素</a></li>
</ul>
<p><code>collections.namedtuple()</code> 函数通过使用一个普通的元组对象来解决这个问题。 这个函数实际上是一个返回 <code>Python</code> 中标准元组类型子类的一个工厂方法。 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Subscriber = namedtuple(<span class="string">'Subscriber'</span>, [<span class="string">'addr'</span>, <span class="string">'joined'</span>])</span><br><span class="line">sub = Subscriber(<span class="string">'jonesy@example.com'</span>, <span class="string">'2012-10-19'</span>)</span><br><span class="line">print(sub)</span><br><span class="line"><span class="comment"># Subscriber(addr='jonesy@example.com', joined='2012-10-19')</span></span><br><span class="line">print(sub.addr)</span><br><span class="line"><span class="comment"># jonesy@example.com</span></span><br><span class="line">print(sub.joined)</span><br><span class="line"><span class="comment"># 2012-10-19</span></span><br></pre></td></tr></table></figure>
<p>尽管 <code>namedtuple</code> 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = len(sub)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">addr, joined = sub</span><br><span class="line">print(addr)</span><br><span class="line"><span class="comment"># jonesy@example.com</span></span><br><span class="line">print(joined)</span><br><span class="line"><span class="comment"># 2012-10-19</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此，如果你从数据库调用中返回了一个很大的元组列表，通过下标去操作其中的元素， 当你在表中添加了新的列的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Stock = namedtuple(<span class="string">'Stock'</span>, [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(records)</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> rec <span class="keyword">in</span> records:</span><br><span class="line">        s = Stock(*rec)</span><br><span class="line">        total += s.shares * s.price</span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>
<p>命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。 如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。 但是需要注意的是，不像字典那样，一个命名元组是不可更改的。</p>
<p>如果你真的需要改变属性的值，那么可以使用命名元组实例的 <code>_replace()</code> 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代。</p>
<pre><code>s = s._replace(shares=75)
</code></pre><p><code>_replace()</code> 方法还有一个很有用的特性就是当你的命名元组拥有可选或者缺失字段时候， 它是一个非常方便的填充数据的方法。 你可以先创建一个包含缺省值的原型元组，然后使用 <code>_replace()</code> 方法创建新的值被更新过的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Stock = namedtuple(<span class="string">'Stock'</span>, [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>, <span class="string">'date'</span>, <span class="string">'time'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a prototype instance</span></span><br><span class="line">stock_prototype = Stock(<span class="string">''</span>, <span class="number">0</span>, <span class="number">0.0</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to convert a dictionary to a Stock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_to_stock</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> stock_prototype._replace(**s)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后要说的是，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择。 这时候你应该考虑定义一个包含 <code>__slots__</code> 方法的类</p>
</blockquote>
<h2 id="collections-ChainMap"><a href="#collections-ChainMap" class="headerlink" title="collections.ChainMap"></a>collections.ChainMap</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p20_combine_multiple_map_to_single_map.html" target="_blank" rel="noopener">合并多个字典或映射</a></li>
</ul>
<p>一个 <code>ChainMap</code> 接受多个字典并将它们在逻辑上变为一个字典。 然后，这些字典并不是真的合并在一起了， <code>ChainMap</code> 类只是在内部创建了一个容纳这些字典的列表 并重新定义了一些常见的字典操作来遍历这个列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'z'</span>: <span class="number">3</span> &#125;</span><br><span class="line">b = &#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'z'</span>: <span class="number">4</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"></span><br><span class="line">c = ChainMap(a, b)</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># ChainMap(&#123;'x': 1, 'z': 3&#125;, &#123;'y': 2, 'z': 4&#125;)</span></span><br><span class="line">print(c[<span class="string">'x'</span>]) <span class="comment"># 1</span></span><br><span class="line">print(c[<span class="string">'z'</span>]) <span class="comment"># 3</span></span><br><span class="line">print(c[<span class="string">'y'</span>]) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果出现重复键，那么第一次出现的映射值会被返回。<br>对于字典的更新或删除操作总是影响的是列表中第一个字典。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">value = ChainMap()</span><br><span class="line">value[<span class="string">'x'</span>] = <span class="number">0</span></span><br><span class="line">value = value.new_child()</span><br><span class="line">value[<span class="string">'x'</span>] = <span class="number">1</span></span><br><span class="line">value = value.new_child()</span><br><span class="line">value[<span class="string">'y'</span>] = <span class="number">2</span></span><br><span class="line">value = value.new_child()</span><br><span class="line">value[<span class="string">'z'</span>] = <span class="number">3</span></span><br><span class="line">print(value)</span><br><span class="line"><span class="comment"># ChainMap(&#123;'z': 3&#125;, &#123;'y': 2&#125;, &#123;'x': 1&#125;, &#123;'x': 0&#125;)</span></span><br><span class="line">value = value.parents</span><br><span class="line"><span class="comment"># 删除最后加入的字典</span></span><br><span class="line">value = value.parents</span><br><span class="line">print(value)</span><br><span class="line"><span class="comment"># ChainMap(&#123;'x': 1&#125;, &#123;'x': 0&#125;)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在原字典中的修改会直接反应到 <code>ChainMap</code> 中。</p>
</blockquote>
<h1 id="字符串和文本"><a href="#字符串和文本" class="headerlink" title="字符串和文本"></a>字符串和文本</h1><h2 id="字符串开头或结尾匹配"><a href="#字符串开头或结尾匹配" class="headerlink" title="字符串开头或结尾匹配"></a>字符串开头或结尾匹配</h2><p>检查字符串开头或结尾的一个简单方法是使用 <code>str.startswith()</code> 或者是 <code>str.endswith()</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_list = os.listdir(<span class="string">'.'</span>)</span><br><span class="line">print(file_list)</span><br><span class="line"><span class="comment"># ['startandendwith.py', '__init__.py']</span></span><br><span class="line">end_with = [name <span class="keyword">for</span> name <span class="keyword">in</span> file_list <span class="keyword">if</span> name.endswith(<span class="string">'.py'</span>)]</span><br><span class="line">print(end_with)</span><br><span class="line"><span class="comment"># ['startandendwith.py', '__init__.py']</span></span><br><span class="line">start_with = [name <span class="keyword">for</span> name <span class="keyword">in</span> file_list <span class="keyword">if</span> name.startswith(<span class="string">'s'</span>)]</span><br><span class="line">print(start_with)</span><br><span class="line"><span class="comment"># ['startandendwith.py']</span></span><br><span class="line">has_end = any(name.endswith(<span class="string">'.py'</span>) <span class="keyword">for</span> name <span class="keyword">in</span> file_list)</span><br><span class="line">print(has_end)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(any([<span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">False</span>]))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>startswith() 和 endswith() 方法提供了一个非常方便的方式去做字符串开头和结尾的检查。 类似的操作也可以使用切片来实现，但是代码看起来没有那么优雅。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">choices = [<span class="string">'http:'</span>, <span class="string">'ftp:'</span>]</span><br><span class="line">t = tuple(choices)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>tuple()</code> 可以将 <code>list</code> 或者 <code>set</code> 类型的选择项转换为元组类型。</p>
</blockquote>
<p>当和其他操作比如普通数据聚合相结合的时候 startswith() 和 endswith() 方法是很不错的。 比如，下面这个语句检查某个文件夹中是否存在指定的文件类型：</p>
<blockquote>
<p>if any(name.endswith((‘.c’, ‘.h’)) for name in listdir(dirname)):</p>
</blockquote>
<h2 id="fnmatch-和-fnmatchcase"><a href="#fnmatch-和-fnmatchcase" class="headerlink" title="fnmatch() 和 fnmatchcase()"></a>fnmatch() 和 fnmatchcase()</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p03_match_strings_with_shell_wildcard.html" target="_blank" rel="noopener">用Shell通配符匹配字符串</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch, fnmatchcase</span><br><span class="line"></span><br><span class="line">is_fnmatch_1 = fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'*.txt'</span>)</span><br><span class="line">print(is_fnmatch_1)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">is_fnmatch_2 = fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'?oo.txt'</span>)</span><br><span class="line">print(is_fnmatch_2)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">is_fnmatch_3 = fnmatch(<span class="string">'Dat45.csv'</span>, <span class="string">'Dat[0-9]*'</span>)</span><br><span class="line">print(is_fnmatch_3)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">names = [<span class="string">'Dat1.csv'</span>, <span class="string">'Dat2.csv'</span>, <span class="string">'config.ini'</span>, <span class="string">'foo.py'</span>]</span><br><span class="line">name_list = [name <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> fnmatch(name, <span class="string">'Dat*.csv'</span>)]</span><br><span class="line">print(name_list)</span><br><span class="line"><span class="comment"># ['Dat1.csv', 'Dat2.csv']</span></span><br></pre></td></tr></table></figure>
<p><code>fnmatch()</code> 函数使用底层操作系统的大小写敏感规则(不同的系统是不一样的)来匹配模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># On OS X (Mac)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'*.TXT'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># On Windows</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fnmatch(<span class="string">'foo.txt'</span>, <span class="string">'*.TXT'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>如果对这个区别很在意，可以使用 <code>fnmatchcase()</code> 来代替。它完全使用所规定的模式大小写匹配。</p>
<blockquote>
<p><code>fnmatch()</code> 函数匹配能力介于简单的字符串方法和强大的正则表达式之间。 如果在数据处理操作中只需要简单的通配符就能完成的时候，这通常是一个比较合理的方案。</p>
</blockquote>
<h2 id="re-sub"><a href="#re-sub" class="headerlink" title="re.sub()"></a>re.sub()</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p05_search_and_replace_text.html" target="_blank" rel="noopener">字符串搜索和替换</a></li>
</ul>
<p><code>sub()</code> 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">'Today is 11/27/2012. PyCon starts 3/13/2013.'</span></span><br><span class="line">s = re.sub(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>, <span class="string">r'\3-\1-\2'</span>, text)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># Today is 2012-11-27. PyCon starts 2013-3-13.</span></span><br></pre></td></tr></table></figure>
<p>如果打算用相同的模式做多次替换，考虑先编译它来提升性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">datepat = re.compile(<span class="string">r'(\d+)/(\d+)/(\d+)'</span>)</span><br><span class="line">s2 = datepat.sub(<span class="string">r'\3-\1-\2'</span>, text)</span><br><span class="line">print(s2)</span><br><span class="line"><span class="comment"># Today is 2012-11-27. PyCon starts 2013-3-13.</span></span><br></pre></td></tr></table></figure>
<p>对于更加复杂的替换，可以传递一个替换回调函数来代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> month_abbr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chane_date</span><span class="params">(m)</span>:</span></span><br><span class="line">    mon_name = month_abbr[int(m.group(<span class="number">1</span>))]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(m.group(<span class="number">2</span>), mon_name, m.group(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">s3 = datepat.sub(chane_date, text)</span><br><span class="line">print(s3)</span><br><span class="line"><span class="comment"># Today is 27 Nov 2012. PyCon starts 13 Mar 2013.</span></span><br></pre></td></tr></table></figure>
<p>一个替换回调函数的参数是一个 match 对象，也就是 match() 或者 find() 返回的对象。 使用 group() 方法来提取特定的匹配部分。回调函数最后返回替换字符串。</p>
<p>如果除了替换后的结果外，还想知道有多少替换发生了，可以使用 <code>re.subn()</code> 来代替。函数返回一个元组来表示替换后的值和一共替换的数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s4, n = datepat.subn(chane_date, text)</span><br><span class="line">print(s4, n)</span><br><span class="line"><span class="comment"># Today is 27 Nov 2012. PyCon starts 13 Mar 2013. 2</span></span><br></pre></td></tr></table></figure>
<h2 id="re-IGNORECASE"><a href="#re-IGNORECASE" class="headerlink" title="re.IGNORECASE"></a>re.IGNORECASE</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p06_search_replace_case_insensitive.html" target="_blank" rel="noopener">字符串忽略大小写的搜索替换</a></li>
</ul>
<p>以忽略大小写的方式搜索与替换文本字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'UPPER PYTHON, lower python, Mixed Python'</span></span><br><span class="line">a = re.findall(<span class="string">'python'</span>, text, flags=re.IGNORECASE)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># ['PYTHON', 'python', 'Python']</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>sub()</code> 函数除了接受替换字符串外，还能接受一个回调函数。</p>
</blockquote>
<h2 id="re-DOTALL"><a href="#re-DOTALL" class="headerlink" title="re.DOTALL"></a>re.DOTALL</h2><p><code>re.compile()</code> 函数接受一个标志参数叫 <code>re.DOTALL</code> ，在这里非常有用。 它可以让正则表达式中的点<code>(.)</code>匹配包括换行符在内的任意字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text2 = <span class="string">'''/* this is a</span></span><br><span class="line"><span class="string"> multiline comment */</span></span><br><span class="line"><span class="string"> '''</span></span><br><span class="line">comment = re.compile(<span class="string">r'/\*(.*?)\*/'</span>, re.DOTALL)</span><br><span class="line">a = comment.findall(text2)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># [' this is a\n multiline comment ']</span></span><br></pre></td></tr></table></figure>
<p>这样的对于那些需要换行的字符串就能很好的匹配， 同时，适用于那些文件的读取。也可以用<code>re.compile(r&#39;/\*((?:.|\n)*?)\*/&#39;)</code>来代替，也能达到跨行匹配字符串的效果。</p>
<h2 id="unicodedata"><a href="#unicodedata" class="headerlink" title="unicodedata"></a>unicodedata</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p09_normalize_unicode_text_to_regexp.html" target="_blank" rel="noopener">将Unicode文本标准化</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'Spicy Jalape\u00f1o'</span></span><br><span class="line">print(s1)</span><br><span class="line"><span class="comment"># Spicy Jalapeño</span></span><br><span class="line">s2 = <span class="string">'Spicy Jalapen\u0303o'</span></span><br><span class="line">print(s2)</span><br><span class="line"><span class="comment"># Spicy Jalapeño</span></span><br><span class="line">print(s1==s2)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(len(s1))</span><br><span class="line"><span class="comment"># 14</span></span><br><span class="line">print(len(s2))</span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure>
<p>这里的文本”Spicy Jalapeño”使用了两种形式来表示。 第一种使用整体字符”ñ”(U+00F1)，第二种使用拉丁字母”n”后面跟一个”~”的组合字符(U+0303)。</p>
<p>在需要比较字符串的程序中使用字符的多种表示会产生问题。 为了修正这个问题，可以使用<code>unicodedata</code>模块先将文本标准化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"></span><br><span class="line">t1 = unicodedata.normalize(<span class="string">'NFC'</span>, s1)</span><br><span class="line">t2 = unicodedata.normalize(<span class="string">'NFC'</span>, s2)</span><br><span class="line">print(t1 == t2)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(ascii(t1))</span><br><span class="line"><span class="comment"># 'Spicy Jalape\xf1o'</span></span><br><span class="line"></span><br><span class="line">t1 = unicodedata.normalize(<span class="string">'NFD'</span>, s1)</span><br><span class="line">t2 = unicodedata.normalize(<span class="string">'NFD'</span>, s2)</span><br><span class="line">print(t1 == t2)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(ascii(t1))</span><br><span class="line"><span class="comment"># 'Spicy Jalapen\u0303o'</span></span><br></pre></td></tr></table></figure>
<p><code>normalize()</code> 第一个参数指定字符串标准化的方式。 <strong>NFC</strong>表示字符应该是整体组成(比如可能的话就使用单一编码)，而<strong>NFD</strong>表示字符应该分解为多个组合字符表示。</p>
<p>Python同样支持扩展的标准化形式<strong>NFKC</strong>和<strong>NFKD</strong>，它们在处理某些字符的时候增加了额外的兼容特性。</p>
<p>标准化对于任何需要以一致的方式处理Unicode文本的程序都是非常重要的。 当处理来自用户输入的字符串而你很难去控制编码的时候尤其如此。</p>
<h2 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h2><p>主要用来去除多余的空格，当然，也可也以去除多余的其他字符。<code>strip()</code> 方法能用于删除开始或结尾的字符。 <code>lstrip()</code> 和 <code>rstrip()</code> 分别从左和从右执行删除操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">' hello world \n'</span></span><br><span class="line">print(s.strip())</span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line">print(s.lstrip())</span><br><span class="line"><span class="comment"># hello world \n</span></span><br><span class="line">print(s.rstrip())</span><br><span class="line"><span class="comment">#  hello world</span></span><br></pre></td></tr></table></figure>
<p>添加参数就可以对应去除参数中的字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="string">'-----hello====='</span></span><br><span class="line">print(t.lstrip(<span class="string">'-'</span>))</span><br><span class="line"><span class="comment"># hello=====</span></span><br><span class="line">print(t.strip(<span class="string">'-='</span>))</span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure>
<p>这些 <code>strip()</code> 方法在读取和清理数据以备后续处理的时候是经常会被用到的。 比如，你可以用它们来去掉空格，引号和完成其他任务。</p>
<blockquote>
<p>但是需要注意的是去除操作不会对字符串的中间的文本产生任何影响。<br>如果想处理中间的空格，那么你需要求助其他技术。比如使用 <code>replace()</code> 方法或者是用正则表达式替换。</p>
</blockquote>
<h2 id="ljust、rjust、center"><a href="#ljust、rjust、center" class="headerlink" title="ljust、rjust、center"></a>ljust、rjust、center</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p13_aligning_text_strings.html" target="_blank" rel="noopener">字符串对齐</a></li>
</ul>
<p>通过参数的设定，可以指定字符串的长度，如果字符串长度不足，就不会添加字符进行填充。否则就会根据参数添加对应的字符进行添加填充，使得整个的字符串的长度达到参数所规定的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hellow World'</span></span><br><span class="line">text = s.ljust(<span class="number">20</span>)</span><br><span class="line">print(text)</span><br><span class="line"><span class="comment"># Hellow World</span></span><br><span class="line"></span><br><span class="line">text = s.rjust(<span class="number">20</span>)</span><br><span class="line">print(text)</span><br><span class="line"><span class="comment">#         Hellow World</span></span><br><span class="line"></span><br><span class="line">text = s.rjust(<span class="number">20</span>, <span class="string">'-'</span>)</span><br><span class="line">print(text)</span><br><span class="line"><span class="comment"># --------Hellow World</span></span><br></pre></td></tr></table></figure>
<p>并且，<code>format</code>函数也可以对字符串进行填充。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(format(s, <span class="string">'+&gt;20s'</span>))</span><br><span class="line">print(format(s, <span class="string">'-&lt;20s'</span>))</span><br><span class="line">print(format(s, <span class="string">'=&gt;20s'</span>))</span><br><span class="line">print(format(s, <span class="string">'*^20s'</span>))</span><br><span class="line"><span class="comment"># ++++++++Hellow World</span></span><br><span class="line"><span class="comment"># Hellow World--------</span></span><br><span class="line"><span class="comment"># ========Hellow World</span></span><br><span class="line"><span class="comment"># ****Hellow World****</span></span><br></pre></td></tr></table></figure>
<p>也可以同时格式化多个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'&#123;:+&gt;10s&#125; &#123;:-&gt;10s&#125;'</span>.format(<span class="string">'Hello'</span>, <span class="string">'World'</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：需要写<code>：</code>号，后面的<code>s</code>只是表明变量是字符串类型的，当然，<code>format</code>也可以格式化其他的类型。</p>
</blockquote>
<p>所以，在需要对字符串进行格式化的时候，尽量使用<code>format</code>函数来格式化字符串，而不应该采用原来的代码<code>%s</code>类似的形式格式化。同时，这一种形式也可以替代<code>ljust</code>、<code>rjust</code>、<code>center</code>。</p>
<h2 id="format-map-和-vars"><a href="#format-map-和-vars" class="headerlink" title="format_map 和 vars"></a>format_map 和 vars</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'lim'</span></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'&#123;name&#125; is &#123;age&#125; years old.'</span></span><br><span class="line">print(s.format_map(vars()))</span><br><span class="line"><span class="comment"># lim is 12 years old.</span></span><br></pre></td></tr></table></figure>
<p> 这样可以直接在变量域中寻找字符串中碎对应的变量，与字符串相结合。</p>
<p><code>vars()</code> 还有一个有意思的特性就是它也适用于对象实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">me = People(<span class="string">'jaelyn'</span>, <span class="number">17</span>)</span><br><span class="line">output = s.format_map(vars(me))</span><br><span class="line">print(output)</span><br><span class="line"><span class="comment"># jaelyn is 17 years old.</span></span><br></pre></td></tr></table></figure>
<p><code>format</code> 和 <code>format_map()</code> 的一个缺陷就是它们并不能很好的处理变量缺失的情况，</p>
<blockquote>
<p>一种避免这种错误的方法是另外定义一个含有 <code>__missing__()</code> 方法的字典对象</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># self.age = age</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;'</span> + key + <span class="string">'&#125;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">safesub</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;'</span> + key + <span class="string">'&#125;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">me = People(<span class="string">'jaelyn'</span>, <span class="number">17</span>)</span><br><span class="line">output = s.format_map(safesub(vars(me)))</span><br><span class="line">print(output)</span><br><span class="line"><span class="comment"># jaelyn is &#123;age&#125; years old.</span></span><br></pre></td></tr></table></figure>
<h2 id="textwrap"><a href="#textwrap" class="headerlink" title="textwrap"></a>textwrap</h2><p>使用 <code>textwrap</code> 模块来格式化字符串的输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line"></span><br><span class="line">s = <span class="string">"Look into my eyes, look into my eyes, the eyes, the eyes, \</span></span><br><span class="line"><span class="string">the eyes, not around the eyes, don't look around the eyes, \</span></span><br><span class="line"><span class="string">look into my eyes, you're under."</span></span><br><span class="line"></span><br><span class="line">print(textwrap.fill(s, <span class="number">70</span>), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,</span></span><br><span class="line"><span class="string">not around the eyes, don't look around the eyes, look into my eyes,</span></span><br><span class="line"><span class="string">you're under.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(textwrap.fill(s, <span class="number">30</span>), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Look into my eyes, look into</span></span><br><span class="line"><span class="string">my eyes, the eyes, the eyes,</span></span><br><span class="line"><span class="string">the eyes, not around the eyes,</span></span><br><span class="line"><span class="string">don't look around the eyes,</span></span><br><span class="line"><span class="string">look into my eyes, you're</span></span><br><span class="line"><span class="string">under.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(textwrap.fill(s, <span class="number">40</span>, initial_indent=<span class="string">'++++++'</span>), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">++++++Look into my eyes, look into my</span></span><br><span class="line"><span class="string">eyes, the eyes, the eyes, the eyes, not</span></span><br><span class="line"><span class="string">around the eyes, don't look around the</span></span><br><span class="line"><span class="string">eyes, look into my eyes, you're under.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(textwrap.fill(s, <span class="number">40</span>, subsequent_indent=<span class="string">'======'</span>), end=<span class="string">'\n\n'</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Look into my eyes, look into my eyes,</span></span><br><span class="line"><span class="string">======the eyes, the eyes, the eyes, not</span></span><br><span class="line"><span class="string">======around the eyes, don't look around</span></span><br><span class="line"><span class="string">======the eyes, look into my eyes,</span></span><br><span class="line"><span class="string">======you're under.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>textwrap</code> 模块对于字符串打印是非常有用的，特别是当你希望输出自动匹配终端大小的时候。 你可以使用 <code>os.get_terminal_size()</code> 方法来获取终端的大小尺寸。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">terminal_colum = os.get_terminal_size().columns</span><br><span class="line">print(terminal_colum)</span><br><span class="line"><span class="comment"># 261</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，上面的那条语句需要在控制台执行，不然会报 <code>OSError: [WinError 6] 句柄无效。</code> 的错误。</p>
</blockquote>
<h2 id="html-escape"><a href="#html-escape" class="headerlink" title="html.escape"></a>html.escape</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p17_handle_html_xml_in_text.html" target="_blank" rel="noopener">在字符串中处理html和xml</a></li>
</ul>
<p>想将HTML或者XML实体如 <code>&amp;entity;</code> 或 <code>&amp;#code;</code> 替换为对应的文本。 再者，需要转换文本中特定的字符(比如<code>&lt;</code>, <code>&gt;</code>, 或 <code>&amp;</code>)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line">s = <span class="string">'Elements are written as "&lt;tag&gt;text&lt;/tag&gt;".'</span></span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># Elements are written as "&lt;tag&gt;text&lt;/tag&gt;".</span></span><br><span class="line">print(html.escape(s))</span><br><span class="line"><span class="comment"># Elements are written as &amp;quot;&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;&amp;quot;.</span></span><br><span class="line">print(html.escape(s, quote=<span class="keyword">False</span>))</span><br><span class="line"><span class="comment"># Elements are written as "&amp;lt;tag&amp;gt;text&amp;lt;/tag&amp;gt;".</span></span><br></pre></td></tr></table></figure>
<p>如果正在处理的是ASCII文本，并且想将非ASCII文本对应的编码实体嵌入进去， 可以给某些I/O函数传递参数 <code>errors=&#39;xmlcharrefreplace&#39;</code> 来达到这个目。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Spicy Jalapeño'</span></span><br><span class="line">print(s.encode(<span class="string">'ascii'</span>, errors=<span class="string">'xmlcharrefreplace'</span>))</span><br><span class="line"><span class="comment"># b'Spicy Jalape&amp;#241;o'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了替换文本中的编码实体，需要使用另外一种方法。 如果正在处理HTML或者XML文本，试着先使用一个合适的HTML或者XML解析器。 通常情况下，这些工具会自动替换这些编码值，你无需担心。</p>
</blockquote>
<blockquote>
<p>有时候，如果你接收到了一些含有编码值的原始文本，需要手动去做替换， 通常你只需要使用HTML或者XML解析器的一些相关工具函数/方法即可。</p>
</blockquote>
<h2 id="字符串令牌解析"><a href="#字符串令牌解析" class="headerlink" title="字符串令牌解析"></a>字符串令牌解析</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p18_tokenizing_text.html" target="_blank" rel="noopener">字符串令牌解析</a></li>
</ul>
<p>第一步就是利用命名捕获组的正则表达式来定义所有可能的令牌。<code>?P&lt;TOKENNAME&gt;</code> 用于给一个模式命名，供后面使用。</p>
<p>为了令牌化，使用模式对象很少被人知道的 <code>scanner()</code> 方法。 这个方法会创建一个 <code>scanner</code> 对象， 在这个对象上不断的调用 <code>match()</code> 方法会一步步的扫描目标文本，每步一个匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">NAME = <span class="string">r'(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)'</span></span><br><span class="line">NUM = <span class="string">r'(?P&lt;NUM&gt;\d+)'</span></span><br><span class="line">PLUS = <span class="string">r'(?P&lt;PLUS&gt;\+)'</span></span><br><span class="line">TIMES = <span class="string">r'(?P&lt;TIMES&gt;\*)'</span></span><br><span class="line">EQ = <span class="string">r'(?P&lt;EQ&gt;=)'</span></span><br><span class="line">WS = <span class="string">r'(?P&lt;WS&gt;\s+)'</span></span><br><span class="line"></span><br><span class="line">master_pat = re.compile(<span class="string">'|'</span>.join([NAME, NUM, PLUS, TIMES, EQ, WS]))</span><br><span class="line">print(master_pat)</span><br><span class="line"><span class="comment"># re.compile('(?P&lt;NAME&gt;[a-zA-Z_][a-zA-Z_0-9]*)|(?P&lt;NUM&gt;\\d+)|(?P&lt;PLUS&gt;\\+)|(?P&lt;TIMES&gt;\\*)|(?P&lt;EQ&gt;=)|(?P&lt;WS&gt;\\s+)')</span></span><br><span class="line">scanner = master_pat.scanner(<span class="string">'foo = 23 + 42 * 10'</span>)</span><br><span class="line">result = scanner.match()</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(0, 3), match='foo'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_tokens</span><span class="params">(pat, text)</span>:</span></span><br><span class="line">    Token = namedtuple(<span class="string">'Token'</span>, [<span class="string">'type'</span>, <span class="string">'value'</span>])</span><br><span class="line">    scanner = pat.scanner(text)</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> iter(scanner.match, <span class="keyword">None</span>):</span><br><span class="line">        <span class="keyword">yield</span> Token(m.lastgroup, m.group())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tok <span class="keyword">in</span> generate_tokens(master_pat, <span class="string">'foo = 23 + 42 * 10'</span>):</span><br><span class="line">    print(tok)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Token(type='NAME', value='foo')</span></span><br><span class="line"><span class="string">Token(type='WS', value=' ')</span></span><br><span class="line"><span class="string">Token(type='EQ', value='=')</span></span><br><span class="line"><span class="string">Token(type='WS', value=' ')</span></span><br><span class="line"><span class="string">Token(type='NUM', value='23')</span></span><br><span class="line"><span class="string">Token(type='WS', value=' ')</span></span><br><span class="line"><span class="string">Token(type='PLUS', value='+')</span></span><br><span class="line"><span class="string">Token(type='WS', value=' ')</span></span><br><span class="line"><span class="string">Token(type='NUM', value='42')</span></span><br><span class="line"><span class="string">Token(type='WS', value=' ')</span></span><br><span class="line"><span class="string">Token(type='TIMES', value='*')</span></span><br><span class="line"><span class="string">Token(type='WS', value=' ')</span></span><br><span class="line"><span class="string">Token(type='NUM', value='10')</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常来讲令牌化是很多高级文本解析与处理的第一步。 为了使用上面的扫描方法，你需要记住这里一些重要的几点。 第一点就是你必须确认你使用正则表达式指定了所有输入中可能出现的文本序列。 如果有任何不可匹配的文本出现了，扫描就会直接停止。这也是为什么上面例子中必须指定空白字符令牌的原因。</p>
</blockquote>
<p>令牌的顺序也是有影响的。 <code>re</code> 模块会按照指定好的顺序去做匹配。 因此，如果一个模式恰好是另一个更长模式的子字符串，那么你需要确定长模式写在前面。</p>
<blockquote>
<p><code>namedtuple</code> 这个函数是用来实例化一个对象用的，这样对于一些比较简单的对象，没有太多的内容的话，就可以用这个函数去实例化出来。<code>namedtuple</code> 是一个函数，它用来创建一个自定义的 <code>tuple</code> 对象，并且规定了 <code>tuple</code> 元素的个数，并可以用属性而不是索引来引用 <code>tuple</code> 的某个元素。</p>
</blockquote>
<h2 id="实现一个简单的递归下降分析器"><a href="#实现一个简单的递归下降分析器" class="headerlink" title="实现一个简单的递归下降分析器"></a>实现一个简单的递归下降分析器</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p19_writing_recursive_descent_parser.html" target="_blank" rel="noopener">实现一个简单的递归下降分析器</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Topic: 下降解析器</span></span><br><span class="line"><span class="string">Desc :</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># Token specification</span></span><br><span class="line">NUM = <span class="string">r'(?P&lt;NUM&gt;\d+)'</span></span><br><span class="line">PLUS = <span class="string">r'(?P&lt;PLUS&gt;\+)'</span></span><br><span class="line">MINUS = <span class="string">r'(?P&lt;MINUS&gt;-)'</span></span><br><span class="line">TIMES = <span class="string">r'(?P&lt;TIMES&gt;\*)'</span></span><br><span class="line">DIVIDE = <span class="string">r'(?P&lt;DIVIDE&gt;/)'</span></span><br><span class="line">LPAREN = <span class="string">r'(?P&lt;LPAREN&gt;\()'</span></span><br><span class="line">RPAREN = <span class="string">r'(?P&lt;RPAREN&gt;\))'</span></span><br><span class="line">WS = <span class="string">r'(?P&lt;WS&gt;\s+)'</span></span><br><span class="line"></span><br><span class="line">master_pat = re.compile(<span class="string">'|'</span>.join([NUM, PLUS, MINUS, TIMES,</span><br><span class="line">                                  DIVIDE, LPAREN, RPAREN, WS]))</span><br><span class="line"><span class="comment"># Tokenizer</span></span><br><span class="line">Token = collections.namedtuple(<span class="string">'Token'</span>, [<span class="string">'type'</span>, <span class="string">'value'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_tokens</span><span class="params">(text)</span>:</span></span><br><span class="line">    scanner = master_pat.scanner(text)</span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> iter(scanner.match, <span class="keyword">None</span>):</span><br><span class="line">        tok = Token(m.lastgroup, m.group())</span><br><span class="line">        <span class="keyword">if</span> tok.type != <span class="string">'WS'</span>:</span><br><span class="line">            <span class="keyword">yield</span> tok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parser</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpressionEvaluator</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Implementation of a recursive descent parser. Each method</span></span><br><span class="line"><span class="string">    implements a single grammar rule. Use the ._accept() method</span></span><br><span class="line"><span class="string">    to test and accept the current lookahead token. Use the ._expect()</span></span><br><span class="line"><span class="string">    method to exactly match and discard the next token on on the input</span></span><br><span class="line"><span class="string">    (or raise a SyntaxError if it doesn't match).</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.tokens = generate_tokens(text)</span><br><span class="line">        self.tok = <span class="keyword">None</span>  <span class="comment"># Last symbol consumed</span></span><br><span class="line">        self.nexttok = <span class="keyword">None</span>  <span class="comment"># Next symbol tokenized</span></span><br><span class="line">        self._advance()  <span class="comment"># Load first lookahead token</span></span><br><span class="line">        <span class="keyword">return</span> self.expr()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_advance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'Advance one token ahead'</span></span><br><span class="line">        self.tok, self.nexttok = self.nexttok, next(self.tokens, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_accept</span><span class="params">(self, toktype)</span>:</span></span><br><span class="line">        <span class="string">'Test and consume the next token if it matches toktype'</span></span><br><span class="line">        <span class="keyword">if</span> self.nexttok <span class="keyword">and</span> self.nexttok.type == toktype:</span><br><span class="line">            self._advance()</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_expect</span><span class="params">(self, toktype)</span>:</span></span><br><span class="line">        <span class="string">'Consume next token if it matches toktype or raise SyntaxError'</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._accept(toktype):</span><br><span class="line">            <span class="keyword">raise</span> SyntaxError(<span class="string">'Expected '</span> + toktype)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Grammar rules follow</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expr</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"expression ::= term &#123; ('+'|'-') term &#125;*"</span></span><br><span class="line">        exprval = self.term()</span><br><span class="line">        <span class="keyword">while</span> self._accept(<span class="string">'PLUS'</span>) <span class="keyword">or</span> self._accept(<span class="string">'MINUS'</span>):</span><br><span class="line">            op = self.tok.type</span><br><span class="line">            right = self.term()</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'PLUS'</span>:</span><br><span class="line">                exprval += right</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'MINUS'</span>:</span><br><span class="line">                exprval -= right</span><br><span class="line">        <span class="keyword">return</span> exprval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">term</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"term ::= factor &#123; ('*'|'/') factor &#125;*"</span></span><br><span class="line">        termval = self.factor()</span><br><span class="line">        <span class="keyword">while</span> self._accept(<span class="string">'TIMES'</span>) <span class="keyword">or</span> self._accept(<span class="string">'DIVIDE'</span>):</span><br><span class="line">            op = self.tok.type</span><br><span class="line">            right = self.factor()</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">'TIMES'</span>:</span><br><span class="line">                termval *= right</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">'DIVIDE'</span>:</span><br><span class="line">                termval /= right</span><br><span class="line">        <span class="keyword">return</span> termval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factor</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"factor ::= NUM | ( expr )"</span></span><br><span class="line">        <span class="keyword">if</span> self._accept(<span class="string">'NUM'</span>):</span><br><span class="line">            <span class="keyword">return</span> int(self.tok.value)</span><br><span class="line">        <span class="keyword">elif</span> self._accept(<span class="string">'LPAREN'</span>):</span><br><span class="line">            exprval = self.expr()</span><br><span class="line">            self._expect(<span class="string">'RPAREN'</span>)</span><br><span class="line">            <span class="keyword">return</span> exprval</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> SyntaxError(<span class="string">'Expected NUMBER or LPAREN'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">descent_parser</span><span class="params">()</span>:</span></span><br><span class="line">    e = ExpressionEvaluator()</span><br><span class="line">    print(e.parse(<span class="string">'2'</span>))</span><br><span class="line">    print(e.parse(<span class="string">'2 + 3'</span>))</span><br><span class="line">    print(e.parse(<span class="string">'2 + 3 * 4'</span>))</span><br><span class="line">    print(e.parse(<span class="string">'2 + (3 + 4) * 5'</span>))</span><br><span class="line">    <span class="comment"># print(e.parse('2 + (3 + * 4)'))</span></span><br><span class="line">    <span class="comment"># Traceback (most recent call last):</span></span><br><span class="line">    <span class="comment">#    File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line">    <span class="comment">#    File "exprparse.py", line 40, in parse</span></span><br><span class="line">    <span class="comment">#    return self.expr()</span></span><br><span class="line">    <span class="comment">#    File "exprparse.py", line 67, in expr</span></span><br><span class="line">    <span class="comment">#    right = self.term()</span></span><br><span class="line">    <span class="comment">#    File "exprparse.py", line 77, in term</span></span><br><span class="line">    <span class="comment">#    termval = self.factor()</span></span><br><span class="line">    <span class="comment">#    File "exprparse.py", line 93, in factor</span></span><br><span class="line">    <span class="comment">#    exprval = self.expr()</span></span><br><span class="line">    <span class="comment">#    File "exprparse.py", line 67, in expr</span></span><br><span class="line">    <span class="comment">#    right = self.term()</span></span><br><span class="line">    <span class="comment">#    File "exprparse.py", line 77, in term</span></span><br><span class="line">    <span class="comment">#    termval = self.factor()</span></span><br><span class="line">    <span class="comment">#    File "exprparse.py", line 97, in factor</span></span><br><span class="line">    <span class="comment">#    raise SyntaxError("Expected NUMBER or LPAREN")</span></span><br><span class="line">    <span class="comment">#    SyntaxError: Expected NUMBER or LPAREN</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    descent_parser()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>待研究学习，字符串相关</p>
</blockquote>
<h1 id="数字日期和时间"><a href="#数字日期和时间" class="headerlink" title="数字日期和时间"></a>数字日期和时间</h1><h2 id="round"><a href="#round" class="headerlink" title="round"></a>round</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p01_round_number.html" target="_blank" rel="noopener">数字的四舍五入</a></li>
</ul>
<p>对浮点数执行指定精度的舍入运算。<br>对于简单的舍入运算，使用内置的 <code>round(value, ndigits)</code> 函数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(round(<span class="number">1.23</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 1.2</span></span><br><span class="line">print(round(<span class="number">1.27</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># 1.3</span></span><br><span class="line">print(round(<span class="number">1.25361</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 1.254</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个值刚好在两个边界的中间的时候， <code>round</code> 函数返回离它最近的偶数。 也就是说，对1.5或者2.5的舍入运算都会得到2。</p>
</blockquote>
<p>传给 <code>round()</code> 函数的 <code>ndigits</code> 参数可以是负数，这种情况下， 舍入运算会作用在十位、百位、千位等上面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1627731</span></span><br><span class="line">print(round(a, <span class="number">-1</span>))</span><br><span class="line"><span class="comment"># 1627730</span></span><br><span class="line">print(round(a, <span class="number">-2</span>))</span><br><span class="line"><span class="comment"># 1627700</span></span><br><span class="line">print(round(a, <span class="number">-3</span>))</span><br><span class="line"><span class="comment"># 1628000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要将舍入和格式化输出搞混淆了。 如果你的目的只是简单的输出一定宽度的数，你不需要使用 <code>round()</code> 函数。 而仅仅只需要在格式化的时候指定精度即可。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1.23456</span></span><br><span class="line">print(format(x, <span class="string">'0.2f'</span>))</span><br><span class="line"><span class="comment"># 1.23</span></span><br></pre></td></tr></table></figure>
<h2 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p02_accurate_decimal_calculations.html" target="_blank" rel="noopener">执行精确的浮点数运算</a></li>
</ul>
<p>对浮点数执行精确的计算操作，并且不希望有任何小误差的出现。</p>
<blockquote>
<p>浮点数的一个普遍问题是它们并不能精确的表示十进制数。 并且，即使是最简单的数学运算也会产生小的误差。这些错误是由底层<strong>CPU</strong>和<strong>IEEE 754标准</strong>通过自己的浮点单位去执行算术时的特征。 由于Python的浮点数据类型使用底层表示存储数据，因此你没办法去避免这样的误差。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">a = Decimal(<span class="string">'4.2'</span>)</span><br><span class="line">b = Decimal(<span class="string">'2.1'</span>)</span><br><span class="line">print(a + b)</span><br><span class="line"><span class="comment"># 6.3</span></span><br><span class="line">print((a + b) == Decimal(<span class="string">'6.3'</span>))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>初看起来，上面的代码好像有点奇怪，比如我们用字符串来表示数字。 然而， <code>Decimal</code> 对象会像普通浮点数一样的工作(支持所有的常用数学运算)。 如果你打印它们或者在字符串格式化函数中使用它们，看起来跟普通数字没什么两样。</p>
<blockquote>
<p>Python新手会倾向于使用 <code>decimal</code> 模块来处理浮点数的精确运算。 然而，先理解你的应用程序目的是非常重要的。 如果你是在做科学计算或工程领域的计算、电脑绘图，或者是科学领域的大多数运算， 那么使用普通的浮点类型是比较普遍的做法。 其中一个原因是，在真实世界中很少会要求精确到普通浮点数能提供的17位精度。 因此，计算过程中的那么一点点的误差是被允许的。 第二点就是，原生的浮点数计算要快的多-有时候你在执行大量运算的时候速度也是非常重要的。</p>
</blockquote>
<p>总的来说， <code>decimal</code> 模块主要用在涉及到金融的领域。 在这类程序中，哪怕是一点小小的误差在计算过程中蔓延都是不允许的。 因此， <code>decimal</code> 模块为解决这类问题提供了方法。 当Python和数据库打交道的时候也通常会遇到 <code>Decimal</code> 对象，并且，通常也是在处理金融数据的时候。</p>
<h2 id="fractions"><a href="#fractions" class="headerlink" title="fractions"></a>fractions</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p08_calculating_with_fractions.html" target="_blank" rel="noopener">分数运算</a></li>
</ul>
<p>用来执行包含分数的数学运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"></span><br><span class="line">a = Fraction(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">b = Fraction(<span class="number">7</span>, <span class="number">16</span>)</span><br><span class="line">print(a + b)</span><br><span class="line"><span class="comment"># 27/16</span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>numerator</code> 显示分子，用<code>denominator</code>显示分母。或者也可以使用<code>float</code>函数显示分数的浮点类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c = a * b</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># 35/64</span></span><br><span class="line">print(c.numerator)</span><br><span class="line"><span class="comment"># 35</span></span><br><span class="line">print(c.denominator)</span><br><span class="line"><span class="comment"># 64</span></span><br><span class="line"></span><br><span class="line">print(float(c))</span><br><span class="line"><span class="comment"># 0.546875</span></span><br></pre></td></tr></table></figure>
<p>这个函数同样也有很多用法，例如，求出一个分数，该分数的分母不超过所设定的数，并且该分数的值最接近所求的浮点数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(c.limit_denominator(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 5/9</span></span><br></pre></td></tr></table></figure>
<p>或者给出一个小数，求原来的分数，当然，求出来的值是最为接近的值，不代表完全一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3.75</span></span><br><span class="line">y = Fraction(*x.as_integer_ratio())</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># 15/4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在大多数程序中一般不会出现分数的计算问题，但是有时候还是需要用到的。 比如，在一个允许接受分数形式的测试单位并以分数形式执行运算的程序中， 直接使用分数可以减少手动转换为小数或浮点数的工作。</p>
</blockquote>
<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p09_calculating_with_large_num_arrays.html" target="_blank" rel="noopener">大型数组运算</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">y = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(x * <span class="number">2</span>)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 1, 2, 3, 4]</span></span><br><span class="line">print(x + y)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p>由此我们可以看出，python 原生的对与数列的处理就是普通的对于数列上的操作，由此看来，像 <code>*</code> 、 <code>+</code> 等操作，是以整个数列为最小单位的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">ax = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">ay = np.array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">print(ax * <span class="number">2</span>)</span><br><span class="line"><span class="comment"># [2 4 6 8]</span></span><br><span class="line">print(ax + <span class="number">10</span>)</span><br><span class="line"><span class="comment"># [11 12 13 14]</span></span><br><span class="line">print(ax + ay)</span><br><span class="line"><span class="comment"># [ 6  8 10 12]</span></span><br><span class="line">print(ax * ay)</span><br><span class="line"><span class="comment"># [ 5 12 21 32]</span></span><br></pre></td></tr></table></figure>
<p>与原生的不同，<code>numpy</code> 的数列操作则是对应里面的每一个元素的操作。</p>
<p><code>NumPy</code> 中的标量运算(比如 <code>ax * 2</code> 或 <code>ax + 10</code> )会作用在每一个元素上。 另外，当两个操作数都是数组的时候执行元素对等位置计算，并最终生成一个新的数组。</p>
<blockquote>
<p>NumPy 还为数组操作提供了大量的通用函数，这些函数可以作为 math 模块中类似函数的替代。</p>
</blockquote>
<p>使用这些通用函数要比循环数组并使用 math 模块中的函数执行计算要快的多。 因此，只要有可能的话尽量选择 NumPy 的数组方案。</p>
<blockquote>
<p>底层实现中， NumPy 数组使用了C或者Fortran语言的机制分配内存。 也就是说，它们是一个非常大的连续的并由同类型数据组成的内存区域。 所以，你可以构造一个比普通Python列表大的多的数组。</p>
</blockquote>
<p>NumPy 是Python领域中很多科学与工程库的基础，同时也是被广泛使用的最大最复杂的模块。 即便如此，在刚开始的时候通过一些简单的例子和玩具程序也能帮我们完成一些有趣的事情。</p>
<p>通常我们导入 NumPy 模块的时候会使用语句 import numpy as np 。 这样的话你就不用再你的程序里面一遍遍的敲入 numpy ，只需要输入 np 就行了，节省了不少时间。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p10_matrix_and_linear_algebra_calculation.html" target="_blank" rel="noopener">矩阵与线性代数运算</a></li>
</ul>
<p>NumPy 库有一个矩阵对象可以用来解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m = np.matrix([[<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">-9</span>]])</span><br><span class="line">print(m)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 1 -2  3]</span></span><br><span class="line"><span class="string"> [ 0  4  5]</span></span><br><span class="line"><span class="string"> [ 7  8 -9]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(m.T)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># 输出矩阵的转置</span></span><br><span class="line"><span class="string">[[ 1  0  7]</span></span><br><span class="line"><span class="string"> [-2  4  8]</span></span><br><span class="line"><span class="string"> [ 3  5 -9]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>可以在 <code>numpy.linalg</code> 子包中找到更多的操作函数。</p>
<p>这个函数有很多强大的功能，如果需要用到一些关于矩阵和线性代数相关的知识和运算的时候，可以参考这个函数，能轻松解决很多问题。</p>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p11_pick_things_at_random.html" target="_blank" rel="noopener">随机选择</a></li>
</ul>
<p>主要用于生成随机数的函数。</p>
<p><code>random</code> 模块有大量的函数用来产生随机数和随机选择元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在列表中随机生成一个数字</span></span><br><span class="line">a = random.choice(values)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在列表中随机生成多个数字组成的新列表</span></span><br><span class="line">b = random.sample(values, <span class="number">2</span>)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱列表的位置，没有返回值，会直接在原来的数组上修改，属于原地操作</span></span><br><span class="line">random.shuffle(values)</span><br><span class="line">print(values)</span><br><span class="line"><span class="comment"># [6, 5, 1, 2, 3, 4]</span></span><br><span class="line">print(values[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在1到10之间随机生成一个数字</span></span><br><span class="line">c = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在0到1之间随机生成浮点数</span></span><br><span class="line">d = random.random()</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 0.19051868016253204</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取N位随机位(二进制)的整数</span></span><br><span class="line">e = random.getrandbits(<span class="number">20</span>)</span><br><span class="line">print(e)</span><br><span class="line"><span class="comment"># 293829</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>random 模块使用 Mersenne Twister 算法来计算生成随机数。</p>
</blockquote>
<p>除了上述介绍的功能，<code>random</code>模块还包含基于均匀分布、高斯分布和其他分布的随机数生成函数。 比如， <code>random.uniform()</code> 计算均匀分布随机数， <code>random.gauss()</code> 计算正态分布随机数。</p>
<p>在 <code>random</code> 模块中的函数不应该用在和密码学相关的程序中。 如果你确实需要类似的功能，可以使用<code>ssl</code>模块中相应的函数。 比如， <code>ssl.RAND_bytes()</code> 可以用来生成一个安全的随机字节序列。</p>
<h2 id="datetime-amp-timedelta"><a href="#datetime-amp-timedelta" class="headerlink" title="datetime &amp; timedelta"></a>datetime &amp; timedelta</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p12_convert_days_to_seconds_and_others.html" target="_blank" rel="noopener">基本的日期与时间转换</a></li>
</ul>
<p>执行不同时间单位的转换和计算，请使用 <code>datetime</code> 模块。</p>
<p>如果你想表示指定的日期和时间，先创建一个 <code>datetime</code> 实例然后使用标准的数学运算来操作它们。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">a = timedelta(days=<span class="number">2</span>, hours=<span class="number">6</span>)</span><br><span class="line">b = timedelta(hours=<span class="number">4.5</span>)</span><br><span class="line">c = a + b</span><br><span class="line">print(c)</span><br><span class="line"><span class="comment"># 2 days, 10:30:00</span></span><br><span class="line">print(c.days)</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(c.seconds)</span><br><span class="line"><span class="comment"># 37800</span></span><br><span class="line">print(c.microseconds)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line">print(c.total_seconds())</span><br><span class="line"><span class="comment"># 210600.0</span></span><br><span class="line"></span><br><span class="line">a = datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">23</span>)</span><br><span class="line">print(a + timedelta(days=<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 2012-10-03 00:00:00</span></span><br><span class="line"></span><br><span class="line">b = datetime(<span class="number">2012</span>, <span class="number">12</span>, <span class="number">21</span>)</span><br><span class="line">d = b - a</span><br><span class="line">print(d.days)</span><br><span class="line"><span class="comment"># 89</span></span><br><span class="line">now = datetime.today()</span><br><span class="line">print(now)</span><br><span class="line"><span class="comment"># 2018-05-28 18:44:35.190897</span></span><br><span class="line">print(now + timedelta(minutes=<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 2018-05-28 18:54:35.190897</span></span><br><span class="line"></span><br><span class="line">a = datetime(<span class="number">2012</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">b = datetime(<span class="number">2012</span>, <span class="number">2</span>, <span class="number">28</span>)</span><br><span class="line">print(a - b)</span><br><span class="line"><span class="comment"># 2 days, 0:00:00</span></span><br><span class="line">print((a-b).days)</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<p>在计算的时候，需要注意的是 <code>datetime</code> 会自动处理闰年。</p>
<p>对大多数基本的日期和时间处理问题， <code>datetime</code> 模块已经足够了。 如果你需要执行更加复杂的日期操作，比如处理时区，模糊时间范围，节假日计算等等， 可以考虑使用 <code>dateutil</code> 模块。</p>
<blockquote>
<p>如果要执行大量的日期计算的话，最好安装第三方包 <code>python-dateutil</code> 来代替。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> dateutil.relativedelta <span class="keyword">import</span> relativedelta</span><br><span class="line"><span class="keyword">from</span> dateutil.rrule <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">d = datetime.now()</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 2018-05-28 23:39:37.526316</span></span><br><span class="line">print(d + relativedelta(weekday=FR))</span><br><span class="line"><span class="comment"># 2018-06-01 23:39:37.526316</span></span><br><span class="line">print(d + relativedelta(weekday=FR(<span class="number">-1</span>)))</span><br><span class="line"><span class="comment"># 2018-05-25 23:39:37.526316</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p14_date_range_for_current_month.html" target="_blank" rel="noopener">计算当前月份的日期范围</a></li>
</ul>
<p>计算对应的月份的天数，可以用到<code>calendar.monthrange()</code>函数，这个函数会根据所传入的年份和月数量，返回一个元组，包括对应月份的的星期和天数。</p>
<p>这样的话就可以使用循环等操作，获得当月份的所有日期。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, timedelta</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_month_range</span><span class="params">(start_date=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start_date <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        start_date = date.today().replace(month=<span class="number">2</span>, day=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for year, month.</span></span><br><span class="line">    temp, days_in_month = calendar.monthrange(start_date.year, start_date.month)</span><br><span class="line">    print(temp)</span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    print(days_in_month)</span><br><span class="line">    <span class="comment"># 28</span></span><br><span class="line">    end_date = start_date + timedelta(days=days_in_month)</span><br><span class="line">    <span class="keyword">return</span> (start_date, end_date)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a_day = timedelta(days=<span class="number">1</span>)</span><br><span class="line">first_day, last_day = get_month_range()</span><br><span class="line"><span class="keyword">while</span> first_day &lt; last_day:</span><br><span class="line">    print(first_day)</span><br><span class="line">    first_day += a_day</span><br></pre></td></tr></table></figure>
<p>同样的，也可以采用生成器的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">date_range</span><span class="params">(start, stop, step)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; stop:</span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line">        start += step</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> date_range(datetime(<span class="number">2012</span>, <span class="number">9</span>, <span class="number">1</span>), datetime(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">1</span>), timedelta(hours=<span class="number">6</span>)):</span><br><span class="line">    print(d)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p15_convert_strings_into_datetimes.html" target="_blank" rel="noopener">字符串转换为日期</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'2012-09-20'</span></span><br><span class="line">y = datetime.strptime(text, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">z = datetime.now()</span><br><span class="line">diff = z- y</span><br><span class="line">print(diff)</span><br><span class="line"><span class="comment"># 2077 days, 11:13:12.631424</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>datetime.strptime()</code> 方法支持很多的格式化代码， 比如 <code>%Y</code> 代表4位数年份， <code>%m</code> 代表两位数月份。 还有一点值得注意的是这些格式化占位符也可以反过来使用，将日期输出为指定的格式字符串形式。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z = datetime.now()</span><br><span class="line">nice_z = datetime.strftime(z, <span class="string">'%Y年%m月%d日'</span>)</span><br><span class="line">print(nice_z)</span><br><span class="line"><span class="comment"># 2018年05月29日</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一点需要注意的是， <code>strptime()</code> 的性能要比你想象中的差很多， 因为它是使用纯Python实现，并且必须处理所有的系统本地设置。 如果你要在代码中需要解析大量的日期并且已经知道了日期字符串的确切格式，可以自己实现一套解析方案来获取更好的性能。</p>
</blockquote>
<ul>
<li><code>datetime.strptime(text, &#39;%Y-%m-%d&#39;)</code> 将字符串转为日期格式。</li>
<li><p><code>datetime.strftime(z, &#39;%Y年%m月%d日&#39;)</code> 将日期格式按照自己所设定的格式转为字符串。（这个函数运行的会很慢，如果需要大量的对字符串的操作，并且有很多格式相似，可以自己用字符串拆分等方式，拆字符串拼接，这样的方式可以比这个函数快7倍）</p>
</li>
<li><p><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p16_manipulate_dates_involving_timezone.html" target="_blank" rel="noopener">结合时区的日期操作</a></p>
</li>
</ul>
<p><code>pytz</code> 模块一个主要用途是将 <code>datetime</code> 库创建的简单日期对象本地化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line">d = datetime(<span class="number">2018</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">41</span>)</span><br><span class="line">print(d)</span><br><span class="line">d = datetime.now()</span><br><span class="line"></span><br><span class="line">central = timezone(<span class="string">'Asia/Shanghai'</span>)</span><br><span class="line">loc_d = central.localize(d)</span><br><span class="line">print(loc_d)</span><br><span class="line"><span class="comment"># 2018-05-29 11:28:56.614715+08:00</span></span><br><span class="line"></span><br><span class="line">bang_d = loc_d.astimezone(timezone(<span class="string">'US/Central'</span>))</span><br><span class="line">print(bang_d)</span><br><span class="line"><span class="comment"># 2018-05-28 22:28:56.614715-05:00</span></span><br></pre></td></tr></table></figure>
<p>首先需要先本地化时间（<code>localize</code>方法），之后再调用 <code>astimezone</code> 方法用于切换时区时间。</p>
<blockquote>
<p>在使用的时候需要注意，在本地化时间上操作的时候，要考虑到夏令时的相关问题，不然会出现时间差 1 小时的情况。</p>
</blockquote>
<p>在使用的时候，如果不记得时区的表达方式，可以使用 <code>country_timezones</code> 来获得时区。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">p = pytz.country_timezones[<span class="string">'IN'</span>]</span><br><span class="line">print(p)</span><br><span class="line"><span class="comment"># ['Asia/Kolkata']</span></span><br><span class="line"></span><br><span class="line">p = pytz.country_timezones[<span class="string">'CN'</span>]</span><br><span class="line">print(p)</span><br><span class="line"><span class="comment"># ['Asia/Shanghai', 'Asia/Urumqi']</span></span><br></pre></td></tr></table></figure>
<h1 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h1><h2 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h2><p>遍历迭代下一个元素，在文件中表示一行。在执行的时候，如果捕获到最后一行，或者捕获到自定义的结束字符的时候，就会返回<code>StopIteration</code>异常，结束读取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">it = iter(items)</span><br><span class="line">print(next(it))</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(next(it))</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(next(it))</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">print(next(it))</span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure>
<h2 id="iter"><a href="#iter" class="headerlink" title="iter()"></a><strong>iter</strong>()</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p02_delegating_iteration.html" target="_blank" rel="noopener">代理迭代</a></li>
</ul>
<p>如果在自己定义的类中需要有自己的定义的迭代，可以定义一个 <code>__iter__()</code> 方法，将迭代操作代理到容器内部的对象上去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">	    <span class="comment"># &#123;!r&#125; 其中 “!r” 对应 repr()； “!s” 对应 str(); “!a” 对应 ascii()。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(self._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_children</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._children)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = Node(<span class="number">0</span>)</span><br><span class="line">    child1 = Node(<span class="number">1</span>)</span><br><span class="line">    child2 = Node(<span class="number">2</span>)</span><br><span class="line">    root.add_children(child1)</span><br><span class="line">    root.add_children(child2)</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> root:</span><br><span class="line">        print(ch)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的 <code>iter()</code> 函数的使用简化了代码， <code>iter(s)</code> 只是简单的通过调用 <code>s.__iter__()</code> 方法来返回对应的迭代器对象， 就跟 <code>len(s)</code> 会调用 <code>s.__len__()</code> 原理是一样的。</p>
</blockquote>
<h2 id="实现深度优先的遍历的树形结构"><a href="#实现深度优先的遍历的树形结构" class="headerlink" title="实现深度优先的遍历的树形结构"></a>实现深度优先的遍历的树形结构</h2><blockquote>
<p>可以在类中迭代方法的方式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._value = value</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;)'</span>.format(self._value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_child</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self._children.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._children)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">depth_first</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> c.depth_first()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = Node(<span class="number">0</span>)</span><br><span class="line">    child1 = Node(<span class="number">1</span>)</span><br><span class="line">    child2 = Node(<span class="number">2</span>)</span><br><span class="line">    root.add_child(child1)</span><br><span class="line">    root.add_child(child2)</span><br><span class="line">    child1.add_child(Node(<span class="number">3</span>))</span><br><span class="line">    child1.add_child(Node(<span class="number">4</span>))</span><br><span class="line">    child2.add_child(Node(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> root.depth_first():</span><br><span class="line">        print(ch)</span><br></pre></td></tr></table></figure>
<p>在 <code>depth_first</code> 方法中，首先迭代自己，之后在 <code>__iter__</code> 的迭代中，开始迭代自己的下级，最后在循环中，<code>yield from c.depth_first()</code>放回自己的下级。</p>
<blockquote>
<p>在这段代码中，<code>depth_first()</code> 方法简单直观。 它首先返回自己本身并迭代每一个子节点并 通过调用子节点的 <code>depth_first()</code> 方法(使用 <code>yield from</code> 语句)返回对应元素。</p>
</blockquote>
<h2 id="reversed"><a href="#reversed" class="headerlink" title="reversed()"></a>reversed()</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p05_iterating_in_reverse.html" target="_blank" rel="noopener">反向迭代</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(a):</span><br><span class="line">    print(i, end=<span class="string">' '</span>)</span><br><span class="line">    <span class="comment"># 4 3 2 1</span></span><br></pre></td></tr></table></figure>
<p>反向迭代仅仅当对象的大小可预先确定或者对象实现了 <code>__reversed__()</code> 的特殊方法时才能生效。 如果两者都不符合，那必须先将对象转换为一个列表才行。</p>
<blockquote>
<p>可以通过在自定义类上实现 <code>__reversed__()</code> 方法来实现反向迭代。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Countdown</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forward iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = self.start</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Reverse iterator</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reversed__</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &lt;= self.start:</span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> reversed(Countdown(<span class="number">30</span>)):</span><br><span class="line">    print(rr)</span><br><span class="line"><span class="keyword">for</span> rr <span class="keyword">in</span> Countdown(<span class="number">30</span>):</span><br><span class="line">    print(rr)</span><br></pre></td></tr></table></figure>
<p>定义一个反向迭代器可以使得代码非常的高效， 因为它不再需要将数据填充到一个列表中然后再去反向迭代这个列表。</p>
<h2 id="带有外部状态的生成器函数"><a href="#带有外部状态的生成器函数" class="headerlink" title="带有外部状态的生成器函数"></a>带有外部状态的生成器函数</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p06_define_generator_func_with_extra_state.html" target="_blank" rel="noopener">带有外部状态的生成器函数</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linehistory</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lines, histlen=<span class="number">3</span>)</span>:</span></span><br><span class="line">        self.lines = lines</span><br><span class="line">        self.history = deque(maxlen=histlen)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> lineno, line <span class="keyword">in</span> enumerate(self.lines, <span class="number">1</span>):</span><br><span class="line">            self.history.append((lineno, line))</span><br><span class="line">            <span class="keyword">yield</span> line</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.history.clear()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = linehistory(f)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'python'</span> <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">for</span> lineno, hline <span class="keyword">in</span> lines.history:</span><br><span class="line">                print(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(lineno, hline), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了使用这个类，你可以将它当做是一个普通的生成器函数。 然而，由于可以创建一个实例对象，于是你可以访问内部属性值， 比如 <code>history</code> 属性或者是 <code>clear()</code> 方法。</p>
</blockquote>
<p>一个需要注意的小地方是，如果你在迭代操作时不使用for循环语句，那么你得先调用 <code>iter()</code> 函数。</p>
<h2 id="itertools-islice"><a href="#itertools-islice" class="headerlink" title="itertools.islice()"></a>itertools.islice()</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p07_taking_slice_of_iterator.html" target="_blank" rel="noopener">迭代器切片</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n, end=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; end:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = count(<span class="number">1</span>, end=<span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> itertools.islice(c, <span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>itertools.islice</code>表示对迭代器或者生成器进行切片，不过不能使用标准的切片方法，标准的切片方法是基于原来的数组是固定长度的情况下才能使用的。这个切片是以函数的形式，接收开始的值和结束的值，位置（长度），之后将切片之后的迭代器返回。</p>
</blockquote>
<p>迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。 函数 <code>islice()</code> 返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。 然后才开始一个个的返回元素，并直到切片结束索引位置。</p>
<p><strong>这里要着重强调的一点是 <code>islice()</code> 会消耗掉传入的迭代器中的数据。 必须考虑到迭代器是不可逆的这个事实。 所以如果你需要之后再次访问这个迭代器的话，那你就得先将它里面的数据放入一个列表中。</strong></p>
<h2 id="itertools-dropwhile"><a href="#itertools-dropwhile" class="headerlink" title="itertools.dropwhile"></a>itertools.dropwhile</h2><p><code>itertools.dropwhile()</code> 函数。使用时，传递一个函数对象和一个可迭代对象。会返回一个迭代器对象，丢弃原有序列中直到函数返回<code>Flase</code>之前的所有元素，然后返回后面所有元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> dropwhile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'__init__.py'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> line: line.startswith(<span class="string">'#'</span>), f):</span><br><span class="line">        print(line, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p>如果已经明确知道了要跳过的元素的个数的话，那么可以使用 <code>itertools.islice()</code> 来代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</span><br><span class="line">items = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> islice(items, <span class="number">3</span>, <span class="keyword">None</span>):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>这个函数会根据所传入的参数，跳过前面几个迭代。<code>islice()</code> 函数最后那个 <code>None</code> 参数指定了你要获取从第3个到最后的所有元素， 如果 <code>None</code> 和3的位置对调，意思就是仅仅获取前三个元素恰恰相反， (这个跟切片的相反操作 [3:] 和 [:3] 原理是一样的)。</p>
<blockquote>
<p>解决方案是仅仅跳过开始部分满足测试条件的行，在那以后，所有的元素不再进行测试和过滤了。</p>
</blockquote>
<h2 id="itertools-permutations-和-itertools-combinations"><a href="#itertools-permutations-和-itertools-combinations" class="headerlink" title="itertools.permutations 和 itertools.combinations"></a>itertools.permutations 和 itertools.combinations</h2><p>对数列进行排列组合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line"></span><br><span class="line">items = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> permutations(items):</span><br><span class="line">    print(p)</span><br></pre></td></tr></table></figure>
<p><code>itertools.permutations()</code> ， 它接受一个集合并产生一个元组序列，每个元组由集合中所有元素的一个可能排列组成。 也就是说通过打乱集合中元素排列顺序生成一个元组。</p>
<p>如果想得到指定长度的所有排列，可以传递一个可选的长度参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> combinations(items, <span class="number">3</span>):</span><br><span class="line">    print(p)</span><br><span class="line">    <span class="comment"># ('a', 'b', 'c')</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> combinations(items, <span class="number">2</span>):</span><br><span class="line">    print(p)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">('a', 'b')</span></span><br><span class="line"><span class="string">('a', 'c')</span></span><br><span class="line"><span class="string">('b', 'c')</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> combinations(items, <span class="number">1</span>):</span><br><span class="line">    print(p)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">('a',)</span></span><br><span class="line"><span class="string">('b',)</span></span><br><span class="line"><span class="string">('c',)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>对于 <code>combinations()</code> 来讲，元素的顺序已经不重要了。 也就是说，组合 (‘a’, ‘b’) 跟 (‘b’, ‘a’) 其实是一样的(最终只会输出其中一个)。</p>
<blockquote>
<p>在计算组合的时候，一旦元素被选取就会从候选中剔除掉(比如如果元素’a’已经被选取了，那么接下来就不会再考虑它了)。 而函数 <code>itertools.combinations_with_replacement()</code> 允许同一个元素被选择多次。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations_with_replacement</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> combinations_with_replacement(items, <span class="number">3</span>):</span><br><span class="line">    print(p)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">('a', 'a', 'a')</span></span><br><span class="line"><span class="string">('a', 'a', 'b')</span></span><br><span class="line"><span class="string">('a', 'a', 'c')</span></span><br><span class="line"><span class="string">('a', 'b', 'b')</span></span><br><span class="line"><span class="string">('a', 'b', 'c')</span></span><br><span class="line"><span class="string">('a', 'c', 'c')</span></span><br><span class="line"><span class="string">('b', 'b', 'b')</span></span><br><span class="line"><span class="string">('b', 'b', 'c')</span></span><br><span class="line"><span class="string">('b', 'c', 'c')</span></span><br><span class="line"><span class="string">('c', 'c', 'c')</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><p>在迭代的时候，获得迭代的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(my_list):</span><br><span class="line">    print(idx, val)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0 a</span></span><br><span class="line"><span class="string">1 b</span></span><br><span class="line"><span class="string">2 c</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(my_list, <span class="number">1</span>):</span><br><span class="line">    print(idx, val)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1 a</span></span><br><span class="line"><span class="string">2 b</span></span><br><span class="line"><span class="string">3 c</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果加入一个参数，则会当作索引的开始。这样在例如有错误的时候，就能很快速的定位错误所在。</p>
</blockquote>
<p><code>enumerate()</code> 函数返回的是一个 <code>enumerate</code> 对象实例， 它是一个迭代器，返回连续的包含一个计数和一个值的元组， 元组中的值通过在传入序列上调用 <code>next()</code> 返回。</p>
<blockquote>
<p>还有一点可能并不很重要，但是也值得注意， 有时候在一个已经解压后的元组序列上使用 <code>enumerate()</code> 函数时很容易调入陷阱。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = [ (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n, (x, y) <span class="keyword">in</span> enumerate(data):</span><br><span class="line">    print(n, x, y)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0 1 2</span></span><br><span class="line"><span class="string">1 3 4</span></span><br><span class="line"><span class="string">2 5 6</span></span><br><span class="line"><span class="string">3 7 8</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="同时迭代多个序列"><a href="#同时迭代多个序列" class="headerlink" title="同时迭代多个序列"></a>同时迭代多个序列</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p11_iterate_over_multiple_sequences_simultaneously.html" target="_blank" rel="noopener">同时迭代多个序列</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">xpts = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">7</span>]</span><br><span class="line">ypts = [<span class="number">101</span>, <span class="number">78</span>, <span class="number">37</span>, <span class="number">15</span>, <span class="number">62</span>, <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(xpts, ypts):</span><br><span class="line">    print(x, y)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1 101</span></span><br><span class="line"><span class="string">5 78</span></span><br><span class="line"><span class="string">4 37</span></span><br><span class="line"><span class="string">2 15</span></span><br><span class="line"><span class="string">10 62</span></span><br><span class="line"><span class="string">7 99</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p><code>zip(a, b)</code> 会生成一个可返回元组 (x, y) 的迭代器，其中x来自a，y来自b。 一旦其中某个序列到底结尾，迭代宣告结束。 因此迭代长度跟参数中最短序列长度一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(a, b):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">(1, 'w')</span></span><br><span class="line"><span class="string">(2, 'x')</span></span><br><span class="line"><span class="string">(3, 'y')</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>如果需要以最长的字段输出，可以采用<code>itertools.zip_longest</code>的方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(a, b):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(a, b, fillvalue=<span class="number">0</span>):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(a, b, fillvalue=<span class="string">"asd"</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果没有指定填充值（<code>fillvalue</code>）的话，就会以<code>None</code>的方式代替，可以采用指定<code>fillvalue</code>的方式填充。</p>
</blockquote>
<p>在处理成对的数据的时候，<code>zip</code>会变得很有用，他可以把两个列表编程字典的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line">values = [<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">490.1</span>]</span><br><span class="line"></span><br><span class="line">coll_dict = dict(zip(headers, values))</span><br><span class="line"></span><br><span class="line">print(coll_dict)</span><br><span class="line"><span class="comment"># &#123;'name': 'ACME', 'shares': 100, 'price': 490.1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> h, v <span class="keyword">in</span> zip(headers, values):</span><br><span class="line">    print(h, <span class="string">' = '</span>, v)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，<code>zip</code>可以接收多余两个列表的参数。</p>
</blockquote>
<p> <code>zip()</code> 会创建一个迭代器来作为结果返回。 如果你需要将结对的值存储在列表中，要使用 <code>list()</code> 函数。</p>
<h2 id="itertools-chain"><a href="#itertools-chain" class="headerlink" title="itertools.chain"></a>itertools.chain</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p12_iterate_on_items_in_separate_containers.html" target="_blank" rel="noopener">不同集合上元素的迭代</a></li>
</ul>
<p>这个函数可以让我们在操作几个数列的时候，进行相同操作的时候，使得我们的代码会更加优雅，减少循环的次数，减少多余的代码。</p>
<p>函数<code>itertools.chain</code>可以将所传入的函数连接成链表一样，在操作循环的时候，代码在不失可读性的情况下避免写重复的循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chain(a, b):</span><br><span class="line">    print(i, end=<span class="string">' '</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1 2 3 4 x y z </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>itertools.chain()</code> 接受一个或多个可迭代对象作为输入参数。 然后创建一个迭代器，依次连续的返回每个可迭代对象中的元素。 这种方式要比先将序列合并再迭代要高效的多。</p>
</blockquote>
<p>在使用<code>itertools.chain</code>的时候，会比直接将两个列表进行相加（a + b）这样的操作的效率会更高，这种相加的操作会生成一个新的列表，而使用<code>itertools.chain</code>会将不仅效率更高，对于两个不同对象的列表也能很好的进行操作。</p>
<h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p14_flattening_nested_sequence.html" target="_blank" rel="noopener">展开嵌套的序列</a></li>
</ul>
<blockquote>
<p>将一个多层嵌套的序列展开成一个单层列表</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(items, ignore_types=<span class="params">(str, bytes)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(x, ignore_types):</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> flatten(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>], <span class="number">7</span>], <span class="number">8</span>]</span><br><span class="line"><span class="comment"># Produces 1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> flatten(items):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>
<p>在上面代码中， <code>isinstance(x, Iterable)</code> 检查某个元素是否是可迭代的。 如果是的话， <code>yield from</code> 就会返回所有子例程的值。最终返回结果就是一个没有嵌套的简单序列了。</p>
<blockquote>
<p>在上面代码中， <code>isinstance(x, Iterable)</code> 检查某个元素是否是可迭代的。 如果是的话， <code>yield from</code> 就会返回所有子例程的值。最终返回结果就是一个没有嵌套的简单序列了。</p>
</blockquote>
<p>额外的参数 <code>ignore_types</code> 和检测语句 <code>isinstance(x, ignore_types)</code> 用来将字符串和字节排除在可迭代对象外，防止将它们再展开成单个的字符。 这样的话字符串数组就能最终返回我们所期望的结果了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="string">'Dave'</span>, <span class="string">'Paula'</span>, [<span class="string">'Thomas'</span>, <span class="string">'Lewis'</span>]]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> flatten(items):</span><br><span class="line">    print(x, end=<span class="string">' '</span>)</span><br><span class="line"><span class="comment"># Dave Paula Thomas Lewis</span></span><br></pre></td></tr></table></figure>
<p>语句 yield from 在你想在生成器中调用其他生成器作为子例程的时候非常有用。</p>
<p>如果你不使用它的话，那么就必须写额外的 for 循环了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(items, ignore_types=<span class="params">(str, bytes)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x, Iterable) <span class="keyword">and</span> <span class="keyword">not</span> isinstance(x, ignore_types):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> flatten(x):</span><br><span class="line">                <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后要注意的一点是， <code>yield from</code> 在涉及到基于协程和生成器的并发编程中扮演着更加重要的角色。</p>
</blockquote>
<h2 id="heapq-merge"><a href="#heapq-merge" class="headerlink" title="heapq.merge"></a>heapq.merge</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c04/p15_iterate_in_sorted_order_over_merged_sorted_iterables.html" target="_blank" rel="noopener">顺序迭代合并后的排序迭代对象</a></li>
</ul>
<p>将两个列表合成一个列表，并且排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line">b = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> heapq.merge(a, b):</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>heapq.merge</code> 可迭代特性意味着它不会立马读取所有序列。 这就意味着你可以在非常长的序列中使用它，而不会有太大的开销。</p>
</blockquote>
<p>有一点要强调的是 <code>heapq.merge()</code> 需要所有输入序列必须是排过序的。 特别的，它并不会预先读取所有数据到堆栈中或者预先排序，也不会对输入做任何的排序检测。 它仅仅是检查所有序列的开始部分并返回最小的那个，这个过程一直会持续直到所有输入序列中的元素都被遍历完。</p>
<h2 id="迭代器代替while无限循环"><a href="#迭代器代替while无限循环" class="headerlink" title="迭代器代替while无限循环"></a>迭代器代替while无限循环</h2><p>一般的IO操作可能会用到while循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CHUNKSIZE = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        data = s.recv(CHUNKSIZE)</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">b''</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        process_data(data)</span><br></pre></td></tr></table></figure>
<p>这种代码通常可以使用 <code>iter()</code> 来代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader2</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: s.recv(CHUNKSIZE), <span class="string">b''</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># process_data(data)</span></span><br></pre></td></tr></table></figure>
<p><code>iter</code> 函数一个鲜为人知的特性是它接受一个可选的 <code>callable</code> 对象和一个标记(结尾)值作为输入参数。 当以这种方式使用的时候，它会创建一个迭代器， 这个迭代器会不断调用 <code>callable</code> 对象直到返回值和标记值相等为止。</p>
<blockquote>
<p>这种特殊的方法对于一些特定的会被重复调用的函数很有效果，比如涉及到I/O调用的函数。 举例来讲，如果你想从套接字或文件中以数据块的方式读取数据，通常你得要不断重复的执行 <code>read()</code> 或 <code>recv()</code> ， 并在后面紧跟一个文件结尾测试来决定是否终止。这节中的方案使用一个简单的 <code>iter()</code> 调用就可以将两者结合起来了。 其中 <code>lambda</code> 函数参数是为了创建一个无参的 <code>callable</code> 对象，并为 <code>recv</code> 或 <code>read()</code> 方法提供了 <code>size</code> 参数。</p>
</blockquote>
<h1 id="文件与IO"><a href="#文件与IO" class="headerlink" title="文件与IO"></a>文件与IO</h1><h2 id="读写文本数据"><a href="#读写文本数据" class="headerlink" title="读写文本数据"></a>读写文本数据</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p01_read_write_text_data.html" target="_blank" rel="noopener">读写文本数据</a></li>
</ul>
<p>使用带有 <code>rt</code> 模式的 <code>open()</code> 函数读取文本文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br></pre></td></tr></table></figure>
<p>类似的，为了写入一个文本文件，使用带有 <code>wt</code> 模式的 <code>open()</code> 函数， 如果之前文件内容存在则清除并覆盖掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text1)</span><br><span class="line">    f.write(text2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是在已存在文件中添加内容，使用模式为 <code>at</code> 的 <code>open()</code> 函数。</p>
</blockquote>
<p>文件的读写操作默认使用系统编码，可以通过调用 <code>sys.getdefaultencoding()</code> 来得到。 在大多数机器上面都是utf-8编码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">s = sys.getdefaultencoding()</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># utf-8</span></span><br></pre></td></tr></table></figure>
<p>如果你已经知道你要读写的文本是其他编码方式， 那么可以通过传递一个可选的 encoding 参数给<code>open()</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'latin-1'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python支持非常多的文本编码。几个常见的编码是ascii, latin-1, utf-8和utf-16。 在web应用程序中通常都使用的是UTF-8。 ascii对应从U+0000到U+007F范围内的7位字符。 latin-1是字节0-255到U+0000至U+00FF范围内Unicode字符的直接映射。<br>当读取一个未知编码的文本时使用latin-1编码永远不会产生解码错误。 使用latin-1编码读取一个文件的时候也许不能产生完全正确的文本解码数据， 但是它也能从中提取出足够多的有用数据。同时，如果你之后将数据回写回去，原先的数据还是会保留的。</p>
</blockquote>
<p>读写文本文件一般来讲是比较简单的。但是也几点是需要注意的。 首先，在例子程序中的with语句给被使用到的文件创建了一个上下文环境， 但 with 控制块结束时，文件会自动关闭。你也可以不使用 with 语句，但是这时候你就必须记得手动关闭文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>另外一个问题是关于换行符的识别问题，在Unix和Windows中是不一样的(分别是 \n 和 \r\n )。 默认情况下，Python会以统一模式处理换行符。 这种模式下，在读取文本的时候，Python可以识别所有的普通换行符并将其转换为单个 \n 字符。 类似的，在输出时会将换行符 \n 转换为系统默认的换行符。 如果你不希望这种默认的处理方式，可以给 open() 函数传入参数 newline=’’ ，就像下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read with disabled newline translation</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如果出现编码错误的时候，优先去查看文件的编码，用<code>encoding</code>指定相对应的编码进行文件的读取，如果编码错误还是存在的话，你可以给 <code>open()</code> 函数传递一个可选的 <code>errors</code> 参数来处理这些错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'sample.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'ascii'</span>, errors=<span class="string">'replace'</span>)</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'sample.txt'</span>, <span class="string">'rt'</span>, encoding=<span class="string">'ascii'</span>, errors=<span class="string">'ignore'</span>)</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想用<code>print()</code>函数将结果输入到一个文件中，可以在<code>print</code>函数中指定<code>file</code>的参数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'d:/work/test.txt'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">'Hello World!'</span>, file=f)</span><br></pre></td></tr></table></figure>
<h2 id="sep"><a href="#sep" class="headerlink" title="sep"></a>sep</h2><p>在<code>print</code>函数中指定两个输出的连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(i, i, sep=<span class="string">'+'</span>, end=<span class="string">' '</span>)</span><br><span class="line"><span class="comment"># 0+0 1+1 2+2 3+3 4+4 5+5 6+6 7+7 8+8 9+9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果想要用<code>str.join()</code>的方式连接的话，就应该要注意，这种连接需要在保证输出的内容是字符串，也就是说如果输出内容不是字符串类型的时候，需要多一个步骤去转换。</p>
</blockquote>
<h2 id="读写字节数据"><a href="#读写字节数据" class="headerlink" title="读写字节数据"></a>读写字节数据</h2><p>读写二进制文件，比如图片，声音文件等等，使用模式为 <code>rb</code> 或 <code>wb</code> 的 <code>open()</code> 函数来读取或写入二进制数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">b'Hello World'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在读取二进制数据时，需要指明的是所有返回的数据都是字节字符串格式的，而不是文本字符串。 类似的，在写入的时候，必须保证参数是以字节形式对外暴露数据的对象(比如字节字符串，字节数组对象等)。</p>
</blockquote>
<p>如果你想从二进制模式的文件中读取或写入文本数据，必须确保要进行解码和编码操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read(<span class="number">16</span>)</span><br><span class="line">    text = data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = <span class="string">'Hello World'</span></span><br><span class="line">    f.write(text.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<h2 id="io-StringIO-和-io-BytesIO"><a href="#io-StringIO-和-io-BytesIO" class="headerlink" title="io.StringIO 和 io.BytesIO"></a>io.StringIO 和 io.BytesIO</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p06_io_operations_on_string.html" target="_blank" rel="noopener">字符串的I/O操作</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line">s = io.StringIO()</span><br><span class="line">s.write(<span class="string">'Hello World\n'</span>)</span><br><span class="line">print(<span class="string">'This is a test'</span>, file=s)</span><br><span class="line"></span><br><span class="line">print(s.getvalue())</span><br><span class="line"><span class="comment"># Hello World</span></span><br><span class="line"><span class="comment"># This is a test</span></span><br><span class="line"></span><br><span class="line">s = io.StringIO(<span class="string">'Hello\nWorld\n'</span>)</span><br><span class="line">print(s.read(<span class="number">4</span>))</span><br><span class="line"><span class="comment"># Hell</span></span><br><span class="line">print(s.read())</span><br><span class="line"><span class="comment"># o</span></span><br><span class="line"><span class="comment"># World</span></span><br></pre></td></tr></table></figure>
<p>当你想模拟一个普通的文件的时候 StringIO 和 BytesIO 类是很有用的。 比如，在单元测试中，你可以使用 StringIO 来创建一个包含测试数据的类文件对象， 这个对象可以被传给某个参数为普通文件对象的函数。</p>
<h2 id="gzip-和-bz2"><a href="#gzip-和-bz2" class="headerlink" title="gzip 和 bz2"></a>gzip 和 bz2</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p07_read_write_compressed_datafiles.html" target="_blank" rel="noopener">读写压缩文件</a></li>
</ul>
<p>读写一个gzip或bz2格式的压缩文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取</span></span><br><span class="line"><span class="comment"># gzip compression</span></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.open(<span class="string">'somefile.gz'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># bz2 compression</span></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.open(<span class="string">'somefile.bz2'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    text = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line"><span class="comment"># gzip compression</span></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.open(<span class="string">'somefile.gz'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># bz2 compression</span></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.open(<span class="string">'somefile.bz2'</span>, <span class="string">'wt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当写入压缩数据时，可以使用 compresslevel 这个可选的关键字参数来指定一个压缩级别。</p>
</blockquote>
<h2 id="functools-partial"><a href="#functools-partial" class="headerlink" title="functools.partial"></a>functools.partial</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p08_iterate_over_fixed_sized_records.html" target="_blank" rel="noopener">固定大小记录的文件迭代</a></li>
</ul>
<p>在固定长度记录或者数据块的集合上迭代，而不是在一个文件中一行一行的迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">RECORD_SIZE = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>, <span class="string">'rt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    records = iter(partial(f.read, RECORD_SIZE), <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> records:</span><br><span class="line">        print(r, <span class="string">'\n\n\n'</span>)</span><br></pre></td></tr></table></figure>
<p>这个例子中的 <code>records</code> 对象是一个可迭代对象，它会不断的产生固定大小的数据块，直到文件末尾。 要注意的是如果总记录大小不是块大小的整数倍的话，最后一个返回元素的字节数会比期望值少。</p>
<p><code>iter()</code> 函数有一个鲜为人知的特性就是，如果你给它传递一个可调用对象和一个标记值，它会创建一个迭代器。 这个迭代器会一直调用传入的可调用对象直到它返回标记值为止，这时候迭代终止。</p>
<p>在例子中， <code>functools.partial</code> 用来创建一个每次被调用时从文件中读取固定数目字节的可调用对象。 标记值 “” 就是当到达文件结尾时的返回值。</p>
<p>一般来说，这种读取固定大小的做法对于读取二进制文件来说比较普遍，对于读取文本文件，更多的做法是一行行读取。</p>
<h2 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p11_manipulating_pathnames.html" target="_blank" rel="noopener">文件路径名的操作</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">'/Users/beazley/Data/data.csv'</span></span><br><span class="line">s1 = os.path.basename(path)</span><br><span class="line">print(s1)</span><br><span class="line"><span class="comment"># data.csv</span></span><br><span class="line">s2 = os.path.dirname(path)</span><br><span class="line">print(s2)</span><br><span class="line"><span class="comment"># /Users/beazley/Data</span></span><br><span class="line">s3 = os.path.join(<span class="string">'tmp'</span>, <span class="string">'data'</span>, os.path.basename(path))</span><br><span class="line">print(s3)</span><br><span class="line"><span class="comment"># tmp/data/data.csv</span></span><br><span class="line">path = <span class="string">'~/Data/data.csv'</span></span><br><span class="line">s4 = os.path.expanduser(path)</span><br><span class="line">print(s4)</span><br><span class="line"><span class="comment"># /Users/apple/Data/data.csv</span></span><br><span class="line">s5 = os.path.splitext(path)</span><br><span class="line">print(s5)</span><br><span class="line"><span class="comment"># ('~/Data/data', '.csv')</span></span><br></pre></td></tr></table></figure>
<p>对于任何的文件名的操作，你都应该使用 <code>os.path</code> 模块，而不是使用标准字符串操作来构造自己的代码。 特别是为了可移植性考虑的时候更应如此， 因为 <code>os.path</code> 模块知道<strong>Unix</strong>和<strong>Windows</strong>系统之间的差异并且能够可靠地处理类似 <code>Data/data.csv</code> 和 <code>Data\data.csv</code> 这样的文件名。 其次，你真的不应该浪费时间去重复造轮子。通常最好是直接使用已经为你准备好的功能。</p>
<p>测试一个文件或目录是否存在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.exists(<span class="string">'/tmp/spam'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Is a regular file</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Is a directory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Is a symbolic link</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.islink(<span class="string">'/usr/local/bin/python3'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Get the file linked to</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.realpath(<span class="string">'/usr/local/bin/python3'</span>)</span><br><span class="line"><span class="string">'/usr/local/bin/python3.3'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getsize(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="number">3669</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.getmtime(<span class="string">'/etc/passwd'</span>)</span><br><span class="line"><span class="number">1272478234.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime(os.path.getmtime(<span class="string">'/etc/passwd'</span>))</span><br><span class="line"><span class="string">'Wed Apr 28 13:10:34 2010'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="os-listdir"><a href="#os-listdir" class="headerlink" title="os.listdir"></a>os.listdir</h2><p>获取文件系统中某个目录下的所有文件列表。</p>
<p>使用 <code>os.listdir()</code> 函数来获取某个目录中的文件列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">names = os.listdir(<span class="string">'somedir'</span>)</span><br></pre></td></tr></table></figure>
<p>结果会返回目录中所有文件列表，包括所有文件，子目录，符号链接等等。 如果你需要通过某种方式过滤数据，可以考虑结合 os.path 库中的一些函数来使用列表推导。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all regular files</span></span><br><span class="line">names = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(os.path.join(<span class="string">'somedir'</span>, name))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all dirs</span></span><br><span class="line">dirnames = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(<span class="string">'somedir'</span>, name))]</span><br></pre></td></tr></table></figure>
<p>字符串的 <code>startswith()</code> 和 <code>endswith()</code> 方法对于过滤一个目录的内容也是很有用的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyfiles = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line">            <span class="keyword">if</span> name.endswith(<span class="string">'.py'</span>)]</span><br></pre></td></tr></table></figure>
<p>文件名的匹配，也可以考虑用 <code>glob</code> 或者 <code>fnmatch</code> 模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">pyfiles = glob.glob(<span class="string">'somedir/*.py'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fnmatch <span class="keyword">import</span> fnmatch</span><br><span class="line">pyfiles = [name <span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(<span class="string">'somedir'</span>)</span><br><span class="line">            <span class="keyword">if</span> fnmatch(name, <span class="string">'*.py'</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="tempfile"><a href="#tempfile" class="headerlink" title="tempfile"></a>tempfile</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p19_make_temporary_files_and_directories.html" target="_blank" rel="noopener">创建临时文件和文件夹</a></li>
</ul>
<p>用于创建一个临时的文件或文件夹。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryFile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">'w+t'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># Read/write to the file</span></span><br><span class="line">    f.write(<span class="string">'Hello World\n'</span>)</span><br><span class="line">    f.write(<span class="string">'Testing\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Seek back to beginning and read the data</span></span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Temporary file is destroyed</span></span><br></pre></td></tr></table></figure>
<p><code>TemporaryFile()</code> 的第一个参数是文件模式，通常来讲文本模式使用 <strong>w+t</strong> ，二进制模式使用 <strong>w+b</strong> 。 这个模式同时支持读和写操作，在这里是很有用的，因为当你关闭文件去改变模式的时候，文件实际上已经不存在了。</p>
<p><code>TemporaryFile()</code> 另外还支持跟内置的 open() 函数一样的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> TemporaryFile(<span class="string">'w+t'</span>, encoding=<span class="string">'utf-8'</span>, errors=<span class="string">'ignore'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>为了创建一个临时目录，可以使用 <code>tempfile.TemporaryDirectory()</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> TemporaryDirectory</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TemporaryDirectory() <span class="keyword">as</span> dirname:</span><br><span class="line">    print(<span class="string">'dirname is:'</span>, dirname)</span><br><span class="line">    <span class="comment"># Use the directory</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment"># Directory and all contents destroyed</span></span><br></pre></td></tr></table></figure>
<h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p21_serializing_python_objects.html" target="_blank" rel="noopener">序列化Python对象</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">data = person(<span class="number">12</span>)</span><br><span class="line">f = open(<span class="string">'data_file'</span>, <span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(data, f)</span><br></pre></td></tr></table></figure>
<p>如果要将对象转为字符串，可以使用 <code>pickle.dumps()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pickle.dumps(data)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>为了从字节流中恢复一个对象，使用 <code>pickle.load()</code> 或 <code>pickle.loads()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Restore from a file</span></span><br><span class="line">f = open(<span class="string">'somefile'</span>, <span class="string">'rb'</span>)</span><br><span class="line">data = pickle.load(f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restore from a string</span></span><br><span class="line">data = pickle.loads(s)</span><br></pre></td></tr></table></figure>
<p>对于大多数应用程序来讲，<code>dump()</code> 和 <code>load()</code> 函数的使用就是你有效使用 <code>pickle</code> 模块所需的全部了。 它可适用于绝大部分Python数据类型和用户自定义类的对象实例。 如果你碰到某个库可以让你在数据库中保存/恢复Python对象或者是通过网络传输对象的话， 那么很有可能这个库的底层就使用了 pickle 模块。</p>
<p><code>pickle</code> 是一种Python特有的自描述的数据编码。 通过自描述，被序列化后的数据包含每个对象开始和结束以及它的类型信息。 因此，你无需担心对象记录的定义，它总是能工作。</p>
<p>当数据反序列化回来的时候，会先假定所有的源数据时可用的。 模块、类和函数会自动按需导入进来。对于Python数据被不同机器上的解析器所共享的应用程序而言， 数据的保存可能会有问题，因为所有的机器都必须访问同一个源代码。</p>
<blockquote>
<p>千万不要对不信任的数据使用<code>pickle.load()</code>。<strong>pickle</strong>在加载时有一个副作用就是它会自动加载相应模块并构造实例对象。但是某个坏人如果知道<strong>pickle</strong>的工作原理，他就可以创建一个恶意的数据导致Python执行随意指定的系统命令。因此，一定要保证<strong>pickle</strong>只在相互之间可以认证对方的解析器的内部使用。</p>
</blockquote>
<p>有些类型的对象是不能被序列化的。这些通常是那些依赖外部系统状态的对象， 比如打开的文件，网络连接，线程，进程，栈帧等等。 用户自定义类可以通过提供 <code>__getstate__()</code> 和 <code>__setstate__()</code> 方法来绕过这些限制。 如果定义了这两个方法，<code>pickle.dump()</code> 就会调用 <code>__getstate__()</code> 获取序列化的对象。 类似的，<code>__setstate__()</code> 在反序列化时被调用。</p>
<p><strong>pickle</strong> 对于大型的数据结构比如使用 <strong>array</strong> 或 <strong>numpy</strong> 模块创建的二进制数组效率并不是一个高效的编码方式。 如果你需要移动大量的数组数据，你最好是先在一个文件中将其保存为数组数据块或使用更高级的标准编码方式如HDF5 (需要第三方库的支持)。</p>
<p>由于 <strong>pickle</strong> 是Python特有的并且附着在源码上，所有如果需要长期存储数据的时候不应该选用它。 例如，如果源码变动了，你所有的存储数据可能会被破坏并且变得不可读取。 坦白来讲，对于在数据库和存档文件中存储数据时，你最好使用更加标准的数据编码格式如XML，CSV或JSON。 这些编码格式更标准，可以被不同的语言支持，并且也能很好的适应源码变更。</p>
<p>最后一点要注意的是 <strong>pickle</strong> 有大量的配置选项和一些棘手的问题。 对于最常见的使用场景，你不需要去担心这个，但是如果你要在一个重要的程序中使用pickle去做序列化的话， 最好去查阅一下 <a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="noopener">官方文档</a> 。</p>
<h1 id="数据编码和处理"><a href="#数据编码和处理" class="headerlink" title="数据编码和处理"></a>数据编码和处理</h1><h2 id="csv"><a href="#csv" class="headerlink" title="csv"></a>csv</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p01_read_write_csv_data.html" target="_blank" rel="noopener">读写CSV数据</a></li>
</ul>
<p>csv 文件可以看成是逗号分隔文件（逗号分隔值文件格式），里面的数据会以纯文本形式存储表格数据（数字和文本）。当然也不一定要用逗号，也可以用别的字符进行分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol,Price,Date,Time,Change,Volume</span><br><span class="line">&quot;AA&quot;,39.48,&quot;6/11/2007&quot;,&quot;9:36am&quot;,-0.18,181800</span><br><span class="line">&quot;AIG&quot;,71.38,&quot;6/11/2007&quot;,&quot;9:36am&quot;,-0.15,195500</span><br><span class="line">&quot;AXP&quot;,62.58,&quot;6/11/2007&quot;,&quot;9:36am&quot;,-0.46,935000</span><br><span class="line">&quot;BA&quot;,98.31,&quot;6/11/2007&quot;,&quot;9:36am&quot;,+0.12,104800</span><br><span class="line">&quot;C&quot;,53.08,&quot;6/11/2007&quot;,&quot;9:36am&quot;,-0.25,360900</span><br><span class="line">&quot;CAT&quot;,78.29,&quot;6/11/2007&quot;,&quot;9:36am&quot;,-0.23,225400</span><br></pre></td></tr></table></figure>
<p>通过<code>csv</code>模块，可以将csv文件逐行读取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'csv_file.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    print(headers)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure>
<p>但是为了更好的理解所获得值，可以使用<code>namedtuple</code>的方式，使用命名元组的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'csv_file.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.reader(f)</span><br><span class="line">    headers = next(f_csv)</span><br><span class="line">    Row = namedtuple(<span class="string">'Row'</span>, headers)</span><br><span class="line">    print(headers)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> f_csv:</span><br><span class="line">        row = Row(*r)</span><br><span class="line">        print(row)</span><br></pre></td></tr></table></figure>
<p>它允许你使用列名如 <code>row.Symbol</code> 和 <code>row.Change</code> 代替下标访问。 需要注意的是这个只有在列名是合法的Python标识符的时候才生效。如果不是的话， 你可能需要修改下原始的列名(如将非标识符字符替换成下划线之类的)。</p>
<p>另外一个选择就是将数据读取到一个字典序列中去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'csv_file.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictReader(f)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_csv:</span><br><span class="line">        print(row[<span class="string">'Price'</span>])</span><br></pre></td></tr></table></figure>
<p>这样就可以直接使用字典的名字去访问字段。例如：<code>row[&#39;Symbol&#39;]</code> 或者 <code>row[&#39;Change&#39;]</code></p>
<p>如果要写入，也可以直接使用这个模块。</p>
<p>不过这时候先创建一个 writer 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">'Symbol'</span>,<span class="string">'Price'</span>,<span class="string">'Date'</span>,<span class="string">'Time'</span>,<span class="string">'Change'</span>,<span class="string">'Volume'</span>]</span><br><span class="line">rows = [(<span class="string">'AA'</span>, <span class="number">39.48</span>, <span class="string">'6/11/2007'</span>, <span class="string">'9:36am'</span>, <span class="number">-0.18</span>, <span class="number">181800</span>),</span><br><span class="line">         (<span class="string">'AIG'</span>, <span class="number">71.38</span>, <span class="string">'6/11/2007'</span>, <span class="string">'9:36am'</span>, <span class="number">-0.15</span>, <span class="number">195500</span>),</span><br><span class="line">         (<span class="string">'AXP'</span>, <span class="number">62.58</span>, <span class="string">'6/11/2007'</span>, <span class="string">'9:36am'</span>, <span class="number">-0.46</span>, <span class="number">935000</span>),</span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.writer(f)</span><br><span class="line">    f_csv.writerow(headers)</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure>
<p>如果有一个字典序列的数据，可以直接使用<code>csv.DictWriter</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">'Symbol'</span>, <span class="string">'Price'</span>, <span class="string">'Date'</span>, <span class="string">'Time'</span>, <span class="string">'Change'</span>, <span class="string">'Volume'</span>]</span><br><span class="line">rows = [&#123;<span class="string">'Symbol'</span>:<span class="string">'AA'</span>, <span class="string">'Price'</span>:<span class="number">39.48</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:<span class="number">-0.18</span>, <span class="string">'Volume'</span>:<span class="number">181800</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AIG'</span>, <span class="string">'Price'</span>: <span class="number">71.38</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:<span class="number">-0.15</span>, <span class="string">'Volume'</span>: <span class="number">195500</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'Symbol'</span>:<span class="string">'AXP'</span>, <span class="string">'Price'</span>: <span class="number">62.58</span>, <span class="string">'Date'</span>:<span class="string">'6/11/2007'</span>,</span><br><span class="line">        <span class="string">'Time'</span>:<span class="string">'9:36am'</span>, <span class="string">'Change'</span>:<span class="number">-0.46</span>, <span class="string">'Volume'</span>: <span class="number">935000</span>&#125;,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stocks.csv'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_csv = csv.DictWriter(f, headers)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    f_csv.writerows(rows)</span><br></pre></td></tr></table></figure>
<p>默认情况下，csv 库可识别Microsoft Excel所使用的CSV编码规则。 这或许也是最常见的形式，并且也会给你带来最好的兼容性。 然而，如果你查看csv的文档，就会发现有很多种方法将它应用到其他编码格式上(如修改分割字符等)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example of reading tab-separated values</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'stock.tsv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_tsv = csv.reader(f, delimiter=<span class="string">'\t'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> f_tsv:</span><br><span class="line">        <span class="comment"># Process row</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后，如果你读取CSV数据的目的是做数据分析和统计的话， 你可能需要看一看 Pandas 包。Pandas 包含了一个非常方便的函数叫 <code>pandas.read_csv()</code> ， 它可以加载CSV数据到一个 DataFrame 对象中去。 然后利用这个对象你就可以生成各种形式的统计、过滤数据以及执行其他高级操作了。</p>
</blockquote>
<h2 id="读写JSON数据"><a href="#读写JSON数据" class="headerlink" title="读写JSON数据"></a>读写JSON数据</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html" target="_blank" rel="noopener">读写JSON数据</a></li>
</ul>
<p><code>json.dumps()</code> 和 <code>json.loads()</code> 处理字符串的转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'name'</span> : <span class="string">'ACME'</span>,</span><br><span class="line">    <span class="string">'shares'</span> : <span class="number">100</span>,</span><br><span class="line">    <span class="string">'price'</span> : <span class="number">542.23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json_str = json.dumps(data)</span><br><span class="line"></span><br><span class="line">data = json.loads(json_str)</span><br></pre></td></tr></table></figure>
<p><code>json.dump()</code> 和 <code>json.load()</code> 处理文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Writing JSON data</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(data, f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading data back</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br></pre></td></tr></table></figure>
<p>JSON编码支持的基本数据类型为 <code>None</code> ， <code>bool</code> ， <code>int</code> ， <code>float</code> 和 <code>str</code> ， 以及包含这些类型数据的lists，tuples和dictionaries。 对于dictionaries，keys需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。 为了遵循JSON规范，你应该只编码Python的<strong>lists</strong>和<strong>dictionaries</strong>。 而且，在web应用程序中，顶层对象被编码为一个字典是一个标准做法。</p>
<blockquote>
<p>JSON编码的格式对于Python语法而已几乎是完全一样的，除了一些小的差异之外。 比如，True会被映射为true，False被映射为false，而None会被映射为null。</p>
</blockquote>
<p>如果你试着去检查JSON解码后的数据，你通常很难通过简单的打印来确定它的结构， 特别是当数据的嵌套结构层次很深或者包含大量的字段时。 为了解决这个问题，可以考虑使用pprint模块的 <code>pprint()</code> 函数来代替普通的 <code>print()</code> 函数。 它会按照key的字母顺序并以一种更加美观的方式输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = urlopen(<span class="string">'http://search.twitter.com/search.json?q=python&amp;rpp=5'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>resp = json.loads(u.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint(resp)</span><br><span class="line">&#123;<span class="string">'completed_in'</span>: <span class="number">0.074</span>,</span><br><span class="line"><span class="string">'max_id'</span>: <span class="number">264043230692245504</span>,</span><br><span class="line"><span class="string">'max_id_str'</span>: <span class="string">'264043230692245504'</span>,</span><br><span class="line"><span class="string">'next_page'</span>: <span class="string">'?page=2&amp;max_id=264043230692245504&amp;q=python&amp;rpp=5'</span>,</span><br><span class="line"><span class="string">'page'</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">'query'</span>: <span class="string">'python'</span>,</span><br><span class="line"><span class="string">'refresh_url'</span>: <span class="string">'?since_id=264043230692245504&amp;q=python'</span>,</span><br><span class="line"><span class="string">'results'</span>: [&#123;<span class="string">'created_at'</span>: <span class="string">'Thu, 01 Nov 2012 16:36:26 +0000'</span>,</span><br><span class="line">            <span class="string">'from_user'</span>: ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;<span class="string">'created_at'</span>: <span class="string">'Thu, 01 Nov 2012 16:36:14 +0000'</span>,</span><br><span class="line">            <span class="string">'from_user'</span>: ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;<span class="string">'created_at'</span>: <span class="string">'Thu, 01 Nov 2012 16:36:13 +0000'</span>,</span><br><span class="line">            <span class="string">'from_user'</span>: ...</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;<span class="string">'created_at'</span>: <span class="string">'Thu, 01 Nov 2012 16:36:07 +0000'</span>,</span><br><span class="line">            <span class="string">'from_user'</span>: ...</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;<span class="string">'created_at'</span>: <span class="string">'Thu, 01 Nov 2012 16:36:04 +0000'</span>,</span><br><span class="line">            <span class="string">'from_user'</span>: ...</span><br><span class="line">            &#125;],</span><br><span class="line"><span class="string">'results_per_page'</span>: <span class="number">5</span>,</span><br><span class="line"><span class="string">'since_id'</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">'since_id_str'</span>: <span class="string">'0'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>一般来讲，JSON解码会根据提供的数据创建dicts或lists。 如果你想要创建其他类型的对象，可以给 json.loads() 传递object_pairs_hook或object_hook参数。 例如，下面是演示如何解码JSON数据并在一个OrderedDict中保留其顺序的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'&#123;"name": "ACME", "shares": 50, "price": 490.1&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = json.loads(s, object_pairs_hook=OrderedDict)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data</span><br><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'ACME'</span>), (<span class="string">'shares'</span>, <span class="number">50</span>), (<span class="string">'price'</span>, <span class="number">490.1</span>)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>将一个JSON字典转换为一个Python对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">JSONObject</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.__dict__ = d</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = json.loads(s, object_hook=JSONObject)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.shares</span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.price</span><br><span class="line"><span class="number">490.1</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在编码JSON的时候，还有一些选项很有用。 如果你想获得漂亮的格式化字符串后输出，可以使用 json.dumps() 的indent参数。 它会使得输出和pprint()函数效果类似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data))</span><br><span class="line">&#123;<span class="string">"price"</span>: <span class="number">542.23</span>, <span class="string">"name"</span>: <span class="string">"ACME"</span>, <span class="string">"shares"</span>: <span class="number">100</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(data, indent=<span class="number">4</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"price"</span>: <span class="number">542.23</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ACME"</span>,</span><br><span class="line">    <span class="string">"shares"</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>一般来说，对象实例通常并不是JSON可序列化的。但是，可以提供一个函数，它的输入是一个实例，返回一个可序列化的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize_instance</span><span class="params">(obj)</span>:</span></span><br><span class="line">    d = &#123; <span class="string">'__classname__'</span> : type(obj).__name__ &#125;</span><br><span class="line">    d.update(vars(obj))</span><br><span class="line">    <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<p>如果你想反过来获取这个实例，可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dictionary mapping names to known classes</span></span><br><span class="line">classes = &#123;</span><br><span class="line">    <span class="string">'Point'</span> : Point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unserialize_object</span><span class="params">(d)</span>:</span></span><br><span class="line">    clsname = d.pop(<span class="string">'__classname__'</span>, <span class="keyword">None</span>)</span><br><span class="line">    <span class="keyword">if</span> clsname:</span><br><span class="line">        cls = classes[clsname]</span><br><span class="line">        obj = cls.__new__(cls) <span class="comment"># Make instance without calling __init__</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            setattr(obj, key, value)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> d</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Point(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = json.dumps(p, default=serialize_instance)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'&#123;"__classname__": "Point", "y": 3, "x": 2&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = json.loads(s, object_hook=unserialize_object)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;__main__.Point object at <span class="number">0x1017577d0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.x</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.y</span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="xml-etree-ElementTree"><a href="#xml-etree-ElementTree" class="headerlink" title="xml.etree.ElementTree"></a>xml.etree.ElementTree</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p03_parse_simple_xml_data.html" target="_blank" rel="noopener">解析简单的XML数据</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download the RSS feed and parse it</span></span><br><span class="line">u = urlopen(<span class="string">'http://planet.python.org/rss20.xml'</span>)</span><br><span class="line">doc = parse(u)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract and output tags of interest</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> doc.iterfind(<span class="string">'channel/item'</span>):</span><br><span class="line">    title = item.findtext(<span class="string">'title'</span>)</span><br><span class="line">    date = item.findtext(<span class="string">'pubDate'</span>)</span><br><span class="line">    link = item.findtext(<span class="string">'link'</span>)</span><br><span class="line"></span><br><span class="line">    print(title)</span><br><span class="line">    print(date)</span><br><span class="line">    print(link)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>
<p><code>xml.etree.ElementTree.parse()</code> 函数解析整个XML文档并将其转换成一个文档对象。 然后，你就能使用 <code>find()</code> 、<code>iterfind()</code> 和 <code>findtext()</code> 等方法来搜索特定的XML元素了。 这些函数的参数就是某个指定的标签名，例如 <code>channel/item</code> 或 <code>title</code> 。</p>
<p>每次指定某个标签时，你需要遍历整个文档结构。每次搜索操作会从一个起始元素开始进行。 同样，每次操作所指定的标签名也是起始元素的相对路径。 例如，执行 <code>doc.iterfind(&#39;channel/item&#39;)</code> 来搜索所有在 <strong>channel</strong> 元素下面的 <strong>item</strong> 元素。 <strong>doc</strong> 代表文档的最顶层(也就是第一级的 <strong>rss</strong> 元素)。 然后接下来的调用 <code>item.findtext()</code> 会从已找到的 <strong>item</strong> 元素位置开始搜索。</p>
<p>ElementTree 模块中的每个元素有一些重要的属性和方法，在解析的时候非常有用。 <code>tag</code> 属性包含了标签的名字，<code>text</code> 属性包含了内部的文本，而 <code>get()</code> 方法能获取属性值。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p04_parse_huge_xml_files_incrementally.html" target="_blank" rel="noopener">增量式解析大型XML文件</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> iterparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_and_remove</span><span class="params">(filename, path)</span>:</span></span><br><span class="line">    path_parts = path.split(<span class="string">'/'</span>)</span><br><span class="line">    doc = iterparse(filename, (<span class="string">'start'</span>, <span class="string">'end'</span>))</span><br><span class="line">    <span class="comment"># Skip the root element</span></span><br><span class="line">    next(doc)</span><br><span class="line"></span><br><span class="line">    tag_stack = []</span><br><span class="line">    elem_stack = []</span><br><span class="line">    <span class="keyword">for</span> event, elem <span class="keyword">in</span> doc:</span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">'start'</span>:</span><br><span class="line">            tag_stack.append(elem.tag)</span><br><span class="line">            elem_stack.append(elem)</span><br><span class="line">        <span class="keyword">elif</span> event == <span class="string">'end'</span>:</span><br><span class="line">            <span class="keyword">if</span> tag_stack == path_parts:</span><br><span class="line">                <span class="keyword">yield</span> elem</span><br><span class="line">                elem_stack[<span class="number">-2</span>].remove(elem)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                tag_stack.pop()</span><br><span class="line">                elem_stack.pop()</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一节的技术会依赖 ElementTree 模块中的两个核心功能。 第一，<code>iterparse()</code> 方法允许对XML文档进行增量操作。 使用时，你需要提供文件名和一个包含下面一种或多种类型的事件列表： <strong>start</strong> , <strong>end</strong>, <strong>start-ns</strong> 和 <strong>end-ns</strong> 。 由 <code>iterparse()</code> 创建的迭代器会产生形如 <code>(event, elem)</code> 的元组， 其中 event 是上述事件列表中的某一个，而 elem 是相应的XML元素。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pothole_by_zip = Counter()</span><br><span class="line"></span><br><span class="line">doc = parse(<span class="string">'potholes.xml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pothole <span class="keyword">in</span> doc.iterfind(<span class="string">'row/row'</span>):</span><br><span class="line">    pothole_by_zip[pothole.findtext(<span class="string">'zip'</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> zipcode, num <span class="keyword">in</span> pothole_by_zip.most_common():</span><br><span class="line">    print(zipcode, num)</span><br></pre></td></tr></table></figure>
<p>使用这个方式的话（<code>doc.iterfind</code>），会将<code>xml</code>文件一次性全部读取出来，先将整个XML文件加载到内存中然后解析，这样会大量使用内存的资源。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = parse_and_remove(<span class="string">'potholes.xml'</span>, <span class="string">'row/row'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pothole <span class="keyword">in</span> data:</span><br><span class="line">    pothole_by_zip[pothole.findtext(<span class="string">'zip'</span>)] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> zipcode, num <span class="keyword">in</span> pothole_by_zip.most_common():</span><br><span class="line">    print(zipcode, num)</span><br></pre></td></tr></table></figure>
<p>这里调用了上面的函数 ，在队列中的保存找到的<strong>tag</strong>，之后在获得需要的标签后，就将结果返回，同时将结果删除（就是删除掉对应的标签），这样就能保证内存不会溢出，能保证系统在占用很小的内存的时候就能找到所需要的数据。</p>
<p><code>start</code> 事件在某个元素第一次被创建并且还没有被插入其他数据(如子元素)时被创建。 而 <code>end</code> 事件在某个元素已经完成时被创建。 尽管没有在例子中演示， <code>start-ns</code> 和 <code>end-ns</code> 事件被用来处理XML文档命名空间的声明。</p>
<p><code>start</code> 和 <code>end</code> 事件被用来管理元素和标签栈。 栈代表了文档被解析时的层次结构， 还被用来判断某个元素是否匹配传给函数 <code>parse_and_remove()</code> 的路径。 如果匹配，就利用 yield 语句向调用者返回这个元素。</p>
<p>比较这两个版本，可以看出，第一个全部读取完的版本会比较占用内存，不过在效率上能得到很大的提高，如果更加注重内存的消耗，应该优先选择第二个版本，采用增量式的方式获得需要的节点。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p05_turning_dictionary_into_xml.html" target="_blank" rel="noopener">将字典转换为XML</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> Element</span><br><span class="line"><span class="keyword">from</span> xml.etree.ElementTree <span class="keyword">import</span> tostring</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dict_to_xlm</span><span class="params">(tag, d)</span>:</span></span><br><span class="line">    elem = Element(tag)</span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> d.items():</span><br><span class="line">        child = Element(key)</span><br><span class="line">        child.text = str(val)</span><br><span class="line">        elem.append(child)</span><br><span class="line">    <span class="keyword">return</span> elem</span><br><span class="line"></span><br><span class="line">s = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'GGO'</span>,</span><br><span class="line">    <span class="string">'status'</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">'count'</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e = dict_to_xlm(<span class="string">'stock'</span>, s)</span><br><span class="line">print(e)</span><br><span class="line"><span class="comment"># &lt;Element 'stock' at 0x10400eb88&gt;</span></span><br><span class="line">string_stocks = tostring(e)</span><br><span class="line">print(string_stocks)</span><br><span class="line"><span class="comment"># b'&lt;stock&gt;&lt;name&gt;GGO&lt;/name&gt;&lt;status&gt;100&lt;/status&gt;&lt;count&gt;12&lt;/count&gt;&lt;/stock&gt;'</span></span><br><span class="line"></span><br><span class="line">e.set(<span class="string">'_id'</span>, <span class="string">'123456'</span>)</span><br><span class="line">string_stocks = tostring(e)</span><br><span class="line">print(string_stocks)</span><br><span class="line"><span class="comment"># b'&lt;stock _id="123456"&gt;&lt;name&gt;GGO&lt;/name&gt;&lt;status&gt;100&lt;/status&gt;&lt;count&gt;12&lt;/count&gt;&lt;/stock&gt;'</span></span><br></pre></td></tr></table></figure>
<p>通过<code>Element</code>可以将元素设置为<code>tag</code>，之后用<code>child.text</code>的方法设置该标签的内容，这样就能获得一个<code>Element</code>元素，之后通过<code>tostring</code>函数，将<code>Element</code>转为字符串。</p>
<p>也可以通过<code>set</code>函数为某个元素添加属性值。</p>
<p>如果传入的内容中有特殊字符，会自动进行转译，例如：字符 ‘&lt;’ 和 ‘&gt;’ 被替换成了 <code>&amp;lt;</code> 和 <code>&amp;gt;</code>。</p>
<p>如果你需要手动去转换这些字符， 可以使用 xml.sax.saxutils 中的 escape() 和 unescape() 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> xml.sax.saxutils <span class="keyword">import</span> escape, unescape</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>escape(<span class="string">'&lt;spam&gt;'</span>)</span><br><span class="line"><span class="string">'&amp;lt;spam&amp;gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unescape(_)</span><br><span class="line"><span class="string">'&lt;spam&gt;'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p06_parse_modify_rewrite_xml.html" target="_blank" rel="noopener">解析和修改XML</a></li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p07_parse_xml_documents_with_namespaces.html" target="_blank" rel="noopener">利用命名空间解析XML文档</a></li>
</ul>
<h2 id="与关系型数据库的交互"><a href="#与关系型数据库的交互" class="headerlink" title="与关系型数据库的交互"></a><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p08_interact_with_relational_database.html" target="_blank" rel="noopener">与关系型数据库的交互</a></h2><p>SQL语句字符串的构造。 你千万不要使用Python字符串格式化操作符(如%)或者 <code>.format()</code> 方法来创建这样的字符串。 如果传递给这些格式化操作符的值来自于用户的输入，那么你的程序就很有可能遭受SQL注入攻击(参考 <a href="http://xkcd.com/327" target="_blank" rel="noopener">http://xkcd.com/327</a> )。 查询语句中的通配符 ? 指示后台数据库使用它自己的字符串替换机制，这样更加的安全。</p>
<p>不幸的是，不同的数据库后台对于通配符的使用是不一样的。大部分模块使用 <code>?</code> 或 <code>%s</code> ， 还有其他一些使用了不同的符号，比如:0或:1来指示参数。 同样的，你还是得去参考你使用的数据库模块相应的文档。 一个数据库模块的 <code>paramstyle</code> 属性包含了参数引用风格的信息。</p>
<h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p09_decode_encode_hexadecimal_digits.html" target="_blank" rel="noopener">编码和解码十六进制数</a></li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p10_decode_encode_base64.html" target="_blank" rel="noopener">编码解码Base64数据</a></li>
</ul>
<p>简单的解码或编码一个十六进制的原始字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">s = <span class="string">b'hello'</span></span><br><span class="line"></span><br><span class="line">h = base64.b16encode(s)</span><br><span class="line">print(h)</span><br><span class="line"><span class="comment"># b'68656C6C6F'</span></span><br><span class="line">b = base64.b64encode(s)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># b'aGVsbG8='</span></span><br><span class="line"></span><br><span class="line">n = base64.b16decode(h)</span><br><span class="line">print(n)</span><br><span class="line"><span class="comment"># b'hello'</span></span><br><span class="line">m = base64.b64decode(b)</span><br><span class="line">print(m)</span><br><span class="line"><span class="comment"># b'hello'</span></span><br></pre></td></tr></table></figure>
<h2 id="读取嵌套和可变长二进制数据"><a href="#读取嵌套和可变长二进制数据" class="headerlink" title="读取嵌套和可变长二进制数据"></a><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p12_read_nested_and_variable_sized_binary_structures.html" target="_blank" rel="noopener">读取嵌套和可变长二进制数据</a></h2><p>二进制数据文件处理</p>
<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><p>对于任何涉及到统计、时间序列以及其他相关技术的数据分析问题，都可以考虑使用 Pandas库 。</p>
<p>Pandas是一个拥有很多特性的大型函数库，我在这里不可能介绍完。 但是只要你需要去分析大型数据集合、对数据分组、计算各种统计量或其他类似任务的话，这个函数库真的值得你去看一看。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="接受任意数量参数的函"><a href="#接受任意数量参数的函" class="headerlink" title="接受任意数量参数的函"></a>接受任意数量参数的函</h2><p>接收任意参数用<code>*</code>， 接收任意关键字参数用<code>**</code></p>
<blockquote>
<p>一个<em>参数只能出现在函数定义中最后一个位置参数后面，而 **参数只能出现在最后一个参数。 有一点要注意的是，在</em>参数后面仍然可以定义其他参数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">(x, *args, y)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">(x, *args, y, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p02_functions_that_only_accept_keyword_arguments.html" target="_blank" rel="noopener">只接受关键字参数的函数</a></li>
</ul>
<p>将强制关键字参数放到某个<code>*</code>参数或者单个<code>*</code>后面就能达到这种效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(maxsize, *, block)</span>:</span></span><br><span class="line">    <span class="string">'Receives a message'</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">recv(<span class="number">1024</span>, <span class="keyword">True</span>) <span class="comment"># TypeError</span></span><br><span class="line">recv(<span class="number">1024</span>, block=<span class="keyword">True</span>) <span class="comment"># Ok</span></span><br></pre></td></tr></table></figure>
<p>我们可以在接受任意参数的函数中接受指定的关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mininum</span><span class="params">(*values, clip=None)</span>:</span></span><br><span class="line">    m = min(values)</span><br><span class="line">    <span class="keyword">if</span> clip <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        m = clip <span class="keyword">if</span> clip &gt; m <span class="keyword">else</span> m</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">minimum(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">-5</span>, <span class="number">10</span>) <span class="comment"># Returns -5</span></span><br><span class="line">minimum(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">-5</span>, <span class="number">10</span>, clip=<span class="number">0</span>) <span class="comment"># Returns 0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>很多情况下，使用强制关键字参数会比使用位置参数表意更加清晰，程序也更加具有可读性。</p>
</blockquote>
<p>这样在使用<code>help</code>的时候也会使得函数更容易理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">help(recv)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Help on function recv in module __main__:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">recv(maxsize, *, block)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<h2 id="给函数参数增加元信息"><a href="#给函数参数增加元信息" class="headerlink" title="给函数参数增加元信息"></a>给函数参数增加元信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>python解释器不会对这些注解添加任何的语义。它们不会被类型检查，运行时跟没有加注解之前的效果也没有任何差距。 然而，对于那些阅读源码的人来讲就很有帮助啦。第三方工具和框架可能会对这些注解添加语义。同时它们也会出现在文档中。</p>
<blockquote>
<p>尽管你可以使用任意类型的对象给函数添加注解(例如数字，字符串，对象实例等等)，不过通常来讲使用类或者字符串会比较好点。</p>
</blockquote>
<p>函数注解只存储在函数的 <code>__annotations__</code> 属性中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(adda.__annotations__)</span><br><span class="line"><span class="comment"># &#123;'x': &lt;class 'int'&gt;, 'y': &lt;class 'int'&gt;, 'return': &lt;class 'int'&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>尽管注解的使用方法可能有很多种，但是它们的主要用途还是文档。 因为python并没有类型声明，通常来讲仅仅通过阅读源码很难知道应该传递什么样的参数给这个函数。 这时候使用注解就能给程序员更多的提示，让他们可以正确的使用函数。</p>
<h2 id="定义有默认参数的函数"><a href="#定义有默认参数的函数" class="headerlink" title="定义有默认参数的函数"></a>定义有默认参数的函数</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p05_define_functions_with_default_arguments.html" target="_blank" rel="noopener">定义有默认参数的函数</a></li>
</ul>
<p>默认参数的值仅仅在函数定义的时候赋值一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">42</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(a, b=x)</span>:</span></span><br><span class="line">    print(a, b)</span><br><span class="line"></span><br><span class="line">spam(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1 42</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">12</span></span><br><span class="line">spam(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1 42</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到当我们改变x的值的时候对默认参数值并没有影响，这是因为在函数定义的时候就已经确定了它的默认值了。</p>
</blockquote>
<p>默认参数的值应该是不可变的对象，比如None、True、False、数字或字符串。</p>
<p>注意在使用默认参数，使用None作为默认，并且对参数进行None判断的时候，应该使用<code>is not None</code>之类的，而不应该直接使用<code>not b</code>，尽管None值确实是被当成False， 但是还有其他的对象(比如长度为0的字符串、列表、元组、字典等)都会被当做False。 因此，上面的代码会误将一些其他输入也当成是没有输入。</p>
<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如None、 0或者False值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。</p>
<p>为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的_no_value变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个_no_value实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。</p>
<p>这里对 <code>object()</code> 的使用看上去有点不太常见。object 是python中所有类的基类。 你可以创建 object 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x+y</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
<p>lambda表达式典型的使用场景是排序或数据reduce等。</p>
<p>尽管lambda表达式允许你定义简单函数，但是它的使用是有限制的。 你只能指定单个表达式，它的值就是最后的返回值。也就是说不能包含其他的语言特性了， 包括多个语句、条件表达式、迭代以及异常处理等等。</p>
<p>你可以不使用lambda表达式就能编写大部分python代码。 但是，当有人编写大量计算表达式值的短小函数或者需要用户提供回调函数的程序的时候， 你就会看到lambda表达式的身影了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">a = <span class="keyword">lambda</span> y: x + y</span><br><span class="line">print(a(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 20</span></span><br><span class="line">x = <span class="number">20</span></span><br><span class="line">b = <span class="keyword">lambda</span> y: x + y</span><br><span class="line">print(a(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 30</span></span><br><span class="line">print(b(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 30</span></span><br></pre></td></tr></table></figure>
<p>这其中的奥妙在于lambda表达式中的x是一个自由变量， 在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。 因此，在调用这个lambda表达式的时候，x的值是执行时的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">10</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">10</span>)</span><br><span class="line"><span class="number">13</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>如果需要在定义的时候就将变量<code>x</code>固定下来，就可以在定义<code>lambda</code>的时候使用<code>x=x</code>的方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="keyword">lambda</span> y, x=x: x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="keyword">lambda</span> y, x=x: x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(<span class="number">10</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(<span class="number">10</span>)</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>如果需要在一开始的时候时候就开始使用所规定的值，就应该一开始就定义，不然在使用的时候就有可能在使用的时候，由于变量的改变，导致函数的变化，导致与期望的值不相符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">funcs = [<span class="keyword">lambda</span> x: x+n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> funcs:</span><br><span class="line">    print(i(<span class="number">0</span>), end=<span class="string">' '</span>)</span><br><span class="line">    <span class="comment"># 4 4 4 4 4 </span></span><br><span class="line">    </span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">funcs1 = [<span class="keyword">lambda</span> x, n=n: x+n <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> funcs1:</span><br><span class="line">    print(i(<span class="number">0</span>), end=<span class="string">' '</span>)</span><br><span class="line">    <span class="comment"># 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>使用的时候，第一种的<code>n</code>就只会保留最后一次的<code>4</code>，所以输出的时候都是<code>4</code>。</p>
<h2 id="functools-partial-1"><a href="#functools-partial-1" class="headerlink" title="functools.partial"></a>functools.partial</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p08_make_callable_with_fewer_arguments.html" target="_blank" rel="noopener">减少可调用对象的参数个数</a></li>
</ul>
<p><code>partial()</code> 函数允许你给一个或多个参数设置固定的值，减少接下来被调用时的参数个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = partial(spam, <span class="number">1</span>) <span class="comment"># a = 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = partial(spam, d=<span class="number">42</span>) <span class="comment"># d = 42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2(<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = partial(spam, <span class="number">1</span>, <span class="number">2</span>, d=<span class="number">42</span>) <span class="comment"># a = 1, b = 2, d = 42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3(<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3(<span class="number">4</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3(<span class="number">5</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">42</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>此外有很多功能看文档。</p>
<h2 id="将单方法的类转换为函数"><a href="#将单方法的类转换为函数" class="headerlink" title="将单方法的类转换为函数"></a>将单方法的类转换为函数</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p09_replace_single_method_classes_with_functions.html" target="_blank" rel="noopener">将单方法的类转换为函数</a></li>
</ul>
<p>你有一个除 <code>__init__()</code> 方法外只定义了一个方法的类。为了简化代码，你想将它转换成一个函数。</p>
<p>大多数情况下，可以使用闭包来将单个方法的类转换成函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UrlTemplate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, template)</span>:</span></span><br><span class="line">        self.template = template</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> urlopen(self.template.format_map(kwargs))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use. Download stock data from yahoo</span></span><br><span class="line">yahoo = UrlTemplate(<span class="string">'http://finance.yahoo.com/d/quotes.csv?s=&#123;names&#125;&amp;f=&#123;fields&#125;'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> yahoo.open(names=<span class="string">'IBM,AAPL,FB'</span>, fields=<span class="string">'sl1c1v'</span>):</span><br><span class="line">    print(line.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p>这个类可以被函数直接代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">urltemplate</span><span class="params">(template)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">opener</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> urlopen(template.format_map(kwargs))</span><br><span class="line">    <span class="keyword">return</span> opener</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line">yahoo = urltemplate(<span class="string">'http://finance.yahoo.com/d/quotes.csv?s=&#123;names&#125;&amp;f=&#123;fields&#125;'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> yahoo(names=<span class="string">'IBM,AAPL,FB'</span>, fields=<span class="string">'sl1c1v'</span>):</span><br><span class="line">    print(line.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p>大部分情况下，你拥有一个单方法类的原因是需要存储某些额外的状态来给方法使用。 比如，定义UrlTemplate类的唯一目的就是先在某个地方存储模板值，以便将来可以在<code>open()</code>方法中使用。</p>
<p>使用一个内部函数或者闭包的方案通常会更优雅一些。简单来讲，一个闭包就是一个函数， 只不过在函数内部带上了一个额外的变量环境。闭包关键特点就是它会记住自己被定义时的环境。 因此，在我们的解决方案中，<code>opener()</code> 函数记住了 <code>template</code> 参数的值，并在接下来的调用中使用它。</p>
<p>任何时候只要你碰到需要给某个函数增加额外的状态信息的问题，都可以考虑使用闭包。 相比将你的函数转换成一个类而言，闭包通常是一种更加简洁和优雅的方案。</p>
<h2 id="带额外状态信息的回调函数"><a href="#带额外状态信息的回调函数" class="headerlink" title="带额外状态信息的回调函数"></a>带额外状态信息的回调函数</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p10_carry_extra_state_with_callback_functions.html" target="_blank" rel="noopener">带额外状态信息的回调函数</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_async</span><span class="params">(func, args, *, callback)</span>:</span></span><br><span class="line">    <span class="comment"># Compute the result</span></span><br><span class="line">    result = func(*args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Invoke the callback with the result</span></span><br><span class="line">    callback(result)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_result</span><span class="params">(result)</span>:</span></span><br><span class="line">    print(<span class="string">'Got: '</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apply_async(add, (<span class="number">2</span>, <span class="number">3</span>), callback=print_result)</span><br><span class="line"><span class="comment"># Got:  5</span></span><br><span class="line">apply_async(add, (<span class="string">'hello '</span>, <span class="string">'word'</span>), callback=print_result)</span><br><span class="line"><span class="comment"># Got:  hello word</span></span><br></pre></td></tr></table></figure>
<p>注意到 <code>print_result()</code> 函数仅仅只接受一个参数 <code>result</code> 。不能再传入其他信息。 而当你想让回调函数访问其他变量或者特定环境的变量值的时候就会遇到麻烦。</p>
<p>为了让回调函数访问外部信息，一种方法是使用一个绑定方法来代替一个简单函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultHandler</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        self.sequence += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[&#123;&#125;] Got: &#123;&#125;'</span>.format(self.sequence, result))</span><br></pre></td></tr></table></figure>
<p>使用这个类的时候，你先创建一个类的实例，然后用它的 handler() 绑定方法来做为回调函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = ResultHandler()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_async(add, (<span class="number">2</span>, <span class="number">3</span>), callback=r.handler)</span><br><span class="line">[<span class="number">1</span>] Got: <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_async(add, (<span class="string">'hello'</span>, <span class="string">'world'</span>), callback=r.handler)</span><br><span class="line">[<span class="number">2</span>] Got: helloworld</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>第二种方式，作为类的替代，可以使用一个闭包捕获状态值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_handler</span><span class="params">()</span>:</span></span><br><span class="line">    sequence = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(result)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> sequence</span><br><span class="line">        sequence += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[&#123;&#125;] Got: &#123;&#125;'</span>.format(sequence, result))</span><br><span class="line">    <span class="keyword">return</span> handler</span><br></pre></td></tr></table></figure>
<p>使用闭包的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>handler = make_handler()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_async(add, (<span class="number">2</span>, <span class="number">3</span>), callback=handler)</span><br><span class="line">[<span class="number">1</span>] Got: <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_async(add, (<span class="string">'hello'</span>, <span class="string">'world'</span>), callback=handler)</span><br><span class="line">[<span class="number">2</span>] Got: helloworld</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>或者使用协程的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_handler</span><span class="params">()</span>:</span></span><br><span class="line">    sequence = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        result = <span class="keyword">yield</span></span><br><span class="line">        sequence += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'[&#123;&#125;] Got; &#123;&#125;'</span>.format(sequence, result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">handler = make_handler()</span><br><span class="line">next(handler)</span><br><span class="line">apply_async(add, (<span class="number">2</span>, <span class="number">3</span>), callback=handler.send)</span><br><span class="line"><span class="comment"># [1] Got; 5</span></span><br><span class="line">apply_async(add, (<span class="string">'lalala '</span>, <span class="string">'hehehe'</span>), callback=handler.send)</span><br><span class="line"><span class="comment"># [2] Got; lalala hehehe</span></span><br></pre></td></tr></table></figure>
<p>基于回调函数的软件通常都有可能变得非常复杂。一部分原因是回调函数通常会跟请求执行代码断开。 因此，请求执行和处理结果之间的执行环境实际上已经丢失了。如果你想让回调函数连续执行多步操作， 那你就必须去解决如何保存和恢复相关的状态信息了。</p>
<p>至少有两种主要方式来捕获和保存状态信息，你可以在一个对象实例(通过一个绑定方法)或者在一个闭包中保存它。 两种方式相比，闭包或许是更加轻量级和自然一点，因为它们可以很简单的通过函数来构造。 它们还能自动捕获所有被使用到的变量。因此，你无需去担心如何去存储额外的状态信息(代码中自动判定)。</p>
<blockquote>
<p>如果使用闭包，你需要注意对那些可修改变量的操作。在上面的方案中， <code>nonlocal</code> 声明语句用来指示接下来的变量会在回调函数中被修改。如果没有这个声明，代码会报错。</p>
</blockquote>
<ul>
<li><a href="http://codingpy.com/article/what-is-nonlocal-statement-in-python/" target="_blank" rel="noopener">python知识 什么是非局部语句</a></li>
</ul>
<p>而使用一个协程来作为一个回调函数就更有趣了，它跟闭包方法密切相关。 某种意义上来讲，它显得更加简洁，因为总共就一个函数而已。 并且，你可以很自由的修改变量而无需去使用 <code>nonlocal</code> 声明。 这种方式唯一缺点就是相对于其他Python技术而言或许比较难以理解。 另外还有一些比较难懂的部分，比如使用之前需要调用 <code>next()</code> ，实际使用时这个步骤很容易被忘记。 尽管如此，协程还有其他用处，比如作为一个内联回调函数的定义。</p>
<h2 id="内联回调函数"><a href="#内联回调函数" class="headerlink" title="内联回调函数"></a>内联回调函数</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p11_inline_callback_functions.html" target="_blank" rel="noopener">内联回调函数</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_async</span><span class="params">(func, args, *, callback)</span>:</span></span><br><span class="line">    <span class="comment"># Compute the result</span></span><br><span class="line">    result = func(*args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Invoke the callback with the result</span></span><br><span class="line">    callback(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Async</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inlined_async</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        f = func(*args)</span><br><span class="line">        result_queue = Queue()</span><br><span class="line">        result_queue.put(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            result = result_queue.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                a = f.send(result)</span><br><span class="line">                apply_async(a.func, a.args, callback=result_queue.put)</span><br><span class="line">            <span class="keyword">except</span> StopIteration:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="meta">@inlined_async</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lala_test</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="keyword">yield</span> Async(add, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">    print(r)</span><br><span class="line">    r = <span class="keyword">yield</span> Async(add, (<span class="string">'hello'</span>, <span class="string">'world'</span>))</span><br><span class="line">    print(r)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        r = <span class="keyword">yield</span> Async(add, (n, n))</span><br><span class="line">        print(r)</span><br><span class="line">    print(<span class="string">'Goodbye'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lala_test()</span><br></pre></td></tr></table></figure>
<p>首先，在需要使用到回调的代码中，关键点在于当前计算工作会挂起并在将来的某个时候重启(比如异步执行)。 当计算重启时，回调函数被调用来继续处理结果。<code>apply_async()</code> 函数演示了执行回调的实际逻辑， 尽管实际情况中它可能会更加复杂(包括线程、进程、事件处理器等等)。</p>
<p>计算的暂停与重启思路跟生成器函数的执行模型不谋而合。 具体来讲，yield 操作会使一个生成器函数产生一个值并暂停。 接下来调用生成器的 <code>__next__()</code> 或 <code>send()</code> 方法又会让它从暂停处继续执行。</p>
<p>根据这个思路，这一小节的核心就在 <code>inline_async()</code> 装饰器函数中了。 关键点就是，装饰器会逐步遍历生成器函数的所有 <code>yield</code> 语句，每一次一个。 为了这样做，刚开始的时候创建了一个 <code>result</code> 队列并向里面放入一个 <code>None</code> 值。 然后开始一个循环操作，从队列中取出结果值并发送给生成器，它会持续到下一个 <code>yield</code> 语句， 在这里一个 <code>Async</code> 的实例被接受到。然后循环开始检查函数和参数，并开始进行异步计算 <code>apply_async()</code> 。 然而，这个计算有个最诡异部分是它并没有使用一个普通的回调函数，而是用队列的 <code>put()</code> 方法来回调。</p>
<p>主循环立即返回顶部并在队列上执行 <code>get()</code> 操作。 如果数据存在，它一定是 put() 回调存放的结果。如果没有数据，那么先暂停操作并等待结果的到来。 这个具体怎样实现是由 <code>apply_async()</code> 函数来决定的。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p12_access_variables_defined_inside_closure.html#id1" target="_blank" rel="noopener">访问闭包中定义的变量</a></li>
</ul>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="让对象支持上下文管理协议"><a href="#让对象支持上下文管理协议" class="headerlink" title="让对象支持上下文管理协议"></a>让对象支持上下文管理协议</h2><p>为了让一个对象兼容 with 语句，你需要实现 <code>__enter__()</code> 和 <code>__exit__()</code> 方法。</p>
<p>一个网络连接的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address, family=AF_INET, type=SOCK_STREAM)</span>:</span></span><br><span class="line">        self.address = address</span><br><span class="line">        self.family = family</span><br><span class="line">        self.type = type</span><br><span class="line">        self.sock = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.sock <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'Already connected'</span>)</span><br><span class="line">        self.sock = socket(self.family, self.type)</span><br><span class="line">        self.sock.connect(self.address)</span><br><span class="line">        <span class="keyword">return</span> self.sock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_ty, exc_val, tb)</span>:</span></span><br><span class="line">        self.sock.close()</span><br><span class="line">        self.sock = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn = LazyConnection((<span class="string">'www.python.org'</span>, <span class="number">80</span>))</span><br><span class="line"><span class="comment"># Connection closed</span></span><br><span class="line"><span class="keyword">with</span> conn <span class="keyword">as</span> s:</span><br><span class="line">    <span class="comment"># conn.__enter__() executes: connection open</span></span><br><span class="line">    s.send(<span class="string">b'GET /index.html HTTP/1.0\r\n'</span>)</span><br><span class="line">    s.send(<span class="string">b'Host: www.python.org\r\n'</span>)</span><br><span class="line">    s.send(<span class="string">b'\r\n'</span>)</span><br><span class="line">    resp = <span class="string">b''</span>.join(iter(partial(s.recv, <span class="number">8192</span>), <span class="string">b''</span>))</span><br><span class="line">    <span class="comment"># conn.__exit__() executes: connection closed</span></span><br></pre></td></tr></table></figure>
<p>编写上下文管理器的主要原理是你的代码会放到 <code>with</code> 语句块中执行。 当出现 <code>with</code> 语句的时候，对象的 <code>__enter__()</code> 方法被触发， 它返回的值(如果有的话)会被赋值给 <code>as</code> 声明的变量。然后，<code>with</code> 语句块里面的代码开始执行。 最后，<code>__exit__()</code> 方法被触发进行清理工作。</p>
<p>不管 <code>with</code> 代码块中发生什么，上面的控制流都会执行完，就算代码块中发生了异常也是一样的。 事实上，<code>__exit__()</code> 方法的第三个参数包含了异常类型、异常值和追溯信息(如果有的话)。 <code>__exit__()</code> 方法能自己决定怎样利用这个异常信息，或者忽略它并返回一个<code>None</code>值。 如果 <code>__exit__()</code> 返回 <code>True</code> ，那么异常会被清空，就好像什么都没发生一样， <code>with</code> 语句后面的程序继续在正常执行。</p>
<blockquote>
<p>在需要管理一些资源比如文件、网络连接和锁的编程环境中，使用上下文管理器是很普遍的。 这些资源的一个主要特征是它们必须被手动的关闭或释放来确保程序的正确运行。 例如，如果你请求了一个锁，那么你必须确保之后释放了它，否则就可能产生死锁。 通过实现 <code>__enter__()</code> 和 <code>__exit__()</code> 方法并使用 with 语句可以很容易的避免这些问题， 因为 <code>__exit__()</code> 方法可以让你无需担心这些了。</p>
</blockquote>
<h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><p>主要是用来当成简单的数据结构的类而言，你可以通过给类添加 <code>__slots__</code> 属性来极大的减少实例所占的内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">'year'</span>, <span class="string">'month'</span>, <span class="string">'day'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br></pre></td></tr></table></figure>
<p>当你定义 <code>__slots__</code> 后，Python就会为实例使用一种更加紧凑的内部表示。 实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似。 在 <code>__slots__</code> 中列出的属性名在内部被映射到这个数组的指定小标上。 使用<code>slots</code>一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 <code>__slots__</code> 中定义的那些属性名。</p>
<blockquote>
<p>使用slots后节省的内存会跟存储属性的数量和类型有关。 不过，一般来讲，使用到的内存总量和将数据存储在一个元组中差不多。 为了给你一个直观认识，假设你不使用slots直接存储一个Date实例， 在64位的Python上面要占用428字节，而如果使用了slots，内存占用下降到156字节。 如果程序中需要同时创建大量的日期实例，那么这个就能极大的减小内存使用量了。</p>
<p>尽管slots看上去是一个很有用的特性，很多时候你还是得减少对它的使用冲动。 Python的很多特性都依赖于普通的基于字典的实现。 另外，定义了slots后的类不再支持一些普通类特性了，比如多继承。 大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义slots (比如在程序中需要创建某个类的几百万个实例对象)。</p>
</blockquote>
<p>关于 <code>__slots__</code> 的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。 尽管使用slots可以达到这样的目的，但是这个并不是它的初衷。 <code>__slots__</code> 更多的是用来作为一个内存优化工具。</p>
<h2 id="在类中封装属性名"><a href="#在类中封装属性名" class="headerlink" title="在类中封装属性名"></a>在类中封装属性名</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p05_encapsulating_names_in_class.html" target="_blank" rel="noopener">在类中封装属性名</a></li>
</ul>
<p>大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p>
<h2 id="创建可管理的属性"><a href="#创建可管理的属性" class="headerlink" title="创建可管理的属性"></a>创建可管理的属性</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p06_create_managed_attributes.html" target="_blank" rel="noopener">创建可管理的属性</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, first_name)</span>:</span></span><br><span class="line">        self.first_name = first_name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Getter function</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._first_name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setter function</span></span><br><span class="line"><span class="meta">    @first_name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected a string'</span>)</span><br><span class="line">        self._first_name = value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Deleter function (optional)</span></span><br><span class="line"><span class="meta">    @first_name.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">"Can't delete attribute"</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个 <code>getter</code> 函数，它使得 <code>first_name</code> 成为一个属性。 其他两个方法给 <code>first_name</code> 属性添加了 <code>setter</code> 和 <code>deleter</code> 函数。 需要强调的是只有在 <code>first_name</code> 属性被创建后， 后面的两个装饰器 <code>@first_name.setter</code> 和 <code>@first_name.deleter</code> 才能被定义。</p>
<p>在实现一个<code>property</code>的时候，底层数据(如果有的话)仍然需要存储在某个地方。 因此，在get和set方法中，你会看到对 <code>_first_name</code> 属性的操作，这也是实际数据保存的地方。 另外，你可能还会问为什么 <code>__init__()</code> 方法中设置了 <code>self.first_name</code> 而不是 <code>self._first_name</code> 。 在这个例子中，我们创建一个<code>property</code>的目的就是在设置<code>attribute</code>的时候进行检查。 因此，你可能想在初始化的时候也进行这种类型检查。通过设置 <code>self.first_name</code> ，自动调用 <code>setter</code> 方法， 这个方法里面会进行参数的检查，否则就是直接访问 <code>self._first_name</code> 了。</p>
<blockquote>
<p>Properties还是一种定义动态计算attribute的方法。 这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来。</p>
</blockquote>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>对于你定义的每一个类，Python会计算出一个所谓的方法解析顺序(MRO)列表。 这个MRO列表就是一个简单的所有基类的线性顺序表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()  <span class="comment"># Only one call to super() here</span></span><br><span class="line">        print(<span class="string">'C.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># c = C()</span></span><br><span class="line">print(C.__mro__)</span><br><span class="line"><span class="comment"># (&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)</span></span><br></pre></td></tr></table></figure>
<p>为了实现继承，Python会在MRO列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<p>而这个MRO列表的构造是通过一个C3线性化算法来实现的。</p>
<p>它实际上就是合并所有父类的MRO列表并遵循如下三条准则：</p>
<ul>
<li>子类会先于父类被检查</li>
<li>多个父类会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类</li>
</ul>
<p>老实说，你所要知道的就是MRO列表中的类顺序会让你定义的任意类层级关系变得有意义。</p>
<p>当你使用 <code>super()</code> 函数时，Python会在MRO列表上继续搜索下一个类。 只要每个重定义的方法统一使用 <code>super()</code> 并只调用它一次， 那么控制流最终会遍历完整个MRO列表，每个方法也只会被调用一次。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p08_extending_property_in_subclass.html" target="_blank" rel="noopener">子类中扩展property</a></li>
</ul>
<p>在子类中扩展父类的功能，需要函数前面加上装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Getting name'</span>)</span><br><span class="line">        <span class="keyword">return</span> super(SubPerson, self).name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Setting name'</span>)</span><br><span class="line">        super(SubPerson, SubPerson).name.__set__(self, value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Deleting name'</span>)</span><br><span class="line">        super(SubPerson, SubPerson).name.__delete__(self)</span><br></pre></td></tr></table></figure>
<p>如果只是扩展其中的一个方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson1</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="meta">    @Person.name.getter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Lalala'</span>)</span><br><span class="line">        <span class="keyword">return</span> super().name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="meta">    @Person.name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">'Setting name to'</span>, value)</span><br><span class="line">        super(SubPerson, SubPerson).name.__set__(self, value)</span><br></pre></td></tr></table></figure>
<p>在子类中扩展一个property可能会引起很多不易察觉的问题， 因为一个property其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的集合，而不是单个方法。 因此，当你扩展一个property的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中某一个。</p>
<p>在第一个例子中，所有的property方法都被重新定义。 在每一个方法中，使用了 <code>super()</code> 来调用父类的实现。 在 setter 函数中使用 <code>super(SubPerson, SubPerson).name.__set__(self, value)</code> 的语句是没有错的。 为了委托给之前定义的<code>setter</code>方法，需要将控制权传递给之前定义的name属性的 <code>__set__()</code> 方法。 不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它。 这也是为什么我们要使用 <code>super(SubPerson, SubPerson)</code> 的原因。</p>
<ul>
<li><a href="https://mozillazg.com/2016/12/python-super-is-not-as-simple-as-you-thought.html" target="_blank" rel="noopener">Python: super 没那么简单</a></li>
</ul>
<h2 id="创建新的类或实例属性"><a href="#创建新的类或实例属性" class="headerlink" title="创建新的类或实例属性"></a>创建新的类或实例属性</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p09_create_new_kind_of_class_or_instance_attribute.html" target="_blank" rel="noopener">创建新的类或实例属性</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> instance.__dict__[self.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected an int'</span>)</span><br><span class="line">        instance.__dict__[self.name] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> instance.__dict__[self.name]</span><br></pre></td></tr></table></figure>
<p>一个描述器就是一个实现了三个核心的属性访问操作(get, set, delete)的类， 分别为 <code>__get__()</code> 、<code>__set__()</code> 和 <code>__delete__()</code> 这三个特殊的方法。 这些方法接受一个实例作为输入，之后相应的操作实例底层的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    x = Integer(<span class="string">'x'</span>)</span><br><span class="line">    y = Integer(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br></pre></td></tr></table></figure>
<p>描述器可实现大部分Python类特性中的底层魔法， 包括 <code>@classmethod</code> 、<code>@staticmethod</code> 、<code>@property</code> ，甚至是 <code>__slots__</code> 特性。</p>
<p>通过定义一个描述器，你可以在底层捕获核心的实例操作(get, set, delete)，并且可完全自定义它们的行为。 这是一个强大的工具，有了它你可以实现很多高级功能，并且它也是很多高级库和框架中的重要工具之一。</p>
<blockquote>
<p>描述器的一个比较困惑的地方是它只能在类级别被定义，而不能为每个实例单独定义。</p>
</blockquote>
<h2 id="使用延迟计算属性"><a href="#使用延迟计算属性" class="headerlink" title="使用延迟计算属性"></a>使用延迟计算属性</h2><p>你想将一个只读属性定义成一个property，并且只在访问的时候才会计算结果。 但是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lazyproperty</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            setattr(instance, self.func.__name__, value)</span><br><span class="line">            <span class="comment"># 设置属性值</span></span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, radius)</span>:</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Computing area'</span>)</span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Computing permeter'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * math.pi * self.radius</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Circle(<span class="number">4.0</span>)</span><br><span class="line">print(c.radius)</span><br><span class="line"><span class="comment"># 4.0</span></span><br><span class="line">print(c.area)</span><br><span class="line"><span class="comment"># Computing area</span></span><br><span class="line"><span class="comment"># 50.26548245743669</span></span><br><span class="line">print(c.area)</span><br><span class="line"><span class="comment"># 50.26548245743669</span></span><br><span class="line">print(c.perimeter)</span><br><span class="line"><span class="comment"># Computing permeter</span></span><br><span class="line"><span class="comment"># 25.132741228718345</span></span><br><span class="line">print(c.perimeter)</span><br><span class="line"><span class="comment"># 25.132741228718345</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Computing area</code> 和 <code>Computing perimeter</code> 仅仅出现一次。</p>
</blockquote>
<p>很多时候，构造一个延迟计算属性的主要目的是为了提升性能。 例如，你可以避免计算这些属性值，除非你真的需要它们。 这里演示的方案就是用来实现这样的效果的， 只不过它是通过以非常高效的方式使用描述器的一个精妙特性来达到这种效果的。</p>
<p>当一个描述器被放入一个类的定义时， 每次访问属性时它的 <code>__get__()</code> 、<code>__set__()</code> 和 <code>__delete__()</code> 方法就会被触发。 不过，如果一个描述器仅仅只定义了一个 <code>__get__()</code> 方法的话，它比通常的具有更弱的绑定。 特别地，只有当被访问属性不在实例底层的字典中时 <code>__get__()</code> 方法才会被触发。</p>
<p><code>lazyproperty</code> 类利用这一点，使用 <code>__get__()</code> 方法在实例中存储计算出来的值， 这个实例使用相同的名字作为它的property。 这样一来，结果值被存储在实例字典中并且以后就不需要再去计算这个property了。 </p>
<h2 id="简化数据结构的初始化"><a href="#简化数据结构的初始化" class="headerlink" title="简化数据结构的初始化"></a>简化数据结构的初始化</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p11_simplify_initialization_of_data_structure.html" target="_blank" rel="noopener">简化数据结构的初始化</a></li>
</ul>
<p>写一个公共的类，定义<code>__init__</code>方法，之后的类继承该类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Structure1</span>:</span></span><br><span class="line">    <span class="comment"># Class variable that specifies expected fields</span></span><br><span class="line">    _fields = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(args) != len(self._fields):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Expected &#123;&#125; arguments'</span>.format(len(self._fields)))</span><br><span class="line">        <span class="comment"># Set the arguments</span></span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> zip(self._fields, args):</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example class definitions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure1)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure1)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'x'</span>, <span class="string">'y'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span><span class="params">(Structure1)</span>:</span></span><br><span class="line">    _fields = [<span class="string">'radius'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="abc"><a href="#abc" class="headerlink" title="abc"></a>abc</h2><p>定义接口或者抽象基类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStream</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self, maxbytes=<span class="number">-1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口。</p>
<blockquote>
<p>尽管ABCs可以让我们很方便的做类型检查，但是我们在代码中最好不要过多的使用它。 因为Python的本质是一门动态编程语言，其目的就是给你更多灵活性， 强制类型检查或让你代码变得更复杂，这样做无异于舍本求末。</p>
</blockquote>
<h2 id="实现数据模型的类型约束"><a href="#实现数据模型的类型约束" class="headerlink" title="实现数据模型的类型约束"></a>实现数据模型的类型约束</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p13_implementing_data_model_or_type_system.html" target="_blank" rel="noopener"> 实现数据模型的类型约束</a></li>
</ul>
<p>定义某些在属性赋值上面有限制的数据结构。</p>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>collections 定义了很多抽象基类，当你想自定义容器类的时候它们会非常有用。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p14_implementing_custom_containers.html" target="_blank" rel="noopener">实现自定义容器</a></li>
</ul>
<h2 id="functools-total-ordering"><a href="#functools-total-ordering" class="headerlink" title="functools.total_ordering"></a>functools.total_ordering</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c08/p24_making_classes_support_comparison_operations.html" target="_blank" rel="noopener">让类支持比较操作</a></li>
</ul>
<p>让某个类的实例支持标准的比较运算(比如&gt;=,!=,&lt;=,&lt;等)，但是又不想去实现那一大丢的特殊方法。</p>
<p>装饰器 <code>functools.total_ordering</code> 就是用来简化这个处理的。 使用它来装饰一个来，你只需定义一个 <code>__eq__()</code> 方法， 外加其他方法(<code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, or <code>__ge__</code>)中的一个即可。 然后装饰器会自动为你填充其它比较方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, length, width)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.length = length</span><br><span class="line">        self.width = width</span><br><span class="line">        self.square_feet = self.length * self.width</span><br><span class="line"></span><br><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, style)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.style = style</span><br><span class="line">        self.rooms = list()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">living_space_footage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(r.square_feet <span class="keyword">for</span> r <span class="keyword">in</span> self.rooms)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_room</span><span class="params">(self, room)</span>:</span></span><br><span class="line">        self.rooms.append(room)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;: &#123;&#125; square foot &#123;&#125;'</span>.format(self.name,</span><br><span class="line">                self.living_space_footage,</span><br><span class="line">                self.style)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.living_space_footage == other.living_space_footage</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.living_space_footage &lt; other.living_space_footage</span><br></pre></td></tr></table></figure>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><ul>
<li><a href="http://aju.space/2016/01/14/dive-into-python-decorator.html" target="_blank" rel="noopener">深入浅出Python装饰器</a></li>
</ul>
<h2 id="wraps"><a href="#wraps" class="headerlink" title="wraps"></a>wraps</h2><ul>
<li><a href="https://segmentfault.com/a/1190000009398663" target="_blank" rel="noopener">简单聊聊Python中的wraps修饰器</a></li>
</ul>
<p>简单的说，就是使得我们自定的修饰起函数的一些函数属性更加符合我们的预期。 </p>
<p>在我们使用函数的类似于 <code>__doc__</code> 和 <code>__name__</code> 等，需要获得函数的一些属性的时候，如果直接使用，就会输出修饰函数的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""这个是修饰函数"""</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_function</span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""这个是被修饰的函数"""</span></span><br><span class="line">    print(<span class="string">'wrapped'</span>)</span><br><span class="line"></span><br><span class="line">print(wrapped.__doc__)  <span class="comment"># 输出`这个是修饰函数`</span></span><br><span class="line">print(wrapped.__name__)  <span class="comment"># 输出`wrapper_function`</span></span><br></pre></td></tr></table></figure>
<p>这并不符合我们的预期，我们应该想知道的是 <code>wrapped</code> 的信息才对，所以就需要 <code>wraps</code> 修饰器，将原本 <code>wrapped</code> 的信息复制到 <code>wrapper</code> 中，从源码中也可以发现，源码中使用了 <code>partial</code> 和 <code>update_wrapper</code> 这两个函数，其中 <code>update_wrapper</code> 就是将信息复制使用的，而 <code>partial</code> 是填充 <code>update_wrapper</code> 的。</p>
<p>任何时候你定义装饰器的时候，都应该使用 <code>functools</code> 库中的 <code>@wraps</code> 装饰器来注解底层包装函数。</p>
<h2 id="装饰器（修饰器）"><a href="#装饰器（修饰器）" class="headerlink" title="装饰器（修饰器）"></a>装饰器（修饰器）</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p01_put_wrapper_around_function.html" target="_blank" rel="noopener">在函数上添加包装器</a></li>
</ul>
<p>使用修饰器，增加额外的操作，如日志，计时等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timethis</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(func.__name__, end-start)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timethis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">countdown(<span class="number">1000000</span>)</span><br><span class="line"><span class="comment"># countdown 0.09182381629943848</span></span><br><span class="line">countdown(<span class="number">9999999</span>)</span><br><span class="line"><span class="comment"># countdown 0.823084831237793</span></span><br></pre></td></tr></table></figure>
<p>一个装饰器就是一个函数，它接受一个函数作为参数并返回一个新的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timethis</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>和下面的效果等同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">countdown = timethis(countdown)</span><br></pre></td></tr></table></figure>
<p>python 自带的一些装饰器也是同样的道理。</p>
<p>在上面的 <code>wrapper()</code> 函数中， 装饰器内部定义了一个使用 <code>*args</code> 和  <code>**kwargs</code> 来接受任意参数的函数。 在这个函数里面调用了原始函数并将其结果返回，不过你还可以添加其他额外的代码(比如计时)。 然后这个新的函数包装器被作为结果返回来代替原始函数。</p>
<p>需要强调的是装饰器并不会修改原始函数的参数签名以及返回值。 使用 <code>*args</code> 和  <code>**kwargs</code> 目的就是确保任何参数都能适用。 而返回结果值基本都是调用原始函数 <code>func(*args, **kwargs)</code> 的返回结果，其中func就是原始函数。</p>
<h2 id="定义一个带参数的装饰器"><a href="#定义一个带参数的装饰器" class="headerlink" title="定义一个带参数的装饰器"></a>定义一个带参数的装饰器</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p04_define_decorator_that_takes_arguments.html" target="_blank" rel="noopener">定义一个带参数的装饰器</a></li>
</ul>
<p>定义了多个包裹的函数，最外层的函数负责接收参数，里面的两层负责接收函数，对函数进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        log = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.DEBUG)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x: int, y: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.CRITICAL, 'example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>最外层的函数 <code>logged()</code> 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数 <code>decorate()</code> 接受一个函数作为参数，然后在函数上面放置一个包装器。 这里的关键点是包装器是可以使用传递给 <code>logged()</code> 的参数的。</p>
<p>简单的说可以概括为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator(x, y, z)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以等价为下面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func = decorator(x, y, z)(func)</span><br></pre></td></tr></table></figure>
<p><code>decorator(x, y, z)</code> 的返回结果必须是一个可调用对象，它接受一个函数作为参数并包装它。</p>
<h2 id="可自定义属性的装饰器"><a href="#可自定义属性的装饰器" class="headerlink" title="可自定义属性的装饰器"></a>可自定义属性的装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps, partial</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attach_wrapper</span><span class="params">(obj, func=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(attach_wrapper, obj)</span><br><span class="line">    setattr(obj, func.__name__, func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(level, name=None, message=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">        log = logging.getLogger(logname)</span><br><span class="line">        logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span> func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log.log(level, logmsg)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @attach_wrapper(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_level</span><span class="params">(newlevle)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> level</span><br><span class="line">            level = newlevle</span><br><span class="line"></span><br><span class="line"><span class="meta">        @attach_wrapper(wrapper)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">set_message</span><span class="params">(newmsg)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> logmsg</span><br><span class="line">            logmsg = newmsg</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.DEBUG)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x: int, y: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(logging.CRITICAL, 'example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>__main__:add</span></span><br><span class="line">add.set_message(<span class="string">'add called'</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>__main__:add called</span></span><br><span class="line">add.set_level(logging.WARNING)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># WARNING:__main__:add called</span></span><br><span class="line">spam()</span><br><span class="line"><span class="comment"># Spam!</span></span><br><span class="line"><span class="comment"># CRITICAL:example:spam</span></span><br></pre></td></tr></table></figure>
<p>其中，在函数 <code>set_message()</code> 和 <code>set_level()</code> 中，作为属性赋值给包装器，每个函数里面，允许使用 <code>nonlocal</code> 来访问上一层包裹的函数（闭包），修改函数内部的变量。</p>
<p>如果有多个装饰器，调用的顺序是从里到外调用，最先调用最里面的装饰器，最后调用最外层的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>等效于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure>
<h2 id="带可选参数的装饰器"><a href="#带可选参数的装饰器" class="headerlink" title="带可选参数的装饰器"></a>带可选参数的装饰器</h2><p>自定义一个装饰器，可以选择接收参数，<code>@decorator(x, y, z)</code> ， 也可以选择不接收参数，直接 <code>@decorator</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps, partial</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logged</span><span class="params">(func=None, *, level=logging.DEBUG, name=None, message=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> partial(logged, level=level, name=name, message=message)</span><br><span class="line">    logname = name <span class="keyword">if</span> name <span class="keyword">else</span> func.__module__</span><br><span class="line">    log = logging.getLogger(logname)</span><br><span class="line">    logmsg = message <span class="keyword">if</span> message <span class="keyword">else</span>  func.__name__</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        log.log(level, logmsg)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="meta">@logged(level=logging.DEBUG, name='example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam !'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>__main__:add</span></span><br><span class="line">spam()</span><br><span class="line"><span class="comment"># Spam !</span></span><br><span class="line"><span class="comment"># DE<span class="doctag">BUG:</span>example:spam</span></span><br></pre></td></tr></table></figure>
<p>对于不加参数的装饰器的调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="meta">@logged</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>上面的调用次序可以和下面的等同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">add = logged(add)</span><br></pre></td></tr></table></figure>
<p>这时候，被装饰函数会被当做第一个参数直接传递给 <code>logged</code> 装饰器。 因此，<code>logged()</code> 中的第一个参数就是被包装函数本身。所有其他参数都必须有默认值。</p>
<p>而对于带有参数的装饰器的调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logged(level=logging.CRITICAL, name='example')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br></pre></td></tr></table></figure>
<p>可以和下面的调用次序等同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Spam!'</span>)</span><br><span class="line">spam = logged(level=logging.CRITICAL, name=<span class="string">'example'</span>)(spam)</span><br></pre></td></tr></table></figure>
<p>初始调用 <code>logged()</code> 函数时，被包装函数并没有传递进来。 因此在装饰器内，它必须是可选的。这个反过来会迫使其他参数必须使用关键字来指定。 并且，但这些参数被传递进来后，装饰器要返回一个接受一个函数参数并包装它的函数。 为了这样做，我们使用了一个技巧，就是利用 <code>functools.partial</code> 。 它会返回一个未完全初始化的自身，除了被包装函数外其他参数都已经确定下来了。</p>
<blockquote>
<p>原本如果没有参数的时候，默认装饰器会将函数作为第一个参数传入，但是如果有参数的话，被包装的函数就没有传递进来，又因为使用了通配符的关系，后面的参数就全都需要关键字参数的形式传递进来，之后使用的 <code>partial</code> 函数，又将自身 <code>logged</code> 返回，使得又再一次调用自己的这个装饰器，只不过就带上了参数，返回自身。</p>
</blockquote>
<h2 id="利用装饰器强制函数上的类型检查"><a href="#利用装饰器强制函数上的类型检查" class="headerlink" title="利用装饰器强制函数上的类型检查"></a>利用装饰器强制函数上的类型检查</h2><p>作为函数的规范，希望在函数的参数上加上参数的类型检查。</p>
<p>一般来说，python 的设计思想是不需要类型检查的，这样不仅会增加代码量，而且也使得python哲学失去意义，站在python的角度来说，不需要对变量进行类型的设定，同样也不需要对变量进行类型检查，python 有很强的自省，如果有什么异常会直接抛出，它认定我们是已经长大的成人了，不需要对这些进行而外的限制，使得我们能更加关注于逻辑的开发，而不是把焦点放在不必要的类型检查，而这所有的前提就是我们能处理自己的错误，或者说不会乱搞。</p>
<p>有时候我们需要对参数进行检查的时候，我们可以写一个装饰器，对函数进行参数的检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typeassert</span><span class="params">(*ty_args, **ty_kwargs)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="comment"># If in optimized mode, disable type checking</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> __debug__:</span><br><span class="line">            <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Map function argument names to supplied types</span></span><br><span class="line">        sig = signature(func)</span><br><span class="line">        bound_types = sig.bind_partial(*ty_args, **ty_kwargs).arguments</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            bound_values = sig.bind(*args, **kwargs)</span><br><span class="line">            <span class="comment"># Enforce type assertions across supplied arguments</span></span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">in</span> bound_types:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, bound_types[name]):</span><br><span class="line">                        <span class="keyword">raise</span> TypeError(</span><br><span class="line">                            <span class="string">'Argument &#123;&#125; must be &#123;&#125;'</span>.format(name, bound_types[name])</span><br><span class="line">                            )</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>
<p>使用的时候就按照正常的装饰器的调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@typeassert(int, int)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    print(add(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line">    print(add(<span class="string">'1233'</span>, <span class="number">23</span>))</span><br></pre></td></tr></table></figure>
<p>首先，装饰器只会在函数定义时被调用一次。 有时候你去掉装饰器的功能，那么你只需要简单的返回被装饰函数即可。 下面的代码中，如果全局变量　<code>__debug__</code> 被设置成了False(当你使用-O或-OO参数的优化模式执行程序时)， 那么就直接返回未修改过的函数本身：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># If in optimized mode, disable type checking</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> __debug__:</span><br><span class="line">        <span class="keyword">return</span> func</span><br></pre></td></tr></table></figure>
<p>其次，这里还对被包装函数的参数签名进行了检查，我们使用了 <code>inspect.signature()</code> 函数。 简单来讲，它运行你提取一个可调用对象的参数签名信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> signature</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(x, y, z=<span class="number">42</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sig = signature(spam)</span><br><span class="line">print(sig)</span><br><span class="line"><span class="comment"># (x, y, z=42)</span></span><br><span class="line">print(sig.parameters)</span><br><span class="line"><span class="comment"># OrderedDict([('x', &lt;Parameter "x"&gt;), ('y', &lt;Parameter "y"&gt;), ('z', &lt;Parameter "z=42"&gt;)])</span></span><br><span class="line">print(sig.parameters[<span class="string">'z'</span>].name)</span><br><span class="line"><span class="comment"># z</span></span><br><span class="line">print(sig.parameters[<span class="string">'z'</span>].default)</span><br><span class="line"><span class="comment"># 42</span></span><br><span class="line">print(sig.parameters[<span class="string">'z'</span>].kind)</span><br><span class="line"><span class="comment"># POSITIONAL_OR_KEYWORD</span></span><br></pre></td></tr></table></figure>
<p>这个模块的功能主要是获得其他函数的参数信息。</p>
<p>装饰器的开始部分，我们使用了 <code>bind_partial()</code> 方法来执行从指定类型到名称的部分绑定。 下面是例子演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types = sig.bind_partial(int,z=int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types</span><br><span class="line">&lt;inspect.BoundArguments object at <span class="number">0x10069bb50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_types.arguments</span><br><span class="line">OrderedDict([('x', &lt;class 'int'&gt;), ('z', &lt;class 'int'&gt;)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>在这个部分绑定中，你可以注意到缺失的参数被忽略了(比如并没有对y进行绑定)。 不过最重要的是创建了一个有序字典 <code>bound_types.arguments</code> 。 这个字典会将参数名以函数签名中相同顺序映射到指定的类型值上面去。 在我们的装饰器例子中，这个映射包含了我们要强制指定的类型断言。</p>
<p>在装饰器创建的实际包装函数中使用到了 <code>sig.bind()</code> 方法。 <code>bind()</code> 跟 <code>bind_partial()</code> 类似，但是它不允许忽略任何参数。因此有了下面的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_values = sig.bind(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bound_values.arguments</span><br><span class="line">OrderedDict([(<span class="string">'x'</span>, <span class="number">1</span>), (<span class="string">'y'</span>, <span class="number">2</span>), (<span class="string">'z'</span>, <span class="number">3</span>)])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>综合来说</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> name <span class="keyword">in</span> bound_types.arguments:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, bound_types.arguments[name]):</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> TypeError()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>不过对于一些有默认值的参数并不适用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@typeassert(int, list)</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(x, items=None)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> items <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line"><span class="meta">... </span>        items = []</span><br><span class="line"><span class="meta">... </span>    items.append(x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> items</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar(<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    File <span class="string">"contract.py"</span>, line <span class="number">33</span>, <span class="keyword">in</span> wrapper</span><br><span class="line">TypeError: Argument items must be &lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">bar</span><span class="params">(<span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></span></span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用元类控制实例的创建"><a href="#使用元类控制实例的创建" class="headerlink" title="使用元类控制实例的创建"></a>使用元类控制实例的创建</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p13_using_mataclass_to_control_instance_creation.html" target="_blank" rel="noopener">使用元类控制实例的创建</a></li>
</ul>
<p>通过改变实例创建方式来实现单例、缓存或其他类似的特性。</p>
<p>主要使用 <code>__call__()</code> 元类来操作，通过限制这个元类，来限制类的实例的创建。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoInstances</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"Can't instantiate directly"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=NoInstances)</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grok</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'Spam.grok'</span>)</span><br></pre></td></tr></table></figure>
<p>或者实现单例模式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.__instance = <span class="keyword">None</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.__instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.__instance = super().__call__(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__instance</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Spam'</span>)</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Spam()</span><br><span class="line">Creating Spam</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Spam()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>也可以创建弱引用的缓存实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cached</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line">        self.__cache = weakref.WeakValueDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> self.__cache:</span><br><span class="line">            <span class="keyword">return</span> self.__cache[args]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj = super().__call__(*args)</span><br><span class="line">            self.__cache[args] = obj</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=Cached)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">'Creating Spam(&#123;!r&#125;)'</span>.format(name))</span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Spam(<span class="string">'Guido'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Guido'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Spam(<span class="string">'Diana'</span>)</span><br><span class="line">Creating Spam(<span class="string">'Diana'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Spam(<span class="string">'Guido'</span>) <span class="comment"># Cached</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> c <span class="comment"># Cached value returned</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>如果没有使用元类的方式，也可以在全局里面定义变量保存类的实例，在写函数，全局引用这个实例，如果有这个对象的话，就返回这个对象本身，没有的话，就创建一个新的实例，赋值给变量。</p>
<h2 id="定义有可选参数的元类"><a href="#定义有可选参数的元类" class="headerlink" title="定义有可选参数的元类"></a>定义有可选参数的元类</h2><p>定义一个元类，允许类定义时提供可选参数，这样可以控制或配置类型的创建过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStream</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reada</span><span class="params">(self, maxsize=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>然而，在自定义元类中我们还可以提供其他的关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spam</span><span class="params">(metaclass=MyMeta, debug=True, synchronize=True)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>为了使元类支持这些关键字参数，你必须确保在 <code>__prepare__()</code> , <code>__new__()</code> 和 <code>__init__()</code> 方法中 都使用强制关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="comment"># Optional</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__prepare__</span><span class="params">(cls, name, bases, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> super().__prepare__(name, bases)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, ns, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, ns)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Required</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, ns, *, debug=False, synchronize=False)</span>:</span></span><br><span class="line">        <span class="comment"># Custom processing</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        super().__init__(name, bases, ns)</span><br></pre></td></tr></table></figure>
<p>给一个元类添加可选关键字参数需要你完全弄懂类创建的所有步骤， 因为这些参数会被传递给每一个相关的方法。 <code>__prepare__()</code> 方法在所有类定义开始执行前首先被调用，用来创建类命名空间。 通常来讲，这个方法只是简单的返回一个字典或其他映射对象。 <code>__new__()</code> 方法被用来实例化最终的类对象。它在类的主体被执行完后开始执行。 <code>__init__()</code> 方法最后被调用，用来执行其他的一些初始化工作。</p>
<p>当我们构造元类的时候，通常只需要定义一个 <code>__new__()</code> 或 <code>__init__()</code> 方法，但不是两个都定义。 但是，如果需要接受其他的关键字参数的话，这两个方法就要同时提供，并且都要提供对应的参数签名。 默认的 <code>__prepare__()</code> 方法接受任意的关键字参数，但是会忽略它们， 所以只有当这些额外的参数可能会影响到类命名空间的创建时你才需要去定义 <code>__prepare__()</code> 方法。</p>
<p>将这些属性定义为参数的好处在于它们不会污染类的名称空间， 这些属性仅仅只从属于类的创建阶段，而不是类中的语句执行阶段。 另外，它们在 <code>__prepare__()</code> 方法中是可以被访问的，因为这个方法会在所有类主体执行前被执行。 但是类变量只能在元类的 <code>__new__()</code> 和 <code>__init__()</code> 方法中可见。</p>
<h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p16_enforce_argument_signature_on_args_kwargs.html" target="_blank" rel="noopener"> *args和**kwargs的强制参数签名</a></li>
</ul>
<p>你有一个函数或方法，它使用*args和**kwargs作为参数，这样使得它比较通用， 但有时候你想检查传递进来的参数是不是某个你想要的类型。</p>
<p>对任何涉及到操作函数调用签名的问题，你都应该使用 <code>inspect</code> 模块中的签名特性。 我们最主要关注两个类：<code>Signature</code> 和 <code>Parameter</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> Signature, Parameter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parms = [</span><br><span class="line">    Parameter(<span class="string">'x'</span>, Parameter.POSITIONAL_OR_KEYWORD),</span><br><span class="line">    Parameter(<span class="string">'y'</span>, Parameter.POSITIONAL_OR_KEYWORD, default=<span class="number">42</span>),</span><br><span class="line">    Parameter(<span class="string">'z'</span>, Parameter.KEYWORD_ONLY, default=<span class="keyword">None</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sig = Signature(parms)</span><br><span class="line">print(sig)</span><br><span class="line"><span class="comment"># (x, y=42, *, z=None)</span></span><br></pre></td></tr></table></figure>
<p>一旦你有了一个签名对象，你就可以使用它的 <code>bind()</code> 方法很容易的将它绑定到 <code>*args</code> 和 <code>**kwargs</code> 上去。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    bound_values = sig.bind(*args, **kwargs)</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">        print(name, value)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, z=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># x 1</span></span><br><span class="line"><span class="comment"># y 2</span></span><br><span class="line"><span class="comment"># z 3</span></span><br></pre></td></tr></table></figure>
<p>可以看出来，通过将签名和传递的参数绑定起来，可以强制函数调用遵循特定的规则，比如必填、默认、重复等等。</p>
<p>一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> Signature, Parameter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_sig</span><span class="params">(*names)</span>:</span></span><br><span class="line">    parms = [Parameter(name, Parameter.POSITIONAL_OR_KEYWORD)</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names]</span><br><span class="line">    <span class="keyword">return</span> Signature(parms)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Structure</span>:</span></span><br><span class="line">    __signature__ = make_sig()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        bound_values = self.__signature__.bind(*args, **kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> bound_values.arguments.items():</span><br><span class="line">            setattr(self, name, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    __signature__ = make_sig(<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(Structure)</span>:</span></span><br><span class="line">    __signature__ = make_sig(<span class="string">'x'</span>, <span class="string">'y'</span>)</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> inspect</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(inspect.signature(Stock))</span><br><span class="line">(name, shares, price)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">490.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: <span class="string">'price'</span> parameter lacking default value</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s3 = Stock(<span class="string">'ACME'</span>, <span class="number">100</span>, <span class="number">490.1</span>, shares=<span class="number">50</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: multiple values <span class="keyword">for</span> argument <span class="string">'shares'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="types-new-class"><a href="#types-new-class" class="headerlink" title="types.new_class"></a>types.new_class</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p18_define_classes_programmatically.html" target="_blank" rel="noopener">以编程方式定义类</a></li>
</ul>
<p>以字符串的方式去创建一个新的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, shares, price)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.shares = shares</span><br><span class="line">    self.price = price</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.shares * self.price</span><br><span class="line"></span><br><span class="line">cls_dict = &#123;</span><br><span class="line">    <span class="string">'__init__'</span> : __init__,</span><br><span class="line">    <span class="string">'cost'</span> : cost,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a class</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line">Stock = types.new_class(<span class="string">'Stock'</span>, (), &#123;&#125;, <span class="keyword">lambda</span> ns: ns.update(cls_dict))</span><br><span class="line">Stock.__module__ = __name__</span><br><span class="line"></span><br><span class="line">s = Stock(<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">91.1</span>)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># &lt;__main__.Stock object at 0x10409af60&gt;</span></span><br><span class="line">print(s.cost())</span><br><span class="line"><span class="comment"># 4555.0</span></span><br></pre></td></tr></table></figure>
<p>这种方法中，一个比较难理解的地方是在调用完 <code>types.new_class()</code> 对 <code>Stock.__module__</code> 的赋值。 每次当一个类被定义后，它的 <code>__module__</code> 属性包含定义它的模块名。 这个名字用于生成 <code>__repr__()</code> 方法的输出。它同样也被用于很多库，比如 <code>pickle</code> 。 因此，为了让你创建的类是“正确”的，你需要确保这个属性也设置正确了。</p>
<p><code>new_class()</code> 第四个参数最神秘，它是一个用来接受类命名空间的映射对象的函数。 通常这是一个普通的字典，但是它实际上是 <code>__prepare__()</code> 方法返回的任意对象。</p>
<h2 id="避免重复的属性方法"><a href="#避免重复的属性方法" class="headerlink" title="避免重复的属性方法"></a>避免重复的属性方法</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p21_avoid_repetitive_property_methods.html" target="_blank" rel="noopener">避免重复的属性方法</a></li>
</ul>
<p>当我们在类中有需要重复的去执行相同逻辑的操作，可以采用闭包的形式去简化代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name ,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'name must be a string'</span>)</span><br><span class="line">        self._name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'age must be an int'</span>)</span><br><span class="line">        self._age = value</span><br></pre></td></tr></table></figure>
<p>如果有更多的变量的值的话，我们就需要写更多的代码，而这样是个不可取的。为此，我们可以采用闭包的形式，将有相似操作的内容都用闭包处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">typed_property</span><span class="params">(name, expected_type)</span>:</span></span><br><span class="line">    storage_name = <span class="string">'_'</span> + name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self, storage_name)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @prop.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, expected_type):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'&#123;&#125; must be a &#123;&#125;'</span>.format(name, expected_type))</span><br><span class="line">        setattr(self, storage_name, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prop</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = typed_property(<span class="string">'name'</span>, str)</span><br><span class="line">    age = typed_property(<span class="string">'age'</span>, int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br></pre></td></tr></table></figure>
<p>例子中的函数 <code>typed_property()</code> 看上去有点难理解，其实它所做的仅仅就是为你生成属性并返回这个属性对象。 因此，当在一个类中使用它的时候，效果跟将它里面的代码放到类定义中去是一样的。 尽管属性的 <code>getter</code> 和 <code>setter</code> 方法访问了本地变量如 <code>name</code> , <code>expected_type</code> 以及 <code>storate_name</code> ，这个很正常，这些变量的值会保存在闭包当中。</p>
<h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p24_parse_and_analyzing_python_source.html" target="_blank" rel="noopener">解析与分析Python源码</a></li>
</ul>
<p><code>ast</code> 模块能被用来将Python源码编译成一个可被分析的抽象语法树（AST）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ast</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ex = ast.parse(<span class="string">'2 + 3*4 + x'</span>, mode=<span class="string">'eval'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ex</span><br><span class="line">&lt;_ast.Expression object at <span class="number">0x1007473d0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(ex)</span><br><span class="line"><span class="string">"Expression(body=BinOp(left=BinOp(left=Num(n=2), op=Add(),</span></span><br><span class="line"><span class="string">right=BinOp(left=Num(n=3), op=Mult(), right=Num(n=4))), op=Add(),</span></span><br><span class="line"><span class="string">right=Name(id='x', ctx=Load())))"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>top = ast.parse(<span class="string">'for i in range(10): print(i)'</span>, mode=<span class="string">'exec'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>top</span><br><span class="line">&lt;_ast.Module object at <span class="number">0x100747390</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(top)</span><br><span class="line"><span class="string">"Module(body=[For(target=Name(id='i', ctx=Store()),</span></span><br><span class="line"><span class="string">iter=Call(func=Name(id='range', ctx=Load()), args=[Num(n=10)],</span></span><br><span class="line"><span class="string">keywords=[], starargs=None, kwargs=None),</span></span><br><span class="line"><span class="string">body=[Expr(value=Call(func=Name(id='print', ctx=Load()),</span></span><br><span class="line"><span class="string">args=[Name(id='i', ctx=Load())], keywords=[], starargs=None,</span></span><br><span class="line"><span class="string">kwargs=None))], orelse=[])])"</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h1 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h1><h2 id="all"><a href="#all" class="headerlink" title="__all__"></a><code>__all__</code></h2><p>如果定义了 <code>__all__</code> , 那么只有被列举出的东西会被导出。</p>
<p>如果你将 <code>__all__</code> 定义成一个空列表, 没有东西将被导入。 如果 <code>__all__</code> 包含未定义的名字, 在导入时引起<code>AttributeError</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># somemodule.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grok</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">blah = <span class="number">42</span></span><br><span class="line"><span class="comment"># Only export 'spam' and 'grok'</span></span><br><span class="line">__all__ = [<span class="string">'spam'</span>, <span class="string">'grok'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="将模块分割成多个文件"><a href="#将模块分割成多个文件" class="headerlink" title="将模块分割成多个文件"></a>将模块分割成多个文件</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p04_split_module_into_multiple_files.html" target="_blank" rel="noopener">将模块分割成多个文件</a></li>
</ul>
<p>想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。</p>
<p>一个类似于这样的文件，可以尝试将一个模块分为两个类，方便对不同内容的功能分开管理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mymodule.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spam</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.spam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.bar'</span>)</span><br></pre></td></tr></table></figure>
<p>这时候需要将这两个类（A和B）分成两个文件，并且需要在 python 模块中将这两个文件的内容导入。</p>
<p>首先用mymodule目录来替换文件mymodule.py。 这这个目录下，创建以下文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mymodule/</span><br><span class="line">    __init__.py</span><br><span class="line">    a.py</span><br><span class="line">    b.py</span><br></pre></td></tr></table></figure>
<p>最后，在 <strong>init</strong>.py 中，将2个文件粘合在一起：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> .a <span class="keyword">import</span> A</span><br><span class="line"><span class="keyword">from</span> .b <span class="keyword">import</span> B</span><br></pre></td></tr></table></figure>
<p>有时候，如果需要导入的模块很大的话，我们就可以考虑延时导入，对于一些很大的模块，我们可以在需要的时候才导入所需要的模块。</p>
<p><code>__init__.py</code>文件一次导入所有必需的组件的。但是对于一个很大的模块，可能你只想组件在需要时被加载。 要做到这一点，<code>__init__.py</code>有细微的变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> .a <span class="keyword">import</span> A</span><br><span class="line">    <span class="keyword">return</span> A()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> .b <span class="keyword">import</span> B</span><br><span class="line">    <span class="keyword">return</span> B()</span><br></pre></td></tr></table></figure>
<p>在这个版本中，类A和类B被替换为在第一次访问时加载所需的类的函数。对于用户，这看起来不会有太大的不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import mymodule</span><br><span class="line">&gt;&gt;&gt; a = mymodule.A()</span><br><span class="line">&gt;&gt;&gt; a.spam()</span><br><span class="line">A.spam</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>延迟加载的主要缺点是继承和类型检查可能会中断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if isinstance(x, mymodule.A): # Error</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if isinstance(x, mymodule.a.A): # Ok</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="利用命名空间导入目录分散的代码"><a href="#利用命名空间导入目录分散的代码" class="headerlink" title="利用命名空间导入目录分散的代码"></a>利用命名空间导入目录分散的代码</h2><p>你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作为独立的包来安装。</p>
<p>从本质上讲，你要定义一个顶级Python包，作为一个大集合分开维护子包的命名空间。这个问题经常出现在大的应用框架中，框架开发者希望鼓励用户发布插件或附加包。</p>
<p>在统一不同的目录里统一相同的命名空间，但是要删去用来将组件联合起来的<code>__init__.py</code>文件。假设你有Python代码的两个不同的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo-package/</span><br><span class="line">    spam/</span><br><span class="line">        blah.py</span><br><span class="line"></span><br><span class="line">bar-package/</span><br><span class="line">    spam/</span><br><span class="line">        grok.py</span><br></pre></td></tr></table></figure>
<p>在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有<code>__init__.py</code>文件。</p>
<p>我们可以在另外的文件中导入所需。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">'foo-package'</span>, <span class="string">'bar-package'</span>])</span><br><span class="line"><span class="keyword">import</span> spam.blah</span><br><span class="line"><span class="keyword">import</span> spam.grok</span><br></pre></td></tr></table></figure>
<p>在这里工作的机制被称为“包命名空间”的一个特征。从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。</p>
<p>包命名空间的关键是确保顶级目录中没有<code>__init__.py</code>文件来作为共同的命名空间。缺失<code>__init__.py</code>文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其<code>__path__</code>变量中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.extend([<span class="string">'foo-package'</span>, <span class="string">'bar-package'</span>])</span><br><span class="line"><span class="comment"># import spam.blah</span></span><br><span class="line"><span class="comment"># import spam.grok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spam</span><br><span class="line">print(spam.__path__)</span><br><span class="line"><span class="comment"># _NamespacePath(['foo-package/spam', 'bar-package/spam'])</span></span><br></pre></td></tr></table></figure>
<p>一个包是否被作为一个包命名空间的主要方法是检查其<code>__file__</code>属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的“namespace”这个词体现出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(spam)</span><br><span class="line"><span class="comment"># &lt;module 'spam' (namespace)&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="__main__"></a><code>__main__</code></h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p07_make_directory_or_zip_runnable_as_main_script.html" target="_blank" rel="noopener">运行目录或压缩文件</a></li>
</ul>
<p>您有一个已成长为包含多个文件的应用，它已远不再是一个简单的脚本，你想向用户提供一些简单的方法运行这个程序。</p>
<p>如果你的应用程序已经有多个文件，你可以把你的应用程序放进它自己的目录并添加一个<code>__main__.py</code>文件。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myapplication/</span><br><span class="line">    spam.py</span><br><span class="line">    bar.py</span><br><span class="line">    grok.py</span><br><span class="line">    __main__.py</span><br></pre></td></tr></table></figure>
<p>如果<code>__main__.py</code>存在，就可以简单地在顶级目录运行Python解释器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash % python3 myapplication</span><br></pre></td></tr></table></figure>
<h2 id="importlib-import-module"><a href="#importlib-import-module" class="headerlink" title="importlib.import_module"></a>importlib.import_module</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p10_import_modules_using_name_given_in_string.html" target="_blank" rel="noopener">通过字符串名导入模块</a></li>
</ul>
<p>使用<code>importlib.import_module()</code>函数来手动导入名字为字符串给出的一个模块或者包的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import importlib</span><br><span class="line">&gt;&gt;&gt; math = importlib.import_module(&apos;math&apos;)</span><br><span class="line">&gt;&gt;&gt; math.sin(2)</span><br><span class="line">0.9092974268256817</span><br><span class="line">&gt;&gt;&gt; mod = importlib.import_module(&apos;urllib.request&apos;)</span><br><span class="line">&gt;&gt;&gt; u = mod.urlopen(&apos;http://www.python.org&apos;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><code>import_module</code>只是简单地执行和<code>import</code>相同的步骤，但是返回生成的模块对象。你只需要将其存储在一个变量，然后像正常的模块一样使用。</p>
<p>如果你正在使用的包，<code>import_module()</code>也可用于相对导入。但是，你需要给它一个额外的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line"># Same as &apos;from . import b&apos;</span><br><span class="line">b = importlib.import_module(&apos;.b&apos;, __package__)</span><br></pre></td></tr></table></figure>
<p>使用<code>import_module()</code>手动导入模块的问题通常出现在以某种方式编写修改或覆盖模块的代码时候。例如，也许你正在执行某种自定义导入机制，需要通过名称来加载一个模块，通过补丁加载代码。</p>
<p>在旧的代码，有时你会看到用于导入的内建函数<code>__import__()</code>。尽管它能工作，但是<code>importlib.import_module()</code> 通常更容易使用。</p>
<h2 id="安装私有的包"><a href="#安装私有的包" class="headerlink" title="安装私有的包"></a>安装私有的包</h2><p>安装一个包，只是提供给自己使用，而不是系统上的所有用户使用。</p>
<p>Python有一个用户安装目录，通常类似”~/.local/lib/python3.3/site-packages”。 要强制在这个目录中安装包，可使用安装选项“–user”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 setup.py install --user</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user packagename</span><br></pre></td></tr></table></figure>
<h2 id="pyvenv"><a href="#pyvenv" class="headerlink" title="pyvenv"></a>pyvenv</h2><p>使用 <code>pyvenv</code> 命令创建一个新的“虚拟”环境。 这个命令被安装在Python解释器同一目录，或Windows上面的Scripts目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash % pyvenv Spam</span><br><span class="line">bash %</span><br></pre></td></tr></table></figure>
<p>这个解释器的特点就是他的site-packages目录被设置为新创建的环境。 如果你要安装第三方包，它们会被安装在那里，而不是通常系统的site-packages目录。</p>
<p>创建虚拟环境通常是为了安装和管理第三方包。 正如你在例子中看到的那样，<code>sys.path</code> 变量包含来自于系统Python的目录， 而 site-packages目录已经被重定位到一个新的目录。</p>
<p>有了一个新的虚拟环境，下一步就是安装一个包管理器，比如distribute或pip。 但安装这样的工具和包的时候，你需要确保你使用的是虚拟环境的解释器。 它会将包安装到新创建的site-packages目录中去。</p>
<p>尽管一个虚拟环境看上去是Python安装的一个复制， 不过它实际上只包含了少量几个文件和一些符号链接。 所有标准库函文件和可执行解释器都来自原来的Python安装。 因此，创建这样的环境是很容易的，并且几乎不会消耗机器资源。</p>
<p>默认情况下，虚拟环境是空的，不包含任何额外的第三方库。如果你想将一个已经安装的包作为虚拟环境的一部分， 可以使用“–system-site-packages”选项来创建虚拟环境，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash % pyvenv --system-site-packages Spam</span><br><span class="line">bash %</span><br></pre></td></tr></table></figure>
<h1 id="网络与Web编程"><a href="#网络与Web编程" class="headerlink" title="网络与Web编程"></a>网络与Web编程</h1><h2 id="urllib-request"><a href="#urllib-request" class="headerlink" title="urllib.request"></a>urllib.request</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c11/p01_interact_with_http_services_as_client.html" target="_blank" rel="noopener">作为客户端与HTTP服务交互</a></li>
</ul>
<p>发送一个简单的HTTP GET请求到远程的服务上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base URL being accessed</span></span><br><span class="line">url = <span class="string">'http://httpbin.org/get'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of query parameters (if any)</span></span><br><span class="line">parms = &#123;</span><br><span class="line">   <span class="string">'name1'</span> : <span class="string">'value1'</span>,</span><br><span class="line">   <span class="string">'name2'</span> : <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encode the query string</span></span><br><span class="line">querystring = parse.urlencode(parms)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a GET request and read the response</span></span><br><span class="line">u = request.urlopen(url+<span class="string">'?'</span> + querystring)</span><br><span class="line">resp = u.read()</span><br></pre></td></tr></table></figure>
<p>使用POST方法在请求主体中发送查询参数，可以将参数编码后作为可选参数提供给 <code>urlopen()</code> 函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base URL being accessed</span></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of query parameters (if any)</span></span><br><span class="line">parms = &#123;</span><br><span class="line">   <span class="string">'name1'</span> : <span class="string">'value1'</span>,</span><br><span class="line">   <span class="string">'name2'</span> : <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encode the query string</span></span><br><span class="line">querystring = parse.urlencode(parms)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a POST request and read the response</span></span><br><span class="line">u = request.urlopen(url, querystring.encode(<span class="string">'ascii'</span>))</span><br><span class="line">resp = u.read()</span><br></pre></td></tr></table></figure>
<p>如果你需要在发出的请求中提供一些自定义的HTTP头，例如修改 <code>user-agent</code> 字段,可以创建一个包含字段值的字典，并创建一个Request实例然后将其传给 <code>urlopen()</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extra headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-agent'</span> : <span class="string">'none/ofyourbusiness'</span>,</span><br><span class="line">    <span class="string">'Spam'</span> : <span class="string">'Eggs'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">req = request.Request(url, querystring.encode(<span class="string">'ascii'</span>), headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make a request and read the response</span></span><br><span class="line">u = request.urlopen(req)</span><br><span class="line">resp = u.read()</span><br></pre></td></tr></table></figure>
<p>使用 <code>requests</code> 库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Base URL being accessed</span></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of query parameters (if any)</span></span><br><span class="line">parms = &#123;</span><br><span class="line">   <span class="string">'name1'</span> : <span class="string">'value1'</span>,</span><br><span class="line">   <span class="string">'name2'</span> : <span class="string">'value2'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extra headers</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-agent'</span> : <span class="string">'none/ofyourbusiness'</span>,</span><br><span class="line">    <span class="string">'Spam'</span> : <span class="string">'Eggs'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp = requests.post(url, data=parms, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decoded text returned by the request</span></span><br><span class="line">text = resp.text</span><br></pre></td></tr></table></figure>
<p><code>get</code> 请求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://gank.io/api/xiandu/categories'</span></span><br><span class="line">resp = requests.get(url)</span><br><span class="line">print(resp.text)</span><br></pre></td></tr></table></figure>
<p>关于requests库，一个值得一提的特性就是它能以多种方式从请求中返回响应结果的内容。从上面的代码来看， <code>resp.text</code> 带给我们的是以Unicode解码的响应文本。但是，如果去访问 <code>resp.content</code> ，就会得到原始的二进制数据。另一方面，如果访问 <code>resp.json</code> ，那么就会得到JSON格式的响应内容。</p>
<h1 id="网络与web"><a href="#网络与web" class="headerlink" title="网络与web"></a>网络与web</h1><h2 id="创建TCP服务器"><a href="#创建TCP服务器" class="headerlink" title="创建TCP服务器"></a><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c11/p02_creating_tcp_server.html" target="_blank" rel="noopener">创建TCP服务器</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> BaseRequestHandler, TCPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoHandler</span><span class="params">(BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Got connection from'</span>, self.client_address)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            msg = self.request.recv(<span class="number">8192</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            self.request.send(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    serv = TCPServer((<span class="string">''</span>, <span class="number">20000</span>), EchoHandler)</span><br><span class="line">    serv.serve_forever()</span><br></pre></td></tr></table></figure>
<p>定义了一个特殊的处理类，实现了一个 <code>handle()</code> 方法，用来为客户端连接服务。 <code>request</code> 属性是客户端socket，<code>client_address</code> 有客户端地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Jun 19 10:07:25 on ttys001</span><br><span class="line">JaelynLim:~ Jaelyn$ python</span><br><span class="line">Python 2.7.11 (v2.7.11:6d1b6a68f775, Dec  5 2015, 12:54:16) </span><br><span class="line">[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; from socket import socket</span><br><span class="line">&gt;&gt;&gt; from socket import AF_INET, SOCK_STREAM</span><br><span class="line">&gt;&gt;&gt; s = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">&gt;&gt;&gt; s.connect((&apos;localhost&apos;, 20000))</span><br><span class="line">&gt;&gt;&gt; s.send(b&apos;Hello&apos;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; s.recv(8192)</span><br><span class="line">&apos;Hello&apos;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>上面的代码进行访问测试，<code>Got connection from (&#39;127.0.0.1&#39;, 53691)</code> 。</p>
<p><code>socketserver</code> 可以让我们很容易的创建简单的TCP服务器。 但是，你需要注意的是，默认情况下这种服务器是单线程的，一次只能为一个客户端连接服务。 如果你想处理多个客户端，可以初始化一个 <code>ForkingTCPServer</code> 或者是 <code>ThreadingTCPServer</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socketserver <span class="keyword">import</span> ThreadingTCPServer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    serv = ThreadingTCPServer((<span class="string">''</span>, <span class="number">20000</span>), EchoHandler)</span><br><span class="line">    serv.serve_forever()</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://gist.github.com/kevinkindom/108ffd675cb9253f8f71" target="_blank" rel="noopener">Python Socket 编程详细介绍</a></li>
<li><a href="http://blog.51cto.com/yangrong/1339593" target="_blank" rel="noopener">python socket编程详细介绍</a></li>
</ul>
<h2 id="ipaddress"><a href="#ipaddress" class="headerlink" title="ipaddress"></a>ipaddress</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c11/p04_generate_range_of_ip_addresses_from_cidr_address.html" target="_blank" rel="noopener">通过CIDR地址生成对应的IP地址集</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ipaddress</span><br><span class="line"></span><br><span class="line">net = ipaddress.ip_network(<span class="string">'123.45.67.64/27'</span>)</span><br><span class="line">print(net)</span><br><span class="line"><span class="comment"># 123.45.67.64/27</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> net:</span><br><span class="line">    print(a)</span><br><span class="line"><span class="comment"># 123.45.67.64</span></span><br><span class="line"><span class="comment"># 123.45.67.65</span></span><br><span class="line"><span class="comment"># 123.45.67.66</span></span><br><span class="line"><span class="comment"># 123.45.67.67</span></span><br><span class="line"><span class="comment"># 123.45.67.68</span></span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>
<h2 id="cgi"><a href="#cgi" class="headerlink" title="cgi"></a>cgi</h2><ul>
<li><a href="https://www.biaodianfu.com/cgi-fastcgi-wsgi.html" target="_blank" rel="noopener">网关协议学习：CGI、FastCGI、WSGI</a></li>
</ul>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="启动与停止线程"><a href="#启动与停止线程" class="headerlink" title="启动与停止线程"></a>启动与停止线程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'T-minus'</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,), daemon=<span class="keyword">True</span>)</span><br><span class="line">t.start()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">t.join()</span><br><span class="line">print(<span class="string">'123123'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="判断线程是否已经启动"><a href="#判断线程是否已经启动" class="headerlink" title="判断线程是否已经启动"></a>判断线程是否已经启动</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p02_determining_if_thread_has_started.html" target="_blank" rel="noopener">判断线程是否已经启动</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n, started_evt)</span>:</span></span><br><span class="line">    print(<span class="string">'countdown starting'</span>)</span><br><span class="line">    <span class="comment"># started_evt.set()</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'T-mius'</span>, n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">6</span>:</span><br><span class="line">            started_evt.set()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">started_evt = Event()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'launching countdown'</span>)</span><br><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>, started_evt))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">started_evt.wait()</span><br><span class="line">print(<span class="string">'countdown is runing'</span>)</span><br></pre></td></tr></table></figure>
<p>当我们需要判断某个线程的状态，进而来进行不同的操作的时候，我们可以使用 <code>Event()</code> 事件来判断，这个对象有一个信号标志，开始为假，如果线程中需要等待一个 <code>event</code> 对象，而这个标志为假的话 ，就会一直等待。直到标志位为真，而标志位的设定，可以通过 <code>set()</code> 方法来设定，这将会唤醒所有等待这个对象的线程。如果遇到的 <code>event</code> 对象的标志位为真的话，会直接忽略，继续其他操作。</p>
<p>书籍原话：</p>
<blockquote>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其他线程需要通过判断某个线程的状态来确定自己下一步的操作，这时线程同步问题就会变得非常棘手。为了解决这些问题，我们需要使用 <code>threading</code> 库中的 <code>Event</code> 对象。 <code>Event</code> 对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生。在初始情况下，event 对象中的信号标志被设置为假。如果有线程等待一个 event 对象，而这个 event 对象的标志为假，那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个 event 对象的信号标志设置为真，它将唤醒所有等待这个 event 对象的线程。如果一个线程等待一个已经被设置为真的 event 对象，那么它将忽略这个事件，继续执行。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Condition</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicTimer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        self._initerval = interval</span><br><span class="line">        self._flag = <span class="number">0</span></span><br><span class="line">        self._cv = Condition()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        t = threading.Thread(target=self.run)</span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            time.sleep(self._initerval)</span><br><span class="line">            <span class="keyword">with</span> self._cv:</span><br><span class="line">                self._flag ^= <span class="number">1</span></span><br><span class="line">                self._cv.notify_all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_for_tick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            last_flag = self._flag</span><br><span class="line">            <span class="keyword">while</span> last_flag == self._flag:</span><br><span class="line">                self._cv.wait()</span><br><span class="line"></span><br><span class="line">ptimer = PeriodicTimer(<span class="number">5</span>)</span><br><span class="line">ptimer.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(nticks)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> nticks &gt; <span class="number">0</span>:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        print(<span class="string">'T-minus'</span>, nticks)</span><br><span class="line">        nticks -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countup</span><span class="params">(last)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; last:</span><br><span class="line">        ptimer.wait_for_tick()</span><br><span class="line">        print(<span class="string">'counting'</span>, n)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threading.Thread(target=countdown, args=(<span class="number">10</span>,)).start()</span><br><span class="line">threading.Thread(target=countup, args=(<span class="number">5</span>,)).start()</span><br></pre></td></tr></table></figure>
<p><code>Condition</code> 是处理多个线程同步的模块。具体要用再查资料去吧。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p03_communicating_between_threads.html" target="_blank" rel="noopener">进程间通信</a></li>
</ul>
<p>从一个线程向另一个线程发送数据最安全的方式可能就是使用 <code>queue</code> 库中的队列了。创建一个被多个线程共享的 <code>Queue</code> 对象，这些线程通过使用 <code>put()</code> 和 <code>get()</code> 操作来向队列中添加或者删除元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>
<p><code>Queue</code> 对象已经包含了必要的锁，所以你可以通过它在多个线程间多安全地共享数据。 当使用队列时，协调生产者和消费者的关闭问题可能会有一些麻烦。一个通用的解决方法是在队列中放置一个特殊的值，当消费者读到这个值的时候，终止执行。</p>
<p>一个例子：创建线程安全优先级队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._count = <span class="number">0</span></span><br><span class="line">        self._cv = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            heapq.heappush(self._queue, (-priority, self._count, item))</span><br><span class="line">            self._count += <span class="number">1</span></span><br><span class="line">            self._cv.notify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._cv:</span><br><span class="line">            <span class="keyword">while</span> len(self._queue) == <span class="number">0</span>:</span><br><span class="line">                self._cv.wait()</span><br><span class="line">            <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p><code>heapq</code> 是python的堆数据结构模块，这里定义了 <code>Condition</code>  ，在获取或者添加数据的时候，必须要获得锁的权限，才可以执行操作，确保数据的安全。</p>
<p>当我们使用队列进行进程间通信的时候，有时候我们不清楚数据什么时候会接受数据并开始工作，这个时候我们可以使用 <code>Queue</code> 中的 <code>task_done()</code> 和 <code>join()</code>  ，采用一种生产者消费者的模式进行数据的获取，并且这样能清楚的知道数据什么时候获取，什么时候消费，并且什么时候全部处理完毕。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        out_q.put(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data = in_q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Indicate completion</span></span><br><span class="line">        in_q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the shared queue and launch both threads</span></span><br><span class="line">q = Queue()</span><br><span class="line">t1 = Thread(target=consumer, args=(q,))</span><br><span class="line">t2 = Thread(target=producer, args=(q,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait for all produced items to be consumed</span></span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure>
<p>如果一个线程需要在一个“消费者”线程处理完特定的数据项时立即得到通知，你可以把要发送的数据和一个 <code>Event</code> 放到一起使用，这样“生产者”就可以通过这个Event对象来监测处理的过程了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that produces data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(out_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> running:</span><br><span class="line">        <span class="comment"># Produce some data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Make an (data, event) pair and hand it to the consumer</span></span><br><span class="line">        evt = Event()</span><br><span class="line">        out_q.put((data, evt))</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Wait for the consumer to process the item</span></span><br><span class="line">        evt.wait()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A thread that consumes data</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(in_q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># Get some data</span></span><br><span class="line">        data, evt = in_q.get()</span><br><span class="line">        <span class="comment"># Process the data</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># Indicate completion</span></span><br><span class="line">        evt.set()</span><br></pre></td></tr></table></figure>
<p>书本对 <code>Queue</code> 方法的建议：</p>
<blockquote>
<p><code>Queue</code> 对象提供一些在当前上下文很有用的附加特性。比如在创建 Queue 对象时提供可选的 <code>size</code> 参数来限制可以添加到队列中的元素数量。对于“生产者”与“消费者”速度有差异的情况，为队列中的元素数量添加上限是有意义的。比如，一个“生产者”产生项目的速度比“消费者” “消费”的速度快，那么使用固定大小的队列就可以在队列已满的时候阻塞队列，以免未预期的连锁效应扩散整个程序造成死锁或者程序运行失常。在通信的线程之间进行“流量控制”是一个看起来容易实现起来困难的问题。如果你发现自己曾经试图通过摆弄队列大小来解决一个问题，这也许就标志着你的程序可能存在脆弱设计或者固有的可伸缩问题。 <code>get()</code> 和 <code>put()</code> 方法都支持非阻塞方式和设定超时，这些操作都可以用来避免当执行某些特定队列操作时发生无限阻塞的情况，比如，一个非阻塞的 <code>put()</code> 方法和一个固定大小的队列一起使用，这样当队列已满时就可以执行不同的代码。比如输出一条日志信息并丢弃。</p>
<p>最后，有 <code>q.qsize()</code> ， <code>q.full()</code> ， <code>q.empty()</code> 等实用方法可以获取一个队列的当前大小和状态。但要注意，这些方法都不是线程安全的。可能你对一个队列使用 <code>empty()</code> 判断出这个队列为空，但同时另外一个线程可能已经向这个队列中插入一个数据项。所以，你最好不要在你的代码中使用这些方法。</p>
</blockquote>
<h2 id="Lock-对象"><a href="#Lock-对象" class="headerlink" title="Lock 对象"></a><code>Lock</code> 对象</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p04_locking_critical_sections.html" target="_blank" rel="noopener">给关键部分加锁</a></li>
</ul>
<p>要在多线程程序中安全使用可变对象，你需要使用 threading 库中的 <code>Lock</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedCounter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, initial_value = <span class="number">0</span>)</span>:</span></span><br><span class="line">        self._value = initial_value</span><br><span class="line">        self._value_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">incr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">             self._value += delta</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decr</span><span class="params">(self,delta=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self._value_lock:</span><br><span class="line">             self._value -= delta</span><br></pre></td></tr></table></figure>
<p><code>Lock</code> 对象和 <code>with</code> 语句块一起使用可以保证互斥执行，就是每次只有一个线程可以执行 with 语句包含的代码块。with 语句会在这个代码块执行前自动获取锁，在执行结束后自动释放锁。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p05_locking_with_deadlock_avoidance.html" target="_blank" rel="noopener">防止死锁的加锁机制</a></li>
</ul>
<p>演示一个死锁的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _id, balance, lock)</span>:</span></span><br><span class="line">        self.id = _id</span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.lock = lock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        self.balance -= amount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, amount)</span>:</span></span><br><span class="line">        self.balance += amount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span><span class="params">(_from, to, amount)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> _from.lock.acquire():  <span class="comment"># 锁住自己的账户</span></span><br><span class="line">        _from.withdraw(amount)</span><br><span class="line">        time.sleep(<span class="number">1</span>)  <span class="comment"># 让交易时间变长，2个交易线程时间上重叠，有足够时间来产生死锁</span></span><br><span class="line">        print(<span class="string">'wait for lock...'</span>)</span><br><span class="line">        <span class="keyword">if</span> to.lock.acquire():  <span class="comment"># 锁住对方的账户</span></span><br><span class="line">            to.deposit(amount)</span><br><span class="line">            to.lock.release()</span><br><span class="line">        _from.lock.release()</span><br><span class="line">    print(<span class="string">'finish...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Account(<span class="string">'a'</span>, <span class="number">1000</span>, threading.Lock())</span><br><span class="line">b = Account(<span class="string">'b'</span>, <span class="number">1000</span>, threading.Lock())</span><br><span class="line">threading.Thread(target=transfer, args=(a, b, <span class="number">100</span>)).start()</span><br><span class="line">threading.Thread(target=transfer, args=(b, a, <span class="number">200</span>)).start()</span><br></pre></td></tr></table></figure>
<p>如果需要解决的话，可以使用 Event() 事件来接连处理两个线程。在两个线程之间加上等待，处理完一个数据之后再将状态置为真。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p06_storing_thread_specific_state.html" target="_blank" rel="noopener">保存线程的状态信息</a></li>
</ul>
<h2 id="创建一个线程池"><a href="#创建一个线程池" class="headerlink" title="创建一个线程池"></a>创建一个线程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> AF_INET, SOCK_STREAM, socket</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_client</span><span class="params">(sock, client_addr)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Handle a client connection</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">'Got connection from'</span>, client_addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        msg = sock.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(<span class="string">'Client closed connection'</span>)</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(addr)</span>:</span></span><br><span class="line">    pool = ThreadPoolExecutor(<span class="number">128</span>)</span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        pool.submit(echo_client, client_sock, client_addr)</span><br><span class="line"></span><br><span class="line">echo_server((<span class="string">''</span>,<span class="number">15000</span>))</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>AF_INET</code> 表示采用 IPV4 的协议。</li>
<li><code>SOCK_STREAM</code> 表示使用双向 socket 通信。</li>
</ul>
<p>对于服务端来说，创建 socket ，绑定地址和端口号，设置监听 <code>listen</code> （这个时候就开始接收消息了，参数指的是最大可获取的连接数），之后设置死循环，开始获取客户端的连接 <code>accept()</code> ，返回客户端的 <code>socket</code> 和IP地址，之后就可以进行别的操作了。</p>
<p>在这个线程池中，将线程提交到线程池，使用 <code>submit()</code>  ，这个时候，就会在线程池中之行这个线程，之后可以通过 <code>result()</code>  或者 <code>done()</code>  等方法，得到这个线程的执行状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, AF_INET, SOCK_STREAM</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_client</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Handle a client connection</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sock, client_addr = q.get()</span><br><span class="line">    print(<span class="string">'Got connection from'</span>, client_addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        msg = sock.recv(<span class="number">65536</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.sendall(msg)</span><br><span class="line">    print(<span class="string">'Client closed connection'</span>)</span><br><span class="line"></span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_server</span><span class="params">(addr, nworkers)</span>:</span></span><br><span class="line">    <span class="comment"># Launch the client workers</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(nworkers):</span><br><span class="line">        t = Thread(target=echo_client, args=(q,))</span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run the server</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    sock.bind(addr)</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        client_sock, client_addr = sock.accept()</span><br><span class="line">        q.put((client_sock, client_addr))</span><br><span class="line"></span><br><span class="line">echo_server((<span class="string">''</span>,<span class="number">15000</span>), <span class="number">128</span>)</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>Queue</code>  模块，也可以实现线程池的操作，在获得线程的时候，就可以将线程放到队列中，之后在需要的地方在取出来操作。</p>
<p>两者相比来说，使用 <code>ThreadPoolExecutor</code> 相对于手动实现的一个好处在于它使得 任务提交者更方便的从被调用函数中获取返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    u = urllib.request.urlopen(url)</span><br><span class="line">    data = u.read()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">pool = ThreadPoolExecutor(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># Submit work to the pool</span></span><br><span class="line">a = pool.submit(fetch_url, <span class="string">'http://www.python.org'</span>)</span><br><span class="line">b = pool.submit(fetch_url, <span class="string">'http://www.pypy.org'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the results back</span></span><br><span class="line">x = a.result()</span><br><span class="line">y = b.result()</span><br></pre></td></tr></table></figure>
<p>例子中返回的handle对象会帮你处理所有的阻塞与协作，然后从工作线程中返回数据给你。 特别的，<code>a.result()</code> 操作会阻塞进程直到对应的函数执行完成并返回一个结果。</p>
<p>除此之外，还有一个好处就是限制线程的数量，使用线程池的话，在一开始初始化的时候，就可以设定一个线程的最大数量，之后在使用的时候，就不用当心线程数量过多照成的系统问题。</p>
<p>同样的，我们也可以使用限制线程内存的方式，限制开启的线程数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">threading.stack_size(<span class="number">65536</span>)</span><br></pre></td></tr></table></figure>
<h2 id="简单的并行编程"><a href="#简单的并行编程" class="headerlink" title="简单的并行编程"></a>简单的并行编程</h2><p>当我们需要使得 CPU 执行密集型工作的时候，希望利用多核 CPU 同时执行，使得运行速度快一些。</p>
<p><code>concurrent.futures</code> 库提供了一个 <code>ProcessPoolExecutor</code> 类， 可被用来在一个单独的Python解释器中执行计算密集型函数。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p08_perform_simple_parallel_programming.html" target="_blank" rel="noopener">简单的并行编程</a></li>
</ul>
<p>书上的一个例子，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># findrobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_robots</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all of the hosts that access robots.txt in a single log file</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    robots = set()</span><br><span class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> io.TextIOWrapper(f,encoding=<span class="string">'ascii'</span>):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            <span class="keyword">if</span> fields[<span class="number">6</span>] == <span class="string">'/robots.txt'</span>:</span><br><span class="line">                robots.add(fields[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> robots</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all_robots</span><span class="params">(logdir)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all hosts across and entire sequence of files</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    files = glob.glob(logdir+<span class="string">'/*.log.gz'</span>)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    <span class="keyword">for</span> robots <span class="keyword">in</span> map(find_robots, files):</span><br><span class="line">        all_robots.update(robots)</span><br><span class="line">    <span class="keyword">return</span> all_robots</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    robots = find_all_robots(<span class="string">'logs'</span>)</span><br><span class="line">    <span class="keyword">for</span> ipaddr <span class="keyword">in</span> robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，使用 <code>map</code> 方法，<code>map()</code>函数接收两个参数，一个是函数，一个是序列，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</p>
<blockquote>
<p><code>glob</code> 模块，用它可以查找符合特定规则的文件路径名。</p>
<p>glob.glob 获取指定文件夹下面的指定文件，返回所有匹配的文件路径列表。它只有一个参数pathname，定义了文件路径匹配规则，这里可以是绝对路径，也可以是相对路径。</p>
</blockquote>
<p>这个代码是一个 <strong>MapReduce</strong> 的设计思路，<strong>MapReduce</strong>是<a href="https://zh.wikipedia.org/wiki/Google" target="_blank" rel="noopener">Google</a>提出的一个<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">软件架构</a>，用于大规模数据集（大于1<a href="https://zh.wikipedia.org/wiki/Terabyte" target="_blank" rel="noopener">TB</a>）的<a href="https://zh.wikipedia.org/wiki/%E4%B8%A6%E8%A1%8C%E9%81%8B%E7%AE%97" target="_blank" rel="noopener">并行运算</a>。</p>
<p>当前的软件实现是指定一个<em>Map（映射）</em>函数，用来把一组键值对映射成一组新的键值对，指定并发的<em>Reduce（归纳）</em>函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/MapReduce" target="_blank" rel="noopener">MapReduce</a></li>
<li><a href="https://www.zhihu.com/question/23345991" target="_blank" rel="noopener">关于MapReduce的理解？</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317852443934a86aa5bb5ea47fbbd5f35282b331335000" target="_blank" rel="noopener">map/reduce</a></li>
</ul>
<p>函数 <code>find_robots()</code> 在一个文件名集合上做map操作，并将结果汇总为一个单独的结果， 也就是 <code>find_all_robots()</code> 函数中的 <code>all_robots</code> 集合。 </p>
<p>当我们需要采用并发式编程的时候，我们就要采用 <code>concurrent.futures</code> ，把 <code>map</code> 操作替换掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># findrobots.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_robots</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all of the hosts that access robots.txt in a single log file</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    robots = set()</span><br><span class="line">    <span class="keyword">with</span> gzip.open(filename) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> io.TextIOWrapper(f,encoding=<span class="string">'ascii'</span>):</span><br><span class="line">            fields = line.split()</span><br><span class="line">            <span class="keyword">if</span> fields[<span class="number">6</span>] == <span class="string">'/robots.txt'</span>:</span><br><span class="line">                robots.add(fields[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> robots</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_all_robots</span><span class="params">(logdir)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Find all hosts across and entire sequence of files</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    files = glob.glob(logdir+<span class="string">'/*.log.gz'</span>)</span><br><span class="line">    all_robots = set()</span><br><span class="line">    <span class="keyword">with</span> futures.ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> robots <span class="keyword">in</span> pool.map(find_robots, files):</span><br><span class="line">            all_robots.update(robots)</span><br><span class="line">    <span class="keyword">return</span> all_robots</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    robots = find_all_robots(<span class="string">'logs'</span>)</span><br><span class="line">    <span class="keyword">for</span> ipaddr <span class="keyword">in</span> robots:</span><br><span class="line">        print(ipaddr)</span><br></pre></td></tr></table></figure>
<p>而实际的优化效果会依据不同的CPU而决定的。</p>
<p>ProcessPoolExecutor<code>的典型用法是和</code>with` 一起使用的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    ...</span><br><span class="line">    do work <span class="keyword">in</span> parallel using pool</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>书本原画介绍：</p>
<p>其原理是，一个 <code>ProcessPoolExecutor</code> 创建N个独立的Python解释器， N是系统上面可用CPU的个数。你可以通过提供可选参数给 <code>ProcessPoolExecutor(N)</code> 来修改 处理器数量。这个处理池会一直运行到with块中最后一个语句执行完成， 然后处理池被关闭。不过，程序会一直等待直到所有提交的工作被处理完成。</p>
<p>被提交到池中的工作必须被定义为一个函数。有两种方法去提交。 如果你想让一个列表推导或一个 <code>map()</code> 操作并行执行的话，可使用 <code>pool.map()</code> ，如果需要单独提交单个任务的时候，可以使用 <code>pool.submit()</code> 来提交。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A function that performs a lot of work</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(x)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># Nonparallel code</span></span><br><span class="line">results = map(work, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parallel implementation</span></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    results = pool.map(work, data)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># Some function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(x)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># Example of submitting work to the pool</span></span><br><span class="line">    future_result = pool.submit(work, arg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Obtaining the result (blocks until done)</span></span><br><span class="line">    r = future_result.result()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如果你手动提交一个任务，结果是一个 <code>Future</code> 实例。 要获取最终结果，你需要调用它的 <code>result()</code> 方法。 它会阻塞进程直到结果被返回来。如果不想阻塞的话，可以使用一个回调函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">when_done</span><span class="params">(r)</span>:</span></span><br><span class="line">    print(<span class="string">'Got:'</span>, r.result())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">     future_result = pool.submit(work, arg)</span><br><span class="line">     future_result.add_done_callback(when_done)</span><br></pre></td></tr></table></figure>
<p>书本上对使用这个的建议：（尽量保持需要并发执行的函数的简单性）</p>
<p>回调函数接受一个 <code>Future</code> 实例，被用来获取最终的结果（比如通过调用它的 <code>result()</code> 方法）。 尽管处理池很容易使用，在设计大程序的时候还是有很多需要注意的地方，如下几点：</p>
<ul>
<li>这种并行处理技术只适用于那些可以被分解为互相独立部分的问题。</li>
<li>被提交的任务必须是简单函数形式。对于方法、闭包和其他类型的并行执行还不支持。</li>
<li>函数参数和返回值必须兼容pickle，因为要使用到进程间的通信，所有解释器之间的交换数据必须被序列化</li>
<li>被提交的任务函数不应保留状态或有副作用。除了打印日志之类简单的事情，</li>
</ul>
<p>一旦启动你不能控制子进程的任何行为，因此最好保持简单和纯洁——函数不要去修改环境。</p>
<ul>
<li>在Unix上进程池通过调用 <code>fork()</code> 系统调用被创建，</li>
</ul>
<p>它会克隆Python解释器，包括fork时的所有程序状态。 而在Windows上，克隆解释器时不会克隆状态。 实际的fork操作会在第一次调用 <code>pool.map()</code> 或 <code>pool.submit()</code> 后发生。</p>
<ul>
<li>当你混合使用进程池和多线程的时候要特别小心。</li>
</ul>
<p>你应该在创建任何线程之前先创建并激活进程池（比如在程序启动的main线程中创建进程池）。</p>
<h2 id="Python的全局锁问题"><a href="#Python的全局锁问题" class="headerlink" title="Python的全局锁问题"></a>Python的全局锁问题</h2><p>尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。 GIL最大的问题就是Python的多线程程序并不能利用多核CPU的优势 （比如一个使用了多个线程的计算密集型程序只会在一个单CPU上面运行）。</p>
<ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p09_dealing_with_gil_stop_worring_about_it.html" target="_blank" rel="noopener">Python的全局锁问题</a></li>
</ul>
<p>在我们尝试使用多线程来提高程序的运行速度的时候，我们应该更加注重代码算法上的提高，这会比单纯的时候多线程会快上很多。多线程的意义更多的是在于网络编程和图形化编程。</p>
<p>如果你准备使用一个处理器池，注意的是这样做涉及到数据序列化和在不同Python解释器通信。 被执行的操作需要放在一个通过def语句定义的Python函数中，不能是lambda、闭包可调用实例等， 并且函数参数和返回值必须要兼容pickle。 同样，要执行的任务量必须足够大以弥补额外的通信开销。</p>
<h2 id="定义一个Actor任务"><a href="#定义一个Actor任务" class="headerlink" title="定义一个Actor任务"></a>定义一个Actor任务</h2><ul>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p10_defining_an_actor_task.html" target="_blank" rel="noopener">定义一个Actor任务</a></li>
</ul>
<p>一种简单的进行并发和分布式计算的解决方案，只需要一个队列和一个线程就能实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Event</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sentinel used for shutdown</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActorExit</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Actor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._mailbox = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Send a message to the actor</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._mailbox.put(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recv</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Receive an incoming message</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        msg = self._mailbox.get()</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">is</span> ActorExit:</span><br><span class="line">            <span class="keyword">raise</span> ActorExit()</span><br><span class="line">        <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Close the actor, thus shutting it down</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.send(ActorExit)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Start concurrent execution</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self._terminated = Event()</span><br><span class="line">        t = Thread(target=self._bootstrap)</span><br><span class="line"></span><br><span class="line">        t.daemon = <span class="keyword">True</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_bootstrap</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run()</span><br><span class="line">        <span class="keyword">except</span> ActorExit:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._terminated.set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._terminated.wait()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        Run method to be implemented by the user</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample ActorTask</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintActor</span><span class="params">(Actor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            msg = self.recv()</span><br><span class="line">            print(<span class="string">'Got:'</span>, msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sample use</span></span><br><span class="line">p = PrintActor()</span><br><span class="line">p.start()</span><br><span class="line">p.send(<span class="string">'Hello'</span>)</span><br><span class="line">p.send(<span class="string">'World'</span>)</span><br><span class="line">p.close()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>
<p>这个例子中，你使用actor实例的 <code>send()</code> 方法发送消息给它们。 其机制是，这个方法会将消息放入一个队里中， 然后将其转交给处理被接受消息的一个内部线程。 <code>close()</code> 方法通过在队列中放入一个特殊的哨兵值（ActorExit）来关闭这个actor。 用户可以通过继承Actor并定义实现自己处理逻辑run()方法来定义新的actor。 <code>ActorExit</code> 异常的使用就是用户自定义代码可以在需要的时候来捕获终止请求 （异常被get()方法抛出并传播出去）。</p>
<p>这个模式可以这样理解，其中，有个重点，<code>Queue()</code> 队列的 <code>get()</code> 方法是阻塞的，也就是说，在没有获得数据的时候，线程会阻塞在其中等待，直到有数据传递进来后，才开始获得数据，进行接下来的操作。</p>
<p>也就是因为这个特性，才可以在开启新的线程后直接使用死循环等待。</p>
<p>在开始创建这个 <code>Actor</code> 对象并且运行 <code>start</code> 的时候，开启新的线程和新建 <code>Event</code> 事件，之后运行 <code>run</code> 方法，死循环，等待队列中获取数据。</p>
<p>当一条数据传递过来之后（ <code>send</code> ），数据添加到队列中，<code>get</code> 方法获得数据，执行 <code>run</code> 方法的操作。</p>
<p>当执行 <code>close</code> 方法的时候，将 <code>ActorExit</code> 异常丢进队列中，<code>get</code>  方法获得异常的数据，抛出异常，获取异常，跳出循环，将 <code>Event</code> 线程的设置标志。</p>
<p>其中的 <code>Event</code> 事件，实现对线程的管理。可以实现，在把异常放进队列中的之前，对主线程进行阻塞，直到有异常状态放到队列中。</p>
<h2 id="实现消息发布-订阅模型"><a href="#实现消息发布-订阅模型" class="headerlink" title="实现消息发布/订阅模型"></a>实现消息发布/订阅模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exchange</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._subscribers = set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attach</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        self._subscribers.add(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detach</span><span class="params">(self, task)</span>:</span></span><br><span class="line">        self._subscribers.remove(task)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        print(len(self._subscribers))</span><br><span class="line">        print(list(self._subscribers))</span><br><span class="line">        <span class="keyword">for</span> subscriber <span class="keyword">in</span> self._subscribers:</span><br><span class="line">            subscriber.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary of all created exchanges</span></span><br><span class="line">_exchanges = defaultdict(Exchange)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Return the Exchange instance associated with a given name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_exchange</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _exchanges[name]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        print(msg)</span><br><span class="line"></span><br><span class="line">task_a = Task()</span><br><span class="line">task_b = Task()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of getting an exchange</span></span><br><span class="line">exc = get_exchange(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Examples of subscribing tasks to it</span></span><br><span class="line">exc.attach(task_a)</span><br><span class="line">exc.attach(task_b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of sending messages</span></span><br><span class="line">exc.send(<span class="string">'msg1'</span>)</span><br><span class="line">exc.send(<span class="string">'msg2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of unsubscribing</span></span><br><span class="line">exc.detach(task_a)</span><br><span class="line">exc.detach(task_b)</span><br></pre></td></tr></table></figure>
<p>设计模式中的一种，<code>Exchange</code> 类相当于一个交换机的模式，其中有订阅，发送消息等功能，通过 <code>get_exchange</code> 获得该对象，所实现的效果就是，对于需要发送的消息任务来说，可以一次性将消息发送给多个关联任务。</p>
<p>在使用过程中，获得对象，在对象中添加多个任务，发送消息的时候，就可以将消息发送给所有绑定的任务中。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Jaelyn
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://jaelyn.coding.me/2018/05/29/python-cookbook-learning/" title="Python Cookbook 笔记">http://jaelyn.coding.me/2018/05/29/python-cookbook-learning/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python3/" rel="tag"><i class="fa fa-tag"></i> python3</a>
          
            <a href="/tags/Python-CookBook/" rel="tag"><i class="fa fa-tag"></i> Python CookBook</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/15/supervisor-learn/" rel="next" title="Supervisor 指令学习">
                <i class="fa fa-chevron-left"></i> Supervisor 指令学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/05/mac-pycharm-quick-click/" rel="prev" title="Mac 下的 PyCharm 快捷键">
                Mac 下的 PyCharm 快捷键 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Jaelyn" />
            
              <p class="site-author-name" itemprop="name">Jaelyn</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Jaelyn-Lim" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/u/2660619527" target="_blank" title="微博">
                    
                      <i class="fa fa-fw fa-globe"></i>微博</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构和算法"><span class="nav-number">1.</span> <span class="nav-text">数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#星号（-）表达式"><span class="nav-number">1.1.</span> <span class="nav-text">星号（*）表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xrange"><span class="nav-number">1.2.</span> <span class="nav-text">xrange</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield"><span class="nav-number">1.3.</span> <span class="nav-text">yield</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections-deque"><span class="nav-number">1.4.</span> <span class="nav-text">collections.deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heapq"><span class="nav-number">1.5.</span> <span class="nav-text">heapq</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections-defaultdict"><span class="nav-number">1.6.</span> <span class="nav-text">collections.defaultdict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections-OrderedDict"><span class="nav-number">1.7.</span> <span class="nav-text">collections.OrderedDict</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zip"><span class="nav-number">1.8.</span> <span class="nav-text">zip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keys-and-values"><span class="nav-number">1.9.</span> <span class="nav-text">keys and values</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections-Counter"><span class="nav-number">1.10.</span> <span class="nav-text">collections.Counter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operator-itemgetter"><span class="nav-number">1.11.</span> <span class="nav-text">operator.itemgetter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operator-attrgetter"><span class="nav-number">1.12.</span> <span class="nav-text">operator.attrgetter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#itertools-groupby"><span class="nav-number">1.13.</span> <span class="nav-text">itertools.groupby</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#filter"><span class="nav-number">1.14.</span> <span class="nav-text">filter()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典推导"><span class="nav-number">1.15.</span> <span class="nav-text">字典推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections-namedtuple"><span class="nav-number">1.16.</span> <span class="nav-text">collections.namedtuple()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections-ChainMap"><span class="nav-number">1.17.</span> <span class="nav-text">collections.ChainMap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串和文本"><span class="nav-number">2.</span> <span class="nav-text">字符串和文本</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串开头或结尾匹配"><span class="nav-number">2.1.</span> <span class="nav-text">字符串开头或结尾匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fnmatch-和-fnmatchcase"><span class="nav-number">2.2.</span> <span class="nav-text">fnmatch() 和 fnmatchcase()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#re-sub"><span class="nav-number">2.3.</span> <span class="nav-text">re.sub()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#re-IGNORECASE"><span class="nav-number">2.4.</span> <span class="nav-text">re.IGNORECASE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#re-DOTALL"><span class="nav-number">2.5.</span> <span class="nav-text">re.DOTALL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unicodedata"><span class="nav-number">2.6.</span> <span class="nav-text">unicodedata</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strip"><span class="nav-number">2.7.</span> <span class="nav-text">strip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ljust、rjust、center"><span class="nav-number">2.8.</span> <span class="nav-text">ljust、rjust、center</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#format-map-和-vars"><span class="nav-number">2.9.</span> <span class="nav-text">format_map 和 vars</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#textwrap"><span class="nav-number">2.10.</span> <span class="nav-text">textwrap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html-escape"><span class="nav-number">2.11.</span> <span class="nav-text">html.escape</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串令牌解析"><span class="nav-number">2.12.</span> <span class="nav-text">字符串令牌解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现一个简单的递归下降分析器"><span class="nav-number">2.13.</span> <span class="nav-text">实现一个简单的递归下降分析器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数字日期和时间"><span class="nav-number">3.</span> <span class="nav-text">数字日期和时间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#round"><span class="nav-number">3.1.</span> <span class="nav-text">round</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#decimal"><span class="nav-number">3.2.</span> <span class="nav-text">decimal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fractions"><span class="nav-number">3.3.</span> <span class="nav-text">fractions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NumPy"><span class="nav-number">3.4.</span> <span class="nav-text">NumPy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#random"><span class="nav-number">3.5.</span> <span class="nav-text">random</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#datetime-amp-timedelta"><span class="nav-number">3.6.</span> <span class="nav-text">datetime &amp; timedelta</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器和生成器"><span class="nav-number">4.</span> <span class="nav-text">迭代器和生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#next"><span class="nav-number">4.1.</span> <span class="nav-text">next()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iter"><span class="nav-number">4.2.</span> <span class="nav-text">iter()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现深度优先的遍历的树形结构"><span class="nav-number">4.3.</span> <span class="nav-text">实现深度优先的遍历的树形结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reversed"><span class="nav-number">4.4.</span> <span class="nav-text">reversed()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带有外部状态的生成器函数"><span class="nav-number">4.5.</span> <span class="nav-text">带有外部状态的生成器函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#itertools-islice"><span class="nav-number">4.6.</span> <span class="nav-text">itertools.islice()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#itertools-dropwhile"><span class="nav-number">4.7.</span> <span class="nav-text">itertools.dropwhile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#itertools-permutations-和-itertools-combinations"><span class="nav-number">4.8.</span> <span class="nav-text">itertools.permutations 和 itertools.combinations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#enumerate"><span class="nav-number">4.9.</span> <span class="nav-text">enumerate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同时迭代多个序列"><span class="nav-number">4.10.</span> <span class="nav-text">同时迭代多个序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#itertools-chain"><span class="nav-number">4.11.</span> <span class="nav-text">itertools.chain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield-from"><span class="nav-number">4.12.</span> <span class="nav-text">yield from</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heapq-merge"><span class="nav-number">4.13.</span> <span class="nav-text">heapq.merge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器代替while无限循环"><span class="nav-number">4.14.</span> <span class="nav-text">迭代器代替while无限循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件与IO"><span class="nav-number">5.</span> <span class="nav-text">文件与IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#读写文本数据"><span class="nav-number">5.1.</span> <span class="nav-text">读写文本数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sep"><span class="nav-number">5.2.</span> <span class="nav-text">sep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写字节数据"><span class="nav-number">5.3.</span> <span class="nav-text">读写字节数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-StringIO-和-io-BytesIO"><span class="nav-number">5.4.</span> <span class="nav-text">io.StringIO 和 io.BytesIO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gzip-和-bz2"><span class="nav-number">5.5.</span> <span class="nav-text">gzip 和 bz2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functools-partial"><span class="nav-number">5.6.</span> <span class="nav-text">functools.partial</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#os-path"><span class="nav-number">5.7.</span> <span class="nav-text">os.path</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#os-listdir"><span class="nav-number">5.8.</span> <span class="nav-text">os.listdir</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tempfile"><span class="nav-number">5.9.</span> <span class="nav-text">tempfile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pickle"><span class="nav-number">5.10.</span> <span class="nav-text">pickle</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据编码和处理"><span class="nav-number">6.</span> <span class="nav-text">数据编码和处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#csv"><span class="nav-number">6.1.</span> <span class="nav-text">csv</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写JSON数据"><span class="nav-number">6.2.</span> <span class="nav-text">读写JSON数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xml-etree-ElementTree"><span class="nav-number">6.3.</span> <span class="nav-text">xml.etree.ElementTree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与关系型数据库的交互"><span class="nav-number">6.4.</span> <span class="nav-text">与关系型数据库的交互</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#base64"><span class="nav-number">6.5.</span> <span class="nav-text">base64</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取嵌套和可变长二进制数据"><span class="nav-number">6.6.</span> <span class="nav-text">读取嵌套和可变长二进制数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pandas"><span class="nav-number">6.7.</span> <span class="nav-text">pandas</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#接受任意数量参数的函"><span class="nav-number">7.1.</span> <span class="nav-text">接受任意数量参数的函</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给函数参数增加元信息"><span class="nav-number">7.2.</span> <span class="nav-text">给函数参数增加元信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义有默认参数的函数"><span class="nav-number">7.3.</span> <span class="nav-text">定义有默认参数的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda表达式"><span class="nav-number">7.4.</span> <span class="nav-text">lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functools-partial-1"><span class="nav-number">7.5.</span> <span class="nav-text">functools.partial</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将单方法的类转换为函数"><span class="nav-number">7.6.</span> <span class="nav-text">将单方法的类转换为函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带额外状态信息的回调函数"><span class="nav-number">7.7.</span> <span class="nav-text">带额外状态信息的回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联回调函数"><span class="nav-number">7.8.</span> <span class="nav-text">内联回调函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类与对象"><span class="nav-number">8.</span> <span class="nav-text">类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#让对象支持上下文管理协议"><span class="nav-number">8.1.</span> <span class="nav-text">让对象支持上下文管理协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slots"><span class="nav-number">8.2.</span> <span class="nav-text">slots</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在类中封装属性名"><span class="nav-number">8.3.</span> <span class="nav-text">在类中封装属性名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建可管理的属性"><span class="nav-number">8.4.</span> <span class="nav-text">创建可管理的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承"><span class="nav-number">8.5.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建新的类或实例属性"><span class="nav-number">8.6.</span> <span class="nav-text">创建新的类或实例属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用延迟计算属性"><span class="nav-number">8.7.</span> <span class="nav-text">使用延迟计算属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简化数据结构的初始化"><span class="nav-number">8.8.</span> <span class="nav-text">简化数据结构的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abc"><span class="nav-number">8.9.</span> <span class="nav-text">abc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现数据模型的类型约束"><span class="nav-number">8.10.</span> <span class="nav-text">实现数据模型的类型约束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collections"><span class="nav-number">8.11.</span> <span class="nav-text">collections</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#functools-total-ordering"><span class="nav-number">8.12.</span> <span class="nav-text">functools.total_ordering</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#元编程"><span class="nav-number">9.</span> <span class="nav-text">元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#wraps"><span class="nav-number">9.1.</span> <span class="nav-text">wraps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器（修饰器）"><span class="nav-number">9.2.</span> <span class="nav-text">装饰器（修饰器）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义一个带参数的装饰器"><span class="nav-number">9.3.</span> <span class="nav-text">定义一个带参数的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可自定义属性的装饰器"><span class="nav-number">9.4.</span> <span class="nav-text">可自定义属性的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带可选参数的装饰器"><span class="nav-number">9.5.</span> <span class="nav-text">带可选参数的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用装饰器强制函数上的类型检查"><span class="nav-number">9.6.</span> <span class="nav-text">利用装饰器强制函数上的类型检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用元类控制实例的创建"><span class="nav-number">9.7.</span> <span class="nav-text">使用元类控制实例的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义有可选参数的元类"><span class="nav-number">9.8.</span> <span class="nav-text">定义有可选参数的元类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inspect"><span class="nav-number">9.9.</span> <span class="nav-text">inspect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#types-new-class"><span class="nav-number">9.10.</span> <span class="nav-text">types.new_class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免重复的属性方法"><span class="nav-number">9.11.</span> <span class="nav-text">避免重复的属性方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ast"><span class="nav-number">9.12.</span> <span class="nav-text">ast</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块与包"><span class="nav-number">10.</span> <span class="nav-text">模块与包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#all"><span class="nav-number">10.1.</span> <span class="nav-text">__all__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将模块分割成多个文件"><span class="nav-number">10.2.</span> <span class="nav-text">将模块分割成多个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用命名空间导入目录分散的代码"><span class="nav-number">10.3.</span> <span class="nav-text">利用命名空间导入目录分散的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#main"><span class="nav-number">10.4.</span> <span class="nav-text">__main__</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#importlib-import-module"><span class="nav-number">10.5.</span> <span class="nav-text">importlib.import_module</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装私有的包"><span class="nav-number">10.6.</span> <span class="nav-text">安装私有的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pyvenv"><span class="nav-number">10.7.</span> <span class="nav-text">pyvenv</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络与Web编程"><span class="nav-number">11.</span> <span class="nav-text">网络与Web编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#urllib-request"><span class="nav-number">11.1.</span> <span class="nav-text">urllib.request</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络与web"><span class="nav-number">12.</span> <span class="nav-text">网络与web</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建TCP服务器"><span class="nav-number">12.1.</span> <span class="nav-text">创建TCP服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ipaddress"><span class="nav-number">12.2.</span> <span class="nav-text">ipaddress</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cgi"><span class="nav-number">12.3.</span> <span class="nav-text">cgi</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发编程"><span class="nav-number">13.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#启动与停止线程"><span class="nav-number">13.1.</span> <span class="nav-text">启动与停止线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断线程是否已经启动"><span class="nav-number">13.2.</span> <span class="nav-text">判断线程是否已经启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间通信"><span class="nav-number">13.3.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock-对象"><span class="nav-number">13.4.</span> <span class="nav-text">Lock 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个线程池"><span class="nav-number">13.5.</span> <span class="nav-text">创建一个线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的并行编程"><span class="nav-number">13.6.</span> <span class="nav-text">简单的并行编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python的全局锁问题"><span class="nav-number">13.7.</span> <span class="nav-text">Python的全局锁问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义一个Actor任务"><span class="nav-number">13.8.</span> <span class="nav-text">定义一个Actor任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现消息发布-订阅模型"><span class="nav-number">13.9.</span> <span class="nav-text">实现消息发布/订阅模型</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jaelyn</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">64.0k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>



<script>
  	var _mtac = {};
  	(function() {
  		var mta = document.createElement("script");
  		mta.src = "https://pingjs.qq.com/h5/stats.js?v2.0.4";
  		mta.setAttribute("name", "MTAH5");
  		mta.setAttribute("sid", "500569228");

  		var s = document.getElementsByTagName("script")[0];
  		s.parentNode.insertBefore(mta, s);
  	})();
</script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=64866827";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  


  

  <script>
    var _mtac = {};
    (function() {
      var mta = document.createElement("script");
      mta.src = "http://pingjs.qq.com/h5/stats.js?v2.0.2";
      mta.setAttribute("name", "MTAH5");
      mta.setAttribute("sid", "500569228");
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(mta, s);
    })();
  </script>

  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
  
</body>
</html>
